[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:extend_output How to add a new destination type]


Suppose there is a type `foobar` and we want to create a function named `write` that takes a `foobar&` as a parameter and that can be used in the same way as the others [link output_types leading expressions]

[#OutputWriterConcept]

[variablelist
  [ [Step1]
    [ Create a class - let's call it `foobar_writer` - that satisfies the following requirements:
      [itemized_list
        [ It is a concrete class that derives from the abstract class
          [link output_writer `output_writer<`[~CharT]`>`], where [~CharT]
          is `char`, `char16_t`, `char32_t` or `wchar_t`
          ( or rather, make `foobar_writer` a class template ).
        ]
        [ The type of the first parameter of its constructor must be
          `boost::stringify::v0::output_writer_init<CharT>`. It must
           be used to construct the [link output_writer
           `output_writer<`[~CharT]`>`] base class.
        ]
        [ [#OutputWriter_reserve] [_Optionally], it may contain a
          [*`reserve(std::size_t size)`] public member function. If present,
          this function is called no more than once, and only before any of the
          writing functions ( [link output_writer `output_writer::put`] ),
          and according to the use of [link syntax_reserve `reserve_auto()`,
          `reserve()` or `no_reserve()`] in the [link syntax_diagram basic
          invocation syntax]. The parameter tells how many characters will
          be written before `finish()` is called.
        ]
        [ It has a [*`finish()`] public member function. This function is called
          just before `foobar_writer` is destroyed. Its returned value is what
          the expression [~leading_expression]` ... (` [~args]` ...)` returns.
        ]
      ] [/itemized_list]

      [tip Consider deriving your class from [link buffered_writer
        `buffered_writer`] instead of directly from [link output_writer
        `output_writer`]. It demands much less work.
      ] [/tip]
    ]
  ]

  [ [Step2]
    [ Define the [link syntax_diagram [~leading_expression]]. So we can define
      our function `write` ( or use whatever name you prefer ) like this:
      ```
        auto write(foobar& destination)
        {
           return boost::stringify::make_destination<foobar_writer, foobar&>(destination);
        }
      ```
      The `make_destination` function template is declared as:
      
      ```
      namespace boost{ namespace stringify{ inline namespace v0{
      
      template <typename OutputWriter, typename ... Args>
      constexpr auto make_destination(Args ... args) -> /* implementation_defined */;
      
      }}}
      ```
      The `make_destination` parameters are later forwarded as the remaining
      arguments to the `OutputWriter` constructor, after the first argument
      whose type is `output_writer_init<CharT>` and that is internally
      passed by the library.
    
      [important Note that the parameters list of `make_destination`
        is `(Args ... arg)` and [_not] `(Args `[*`&&`]` ... args)`.
        Hence, if you want to pass a parameter by reference,
        then template type deduction won't do what you want.
        You must to explicitly specify the type of each argument,
        as done in the example above ]
    ]
  ]
]

[#buffered_writer]
[h3 The `buffered_writer` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class buffered_writer: public output_writer<CharT>
{
public:

    buffered_writer(output_writer_init<CharT>, CharT* buffer, std::size_t buffer_size);

    virtual ~buffered_writer();

    expected<void, std::error_code> finish(); // calls flush()

    // it implements for you all pure virtual function of output_writer:
    virtual void set_error(std::error_code err) override;
    virtual bool good() const override;
    virtual bool put(const CharT* str, std::size_t size) final;
    virtual bool put(CharT ch) final;
    virtual bool put(std::size_t count, CharT ch) final;
    virtual bool put(piecemeal_input<CharT>& src) final;

protected:

    // ... so that you only have to override this one:
    virtual bool do_put(const CharT* str, std::size_t count) = 0;

    bool flush();  // flush the buffer ( calls do_put )
};

}}} // namespace boost::stringify::v0
``

A `buffered_writer` sub-object shall be the only one that directly writes into the buffer used to construct it (until, of course, it is destroyed). 


[/
The derived class shall not access that buffer ( except in the `do_put` function, since the parameter `str` will be aways in range \u005B`buffer, buffer + buffer_size`), and `str + count` in \u005b`buffer, buffer + buffer_size`\u005D ) 
]
[/
The `do_put` function is called by `flush()`, and the argument `str` will be aways in range \u005B`buffer, buffer + buffer_size`), and `str + count` in \u005b`buffer, buffer + buffer_size`\u005D;
]
[/
You may be wondering, why the comment says that `flush()` or `discard()` shall be called in the destructor? You know the buffer should be empty at such time, since `finish_error_code()` or `finish_exception()` must have been called. But not if an exception has been thrown. So you shall decide whether the remaining content in the buffer should be flushed or discarded in this case.
]


[#output_writer]
[h3 The `output_writer` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template<typename CharT>
class output_writer
{
public:

    using char_type = CharT;

    output_writer(output_writer_init<CharT>)

    virtual ~output_writer();

    virtual void set_error(std::error_code err) = 0;

    virtual bool good() const = 0;

    virtual bool put(const CharT* str, std::size_t size) = 0;

    virtual bool put(CharT ch) = 0;

    virtual bool put(std::size_t count, CharT ch) = 0;

    virtual bool put(piecemeal_input<CharT>& pmw) = 0;

    std::size_t necessary_size(char32_t ch) const;

    bool put32(char32_t ch);

    bool put32(std::size_t count, char32_t ch);

    template<typename CharIn>
    bool put( const stringify::v0::transcoder<CharIn, CharOut>& trans
            , const CharIn* src_begin
            , const CharIn* src_end );

    const stringify::v0::encoder<CharOut>& encoder() const;

    stringify::v0::encoding<CharOut> encoding() const;

    bool allow_surrogates() const;

    const auto& on_encoding_error() const;
};

}}} // namespace boost::stringify::v0
``

* The `repeat` function shall attempt to write [~count] times the sequence of character [~ch1], [~ch2], ... , and return `true` on success and `false` on failure.

* `put(CharT ch)` shall attempt to write the character [~ch] and return `true` on success and `false` on failure.

* `put(const CharT* str, std::size_t size)` shall attempt to write the first [~size] characters of [~str], and return `true` on success and `false` on failure.

* `put(piecemeal_input<CharT>& pmw)` implementation shall be equivalent to this:

``
bool put(boost::stringify::piecemeal_input<char_type>& src)
{
    if (!this->good())
    {
        return false;
    }
    while (true)
    {
        CharT buff[boost::stringify::min_buff_size];
        CharT* const buff_end = buff + (sizeof[buff] / sizeof(CharT));
        
        auto it = pmw.get_some(buff, buff_end);
        if (!pmw.more())
        {
            if (pmw.success())
            {
                return true;
            }
            this->set_error(pmw.get_error())
            return false;
        }
        if (!this->put(buff, (it - buff)))
        {
            return false;
        }
    }
    return true;
}
``

*  Once the function `set_error` is called, `good()` shall return `false`.

*  `good()` returns whether this `output_writer` instance is capable of writing more characters. Once `good()` returns false, it shall not return `true` anymore, and all the `put` overloads shall have no effect and return `false`.

[#piecemeal_input]
[h4 The `piecemeal_input` class template]
``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class piecemeal_input
{
public:

    virtual CharT* get_some(CharT* dest_begin, CharT* dest_end) = 0;

    bool more() const;
    bool success() const;
    std::error_code get_error() const;

protected:

    void report_success();
    void report_error(std::error_code);
};

}}} // namespace boost::stringify::v0
``

`get_some(dest_begin, dest_end)` shall write into `dest_begin`
a part of the content and returns the pointer immediately after
the last written location, which must not be greater than `dest_end`.
It is expected to be called successively until `more()` returns `false`,
and each call shall write the continuation of the previously written part.
When there is nothing else to be written, `get_some(dest_begin, dest_end)`
shall call either `report_success()` or `report_error(`[~some_error_code]`)`,
which in turn causes `more()` to return `false`.

[#min_buff_size]
If `(dest_end - dest_begin < `[*`min_buff_size`]`)`
then `get_some(dest_begin, dest_end)` is not required to write
anything and may just return `dest_begin`, expecting a larger
output range to be passed in the next call.
Otherwise, it is required to write some part of the content.
The caller, on the other hand, must be aware that
if the passed range is smaller than `min_buff_size` is all calls,
then an infinite loop may occur.

Currently `min_buff_size` is defined as:

``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

} } }
``



[h3 Examples]

* [@../../example/extend_output_toQString.cpp extend_output_toQString.cpp]: This file implements `toQString`, which is an equivalent to `to_string` that creates an QString ( from Qt framework ) instead.

You can also see how the [link output_types output types] currently supported by the library are implemented:

* [@../../include/boost/stringify/v0/output_types/std_string.hpp    std_string.hpp] : This is the source file that implements [*`append`],  [*`assign`] [*`to_string`], [*`to_u16string`], [*`to_u32string`], [*`to_wstring`] and [*`to_basic_string`].
* [@../../include/boost/stringify/v0/output_types/char_ptr.hpp char_ptr.hpp] : This is the source file implements the [*`format`] function templates that write to raw strings.
* [@../../include/boost/stringify/v0/output_types/std_streambuf.hpp std_streambuf.hpp] : This is the source file that implements the [*`format`] function template that writes to `std::streambuff`.
* [@../../include/boost/stringify/v0/output_types/FILE.hpp FILE.hpp] : This is the source file that implements the [*`format`] and [*`wformat`] function templates that writes to `FILE*`.


[endsect]