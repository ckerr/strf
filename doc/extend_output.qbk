[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:extend_output How to add a new destination type]


Suppose there is a type `foobar` and we want to create a function named `write` that takes a `foobar&` as a parameter and that can be used in the same way as the others [link output_types leading expressions]

[#OutputBufferConcept]

[variablelist
  [ [Step1]
    [ Create a class - let's call it `foobar_writer` - that satisfies the following requirements:
      [itemized_list
        [ It is a concrete class that derives from the abstract class
          [link output_buffer `output_buffer<`[~CharT]`>`], where [~CharT]
          is `char`, `char16_t`, `char32_t` or `wchar_t`
          ( or rather, make `foobar_writer` a class template ).
        ]
        [ [#OutputBuffer_reserve] [_Optionally], it may contain a
          [*`reserve(std::size_t size)`] public member function. If present,
          this function is called no more than once, and just after the
          constructor,
          and according to the use of [link syntax_reserve `reserve_auto()`,
          `reserve()` or `no_reserve()`] in the [link syntax_diagram basic
          invocation syntax]. The parameter tells how many characters will
          be written before `finish()` is called.
        ]
        [ It has a [*`finish()`] public member function. This function is called
          just before `foobar_writer` is destroyed. Its returned value is what
          the expression [~leading_expression]` ... (` [~args]` ...)` returns.
        ]
      ] [/itemized_list]
    ]
  ]

  [ [Step2]
    [ Define the [link syntax_diagram [~leading_expression]]. So we can define
      our function `write` ( or use whatever name you prefer ) like this:
      ```
        auto write(foobar& destination)
        {
           return boost::stringify::make_destination<foobar_writer, foobar&>(destination);
        }
      ```
      The `make_destination` function template is declared as:
      
      ```
      namespace boost{ namespace stringify{ inline namespace v0{
      
      template <typename OutputBuffer, typename ... Args>
      constexpr auto make_destination(Args ... args) -> /* implementation_defined */;
      
      }}}
      ```
      The `make_destination` parameters are later forwarded to the constructor
      of `OutputBuffer` constructor
    
      [important Note that the parameters list of `make_destination`
        is `(Args ... arg)` and [_not] `(Args `[*`&&`]` ... args)`.
        Hence, if you want to pass a parameter by reference,
        then template type deduction won't do what you want.
        You must to explicitly specify the type of each argument,
        as done in the example above ]
    ]
  ]
]


[h3 Examples]

* [@../../example/extend_output_toQString.cpp extend_output_toQString.cpp]: This file implements `toQString`, which is an equivalent to `to_string` that creates an QString ( from Qt framework ) instead.

You can also see how the [link output_types output types] currently supported by the library are implemented:

* [@../../include/boost/stringify/v0/output_types/std_string.hpp    std_string.hpp] : This is the source file that implements [*`append`],  [*`assign`] [*`to_string`], [*`to_u16string`], [*`to_u32string`], [*`to_wstring`] and [*`to_basic_string`].
* [@../../include/boost/stringify/v0/output_types/char_ptr.hpp char_ptr.hpp] : This is the source file implements the [*`format`] function templates that write to raw strings.
* [@../../include/boost/stringify/v0/output_types/std_streambuf.hpp std_streambuf.hpp] : This is the source file that implements the [*`format`] function template that writes to `std::streambuff`.
* [@../../include/boost/stringify/v0/output_types/FILE.hpp FILE.hpp] : This is the source file that implements the [*`format`] and [*`wformat`] function templates that writes to `FILE*`.


[endsect]