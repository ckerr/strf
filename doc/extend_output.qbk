[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:extend_output How to add a new destination type]


Suppose there is a type `foobar` and we want to create a function named `write` that takes a `foobar&` as a parameter and that can be used in the same way as the others [link output_types leading expressions]

[#OutputBufferConcept]

[variablelist
  [ [Step1]
    [ Create a class - let's call it `foobar_writer` - that satisfies the following requirements:
      [itemized_list
        [ It is a concrete class that derives from the abstract class
          [link output_buffer `output_buffer<`[~CharT]`>`], where [~CharT]
          is `char`, `char16_t`, `char32_t` or `wchar_t`
          ( or rather, make `foobar_writer` a class template ).
        ]
        [ [#OutputBuffer_reserve] [_Optionally], it may contain a
          [*`reserve(std::size_t size)`] public member function. If present,
          this function is called no more than once, and just after the
          constructor,
          and according to the use of [link syntax_reserve `reserve_auto()`,
          `reserve()` or `no_reserve()`] in the [link syntax_diagram basic
          invocation syntax]. The parameter tells how many characters will
          be written before `finish()` is called.
        ]
        [ It has a [*`finish()`] public member function. This function is called
          just before `foobar_writer` is destroyed. Its returned value is what
          the expression [~leading_expression]` ... (` [~args]` ...)` returns.
        ]
      ] [/itemized_list]
    ]
  ]

  [ [Step2]
    [ Define the [link syntax_diagram [~leading_expression]]. So we can define
      our function `write` ( or use whatever name you prefer ) like this:
      ```
        auto write(foobar& destination)
        {
           return boost::stringify::make_destination<foobar_writer, foobar&>(destination);
        }
      ```
      The `make_destination` function template is declared as:
      
      ```
      namespace boost{ namespace stringify{ inline namespace v0{
      
      template <typename OutputBuffer, typename ... Args>
      constexpr auto make_destination(Args ... args) -> /* implementation_defined */;
      
      }}}
      ```
      The `make_destination` parameters are later forwarded to the constructor
      of `OutputBuffer` constructor
    
      [important Note that the parameters list of `make_destination`
        is `(Args ... arg)` and [_not] `(Args `[*`&&`]` ... args)`.
        Hence, if you want to pass a parameter by reference,
        then template type deduction won't do what you want.
        You must to explicitly specify the type of each argument,
        as done in the example above ]
    ]
  ]
]

[#output_buffer]
[h3 The `output_buffer` class template]

[#min_buff_size]
``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

template <typename CharT>
class output_buffer
{
public:

    using char_type = CharT;

    virtual ~output_buffer();

    virtual bool recycle() = 0;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;

    void advance_to(CharT* p) noexcept;
    void advance(std::size_t n) noexcept;

    void set_error(std::error_code ec) noexcept;
    void set_error(std::errc e) noexcept;
    void set_encoding_error() noexcept;
    std::error_code get_error() const noexcept;
    bool has_error() const noexcept;

protected:

    output_buffer(CharT* buff_begin, CharT* buff_end) noexcept;
    output_buffer(CharT* buff_begin, std::size_t buff_size) noexcept;

    void set_pos(CharT* p) noexcept;
    void set_end(CharT* e) noexcept;
};

}}} // namespace boost::stringify::v0
``
[table
[[`public: virtual bool recycle() = 0;`]]
[[[variablelist
     [[ Effects]
      [ Consumes the content in the range \u005B ['initial_pos],
       `pos()` \u0029 , where ['initial_pos] is value returned by `pos()`
        before any call to `advance()`  and `advance_to(p)` and after
        the previous call to `recycle()`.]
      [ On success, calls `set_pos(`[~new_pos]`)` and optionally
        `set_end(`[~new_end]`)`.
        On failure, calls `set_error(`[~some_error]`)`.  ]]
     [[ Return value]
      [ `true` on success and `false` otherwise.]]
     [[ Postcondition]
      [ on sucess: size() >= min_buff_size]]]]]]

[table
[[`public: std::size_t size() const noexcept;`]]
[[[variablelist
   [[Return value]
    [`end() - pos()`]]]]]]

[table
[[`public: char_type* pos() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The memory position where the content shall be written]]]]]]

[table
[[`public: char_type* end() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The end of memory position where the content shall be written]]]]]]

[table
[[`public: void advance_to(char_type* p) noexcept;`]]
[[[variablelist
   [[Effect]
      [update pos] ]
   [[Precondition]
      [`pos() <= p && p <= end()`] ]
   [[Postcondition]
      [`pos() == p`]]]]]]

[table
[[`public: void advance(std::size_t n) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`pos() + n <= end()`] ]
  [[Effect]
     [same as `advance(pos() + n)`]]]]]]

[table
[[`public: void set_error(std::error_code ec) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`has_error() == true`]]]]]]
     
[table
[[`public: void set_error(std::errc e) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::make_error_code(e))`]]]]]]
    
[table
[[`public: void set_encoding_error() noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::errc::illegal_byte_sequence)`]]]]]]

[table
[[`public: std::error_code get_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [The value passed to `set_error` the first time it was called]]]]]]

[table
[[`public: bool has_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [Whether `set_error` has been called ]]]]]]

[table
[[`protected: void set_pos(char_type* p) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`pos() == p`]]]]]]

[table
[[`protected: void set_end(char_type* e) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`end() == e`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, char_type* buff_end) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`buff_begin <= buff_end`]]
  [[Postconditions]
     [\u2022 `pos() == buff_begin` ]
     [\u2022 `pos() == buff_end`   ]
     [\u2022 `has_error() == false`]
     [\u2022 `get_error() == std::error_code{}`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, std::size_t buff_size) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `output_buffer(buff_begin, buff_begin + buff_size)` ]]]]]]
     

[h3 Examples]

* [@../../example/extend_output_toQString.cpp extend_output_toQString.cpp]: This file implements `toQString`, which is an equivalent to `to_string` that creates an QString ( from Qt framework ) instead.

You can also see how the [link output_types output types] currently supported by the library are implemented:

* [@../../include/boost/stringify/v0/output_types/std_string.hpp    std_string.hpp] : This is the source file that implements [*`append`],  [*`assign`] [*`to_string`], [*`to_u16string`], [*`to_u32string`], [*`to_wstring`] and [*`to_basic_string`].
* [@../../include/boost/stringify/v0/output_types/char_ptr.hpp char_ptr.hpp] : This is the source file implements the [*`format`] function templates that write to raw strings.
* [@../../include/boost/stringify/v0/output_types/std_streambuf.hpp std_streambuf.hpp] : This is the source file that implements the [*`format`] function template that writes to `std::streambuff`.
* [@../../include/boost/stringify/v0/output_types/FILE.hpp FILE.hpp] : This is the source file that implements the [*`format`] and [*`wformat`] function templates that writes to `FILE*`.


[endsect]