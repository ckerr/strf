[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section:extend_output How to add support to a new destination type]


Suppose you have a type `foobar` and you want to create a function named `format` that takes a `foobar&` as a parameter and can be used just like the [link output_types other functions]

[#OutputWriterConcept]
[*Step 1)] Create a class - let's call it `foobar_writer` - that satisfies the following requirements:

* it is a concrete class that derives from the abstract class [link output_writer `output_writer<`[~CharT]`>`], where [~CharT] is `char`, `char16_t`, `char32_t` or `wchar_t` ( or rather, make `foobar_writer` a class template as well).
* has a [*`finish()`] public member function. This function will be called just before `foobar_writer` is destroyed. Its return is returned by the expression [~leading_expression]` ... (` [~args]` ...)` 
* [#OutputWriter_reserve] [_optionally], it may contain a [*`reserve(std::size_t size)`] public member function. If present, this function is called (or not) according to the use of [link syntax_reserve `reserve_auto()`, `reserve()` or `no_reserve()`] in the [link syntax_diagram basic invocation syntax]. The parameter `size` tells how many characters will be written. This function will be called no more than once, and only before any of the writing functions (the [link output_writer `put`] overloads). The argument will be the total number of characters that will be written until `finish_error_code()` of `finish_exception()` is called.
* The first parameter of its constructor must be of type `boost::stringify::v0::output_writer_init<CharT>`. It must be used to construct the [link output_writer `output_writer<`[~CharT]`>`] base class.

[*Step 2)] Define the [link syntax_diagram [~leading_expression]]. Usually this imples to create function `write` ( or whatever name you prefer ) like below.

```
  auto write(foobar& destination)
  {
     return boost::stringify::make_destination<foobar_writer, foobar&>(destination);
  }
```
The argument(s) passed to function template `make_destination` will be used to construct `foobar_writer`. Its signature is:

```
template <typename OutputWriter, typename ... Args>
constexpr auto make_destination(Args ... args) -> /* implementation_defined */;
```
The arguments passed to `make_destination` will be used to as the remaining arguments used to construct `OutputWriter` ( after the `output_writer_init<CharT>` wich must be the first parameter of the constructor ).

[important Note that the parameters list of `make_destination` is `(Args ... arg)` and [_not] `(Args `[*`&&`]` ... args)`. Hence, if you want to pass a parameter by reference, template type deduction won't do what you want. You must specify the type of each argument, as done in the example above ]



[/
Given

* `W`, a type that satisfies `OutputWriter` concept
* `w`, an object of type `W`
* `ch`, a value of type `W::char_type`
* `str`, a pointer of `W::char_type`
* `i`, `n`, values of type `std::size_t`

[table
[ [Expression]       [Return type] [Description] ]
[ [`W::char_type`]   []      [The character type (`char`, `wchar_t`, `char32_t` or `char16_t`)] ]
[ [`w.finish_error_code()`]  [anything] [ Finalizes the writing process. ]]
[ [`w.finish_exception()`]   [anything] [ Finalizes the writing process. ]]
]
]

[h3 The `output_writer` class template]

[#output_writer]
``
namespace boost { namespace stringify { inline namespace v0 {

template<typename CharT>
class output_writer
{
public:

    using char_type = CharT;

    output_writer(output_writer_init<CharT>)

    virtual ~output_writer();

    virtual void set_error(std::error_code err) = 0;

    virtual bool good() const = 0;

    virtual bool put(const CharT* str, std::size_t size) = 0;

    virtual bool put(CharT ch) = 0;

    virtual bool put(std::size_t count, CharT ch) = 0;

    virtual bool put(piecemeal_writer<CharT>& pmw) = 0;

    std::size_t necessary_size(char32_t ch) const;

    bool put32(char32_t ch);

    bool put32(std::size_t count, char32_t ch);

    template<typename CharIn>
    bool put( const stringify::v0::transcoder<CharIn, CharOut>& trans
            , const CharIn* src_begin
            , const CharIn* src_end );

    const stringify::v0::encoder<CharOut>& encoder() const;

    stringify::v0::encoding<CharOut> encoding() const;

    bool allow_surrogates() const;

    const auto& on_encoding_error() const;
};

}}} // namespace boost::stringify::v0
``

* The `repeat` function shall attempt to write [~count] times the sequence of character [~ch1], [~ch2], ... , and return `true` on success and `false` on failure.

* `put(CharT ch)` shall attempt to write the character [~ch] and return `true` on success and `false` on failure.

* `put(const CharT* str, std::size_t size)` shall attempt to write [~size] character of [~str], /i.e./ the range `[str[0], str[size])`, and return `true` on success and `false` on failure.

* `put(piecemeal_writer<CharT>& pmw)` shall successively call `it2 = pmw.write(it, end)` and write the range \[`it, it2`) after each call until `pmw.more()` returns `false`

*  Once the function `set_error` is called, `good()` shall return `false`.

*  `good()` returns whether this `output_writer` instance is capable of writing more characters. Once `good()` returns false, it shall not return `true` anymore, and all the `put` overloads shall have no effect and return `false`.

[#piecemeal_writer]
[h4 The `piecemeal_writer` class template]
``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class piecemeal_writer
{
public:

    virtual CharT* write(CharT* dest_begin, CharT* dest_end) = 0;

    bool more() const;
    bool success() const;
    std::error_code get_error() const;

protected:

    void report_success();
    void report_error(std::error_code);
};

}}} // namespace boost::stringify::v0
``

`write(dest_begin, dest_end)` writes into \[`dest_begin, dest_end`) 
a part of the content and returns the pointer immediately after
the last written location, which is not greater than `dest_end`.
It is expected to be called successively until `more()` returns `false`,
and each call writes the continuation of the previous written part.
When there is nothing else to be written, `write(dest_begin, dest_end)`
call either `report_success()` or `report_error(`[~some_error_code]`)`,
which in turn causes `more()` to return `false`.

If `(dest_end - dest_begin < BOOST_STRINGIFY_MIN_BUFFER_SIZE)`
then `write(dest_begin, dest_end)` is not required to write
anything and may just return `dest_begin`, expecting a larger
output range to be passed in the next call.
Otherwise it is required write some part of the content.
The caller, on the other hand, must be aware that
if the passed range is aways smaller than
BOOST_STRINGIFY_MIN_BUFFER_SIZE is all calls,
then an infinite loop may occur.

[#BOOST_STRINGIFY_MIN_BUFFER_SIZE]
Currently the value of BOOST_STRINGIFY_MIN_BUFFER_SIZE is 60.

[#buffered_writer]
[h3 The `buffered_writer` class template]

Your class can derive from `buffered_writer` rather than from `output_writer`. This requires much less work.

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class buffered_writer: public output_writer<CharT>
{
public:

    buffered_writer(output_writer_init<CharT>, CharT* buffer, std::size_t buffer_size);

    virtual ~buffered_writer();

    std::error_code finish_error_code(); // calls flush()
    void finish_exception(); // class flush()

    // it implements for you all pure virtual function of output_writer:
    virtual void set_error(std::error_code err) override;
    virtual bool good() const override;
    virtual bool put(const CharT* str, std::size_t size) final;
    virtual bool put(CharT ch) final;
    virtual bool put(std::size_t count, CharT ch) final;
    virtual bool put(piecemeal_writer<CharT>& src) final;

protected:

    // ... so that you only have to override this one:
    virtual bool do_put(const CharT* str, std::size_t count) = 0;

    bool flush();  // flush the buffer ( calls do_put )
};

}}} // namespace boost::stringify::v0
``
The buffer that is passed in the constructor shall be written and readen by `buffered_writer` class template only. The subclass shall not directly access it. The `do_put` function is called by `flush()`, and the argument `str` will be aways in range \[`buffer, buffer + buffer_size`), and `str + count` in \[`buffer, buffer + buffer_size`\];

[/
You may be wondering, why the comment says that `flush()` or `discard()` shall be called in the destructor? You know the buffer should be empty at such time, since `finish_error_code()` or `finish_exception()` must have been called. But not if an exception has been thrown. So you shall decide whether the remaining content in the buffer should be flushed or discarded in this case.
]
[h3 Examples]

* [@../../example/v0/extend_output_toQString.cpp extend_output_toQString.cpp]: This file implements `toQString`, which is an equivalent to `to_string` that creates an QString ( from Qt framework ) instead. 

You can also see how the [link output_types already supported output types] are implemented:

* [@../../include/boost/stringify/v0/output_types/std_string.hpp    std_string.hpp] : This is the source file that implements the [*`append`] and [*`assign`] function templates.
* [@../../include/boost/stringify/v0/output_types/to_string.hpp   to_string.hpp] : This is the source file implements the [*`to_string`], [*`to_u16string`], [*`to_u32string`], [*`to_wstring`] and [*`to_basic_string`] function templates.
* [@../../include/boost/stringify/v0/output_types/char_ptr.hpp char_ptr.hpp] : This is the source file implements the [*`format`] function templates that write to raw strings.
* [@../../include/boost/stringify/v0/output_types/std_streambuf.hpp std_streambuf.hpp] : This is the source file that implements the [*`format`] functing template that writes to `std::streambuff`.
* [@../../include/boost/stringify/v0/output_types/FILE.hpp FILE.hpp] : This is the source file that implements the [*`format`] and [*`wformat`] function templates that writes to `FILE*`.


[endsect]