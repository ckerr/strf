[#value_with_format]
[section Class template `value_with_format`]

[table
[[
  `template <typename ValueType, class ... Fmts>`[br]
  `class value_with_format;`
]]
[[
  [variablelist
    [[Compile time requirements]
     [itemized_list
       [`Value` is ... (/To-do/) ]
       [All types in `Fmt...` satisfy the [link FormatterRequirements
        Formatter] requirements.]]]]    
]]
]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::template fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::template fn<T>`. ]
      [`Fmt::template fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::template fn<T>` can be constructed from `const Fmt::template fn<U>&`
       , assuming both are well formed. ] ] ] ]    


[endsect]

[#FormatterRequirements]
[section Concept ['Formatter]]

A type `Fmt` is a `Formatter` if it has a member `fn` that is a type template
with one template type parameter such that, given any types `T` and `U`:
    [itemized_list
      [`Fmt::template fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::template fn<T>`. ]
      [`Fmt::template fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::template fn<T>` can be constructed from `const Fmt::template fn<U>&`
       , assuming both are well formed. ] ]

[endsect]