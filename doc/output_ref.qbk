[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]


[#output_buffer]
[h3 Class template `output_buffer`]

[#min_buff_size]
``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

template <typename CharT>
class output_buffer
{
public:

    using char_type = CharT;
    output_buffer(const output_buffer&) = delete;
    output_buffer(output_buffer&&) = delete;

    output_buffer& operator=(const output_buffer&) = delete;
    output_buffer& operator=(output_buffer&&) = delete;

    virtual ~output_buffer() = default;

    virtual bool recycle() = 0;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;

    void advance_to(CharT* p) noexcept;
    void advance(std::size_t n) noexcept;

    void set_error(std::error_code ec) noexcept;
    void set_error(std::errc e) noexcept;
    void set_encoding_error() noexcept;
    std::error_code get_error() const noexcept;
    bool has_error() const noexcept;

protected:

    output_buffer(CharT* buff_begin, CharT* buff_end) noexcept;
    output_buffer(CharT* buff_begin, std::size_t buff_size) noexcept;

    void set_pos(CharT* p) noexcept;
    void set_end(CharT* e) noexcept;
};

}}} // namespace boost::stringify::v0
``
[h4 Protected constructors]

[h4 Destructor]

[table
[[`public: virtual ~output_buffer() = default;`]]
[[
]]
]

[h4 Public pure virtual member functions ]

[table
[[`virtual bool recycle() = 0;`]]
[[[variablelist
     [[ Effects]
      [ Consumes the content in the range \u005B ['initial_pos], `pos()` \u0029,
        where ['initial_pos] is the value returned by `pos()` after the previous
        call to `recycle()` and before any call to `advance()`
        and `advance_to(p)`.]
      [ On success, calls `set_pos(`[~new_pos]`)` and optionally
        `set_end(`[~new_end]`)`.
        On failure, calls `set_error(`[~some_error]`)`.  ]]
     [[ Return value]
      [ `true` on success and `false` otherwise.]]
     [[ Postcondition]
      [ on sucess: size() >= min_buff_size]]]]]]

[h4 Public non-virtual member functions ]

[table
[[`std::size_t size() const noexcept;`]]
[[[variablelist
   [[Return value]
    [`end() - pos()`]]]]]]

[table
[[`char_type* pos() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The memory position where the content shall be written]]]]]]

[table
[[`char_type* end() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The end of memory position where the content shall be written]]]]]]

[table
[[`void advance_to(char_type* p) noexcept;`]]
[[[variablelist
   [[Effect]
      [update pos] ]
   [[Precondition]
      [`pos() <= p && p <= end()`] ]
   [[Postcondition]
      [`pos() == p`]]]]]]

[table
[[`void advance(std::size_t n) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`pos() + n <= end()`] ]
  [[Effect]
     [same as `advance(pos() + n)`]]]]]]

[table
[[`void set_error(std::error_code ec) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`has_error() == true`]]]]]]
     
[table
[[`void set_error(std::errc e) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::make_error_code(e))`]]]]]]
    
[table
[[`void set_encoding_error() noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::errc::illegal_byte_sequence)`]]]]]]

[table
[[`std::error_code get_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [The value passed to `set_error` the first time it was called]]]]]]

[table
[[`bool has_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [Whether `set_error` has been called ]]]]]]

[table
[[`protected: void set_pos(char_type* p) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`pos() == p`]]]]]]

[table
[[`protected: void set_end(char_type* e) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`end() == e`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, char_type* buff_end) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`buff_begin <= buff_end`]]
  [[Postconditions]
     [\u2022 `pos() == buff_begin` ]
     [\u2022 `pos() == buff_end`   ]
     [\u2022 `has_error() == false`]
     [\u2022 `get_error() == std::error_code{}`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, std::size_t buff_size) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `output_buffer(buff_begin, buff_begin + buff_size)` ]]]]]]
     




[#nodiscard_error_code_class]
[h3 Class `nodiscard_error_code`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class [[nodiscard]] nodiscard_error_code: public std::error_code
{
public:
    using std::error_code::error_code;

    nodiscard_error_code(const std::error_code& ec) noexcept
        : std::error_code(ec)
    {}
};

}}}
``

[#stringify_error]
[h3 Class `stringify_error`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class stringify_error: public std::system_error
{
public:
    using std::system_error::system_error;
};

}}}
``

