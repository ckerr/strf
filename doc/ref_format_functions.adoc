////
Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////

:fmt_type: <<fmt_type,fmt_type>>
:fmt: <<fmt,fmt>>
:width_t: <<width_t,width_t>>
:float_notation: <<float_format,float_notation>>
:float_format: <<float_format,float_format>>
:change_notation: <<float_format,change_notation>>
:int_format: <<int_formatter_fn,int_format>>

== Format functions

=== Global format functions
[[format_function_aliases]]
[source,cpp,subs=normal]
----
namespace strf {
inline namespace format_functions {

constexpr /{asterisk}...{asterisk}/ hex {};
constexpr /{asterisk}...{asterisk}/ dec {};
constexpr /{asterisk}...{asterisk}/ oct {};
constexpr /{asterisk}...{asterisk}/ bin {};
constexpr /{asterisk}...{asterisk}/ fixed {};
constexpr /{asterisk}...{asterisk}/ sci {};
constexpr /{asterisk}...{asterisk}/ gen {};
constexpr /{asterisk}...{asterisk}/ multi {};
constexpr /{asterisk}...{asterisk}/ conv {};
constexpr /{asterisk}...{asterisk}/ sani {};
constexpr /{asterisk}...{asterisk}/ right {};
constexpr /{asterisk}...{asterisk}/ left {};
constexpr /{asterisk}...{asterisk}/ center {};
constexpr /{asterisk}...{asterisk}/ split {};

} // inline namespace format_functions
} // namespace strf
----

The `format_functions` inline namespace contains callable objects
that work as alias to format functions

[%header,cols="22,25"]
|===
| Expression | Equivalent Expression
|`left(_arg_, _width_)`        |`{fmt}(_arg_) < _width_`
|`right(_arg_, _width_)`       |`{fmt}(_arg_) > _width_`
|`center(_arg_, _width_)`      |`{fmt}(_arg_) ^ _width_`
|`split(_arg_, _width_)`       |`{fmt}(_arg_) % _width_`
|`left(_arg_, _width_, _ch_)`  |`{fmt}(_arg_).fill(_ch_) < _width_`
|`right(_arg_, _width_, _ch_)` |`{fmt}(_arg_).fill(_ch_) > _width_`
|`center(_arg_, _width_, _ch_)`|`{fmt}(_arg_).fill(_ch_) ^ _width_`
|`split(_arg_, _width_, _ch_)` |`{fmt}(_arg_).fill(_ch_) % _width_`
|`bin(_arg_)`                  |`{fmt}(_arg_).bin()`
|`dec(_arg_)`                  |`{fmt}(_arg_).oct()`
|`oct(_arg_)`                  |`{fmt}(_arg_).dec()`
|`hex(_arg_)`                  |`{fmt}(_arg_).hex()`
|`sci(_arg_)`                  |`{fmt}(_arg_).sic()`
|`fixed(_arg_)`                |`{fmt}(_arg_).fixed()`
|`gen(_arg_)`                  |`{fmt}(_arg_).gen()`
|`sci(_arg_, _precision_)`     |`{fmt}(_arg_).sic().p(_precision_)`
|`fixed(_arg_, _precision_)`   |`{fmt}(_arg_).fixed().p(_precision_)`
|`gen(_arg_, _precision_)`     |`{fmt}(_arg_).gen().p(_precision_)`
|`multi(_arg_, _count_)`       |`{fmt}(_arg_).multi(_count_)`
|`sani(_arg_, _enc_)`          |`{fmt}(_arg_).sani(_enc_)`
|`conv(_arg_, _enc_)`          |`{fmt}(_arg_).conv(_enc_)`
|`sani(_arg_)`                 |`{fmt}(_arg_).sani()`
|`conv(_arg_)`                 |`{fmt}(_arg_).cont()`
|===

=== Callable object `fmt` [[fmt]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using fmt_value_type = typename {fmt_type}<T>::value_type;

constexpr struct /{asterisk}...{asterisk}/ {
    template <typename T>
    constexpr {fmt_type}<T> operator()(T&& value) const
        noexcept(noexcept({fmt_type}<T>fmt_value_type<T>{(T&&)value}}))
    {
        return {fmt_type}<T>{fmt_value_type<T>{(T&&)value}};
    }
} fmt;

} // namespace strf
----

=== Type alias template `fmt_type` [[fmt_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using fmt_type = /{asterisk}...{asterisk}/;

} // namespace strf
----

`fmt_type<T>` is:

* `T`, when `T` is `{value_with_formatters}</{asterisk} ... {asterisk}/>`
* `{print_traits_of}<T>::<<PrintTraits,fmt_type>>`, otherwise

`fmt_type<T>` is always expected to be an instance of `{value_with_formatters}` class template.

[[value_with_formatters]]
=== Class template `value_with_formatters`
[source,cpp]
----
namespace strf {

template <typename ValueType, class... Fmts>
class value_with_formatters;

} // namespace strf
----
Compile-time requirements::
- All types in `Fmt\...` satisfy <<Formatter,Formatter>>.
- All types in `Fmt\...` are different.

==== Synopsis
[source,cpp,subs=normal]
----
namespace strf {

template <typename PrintTraits, class\... Fmts>
class value_with_formatters
    : public Fmts::template fn<value_with_formatters<ValueType, Fmts\...>>\...
{
public:
    using traits = PrintTraits;
    using value_type = typename PrintTraits::forwarded_type;

    constexpr explicit <<value_with_formatters_v,value_with_formatters>>(const value_type& v);

    template <typename\... OtherFmts>
    constexpr explicit <<value_with_formatters_vwf2,value_with_formatters>>
        ( const value_with_formatters<PrintTraits, OtherFmts\...>& f );

    template <typename\... OtherFmts>
    constexpr explicit <<value_with_formatters_vwf2_rr,value_with_formatters>>
        ( value_with_formatters<PrintTraits, OtherFmts\...>&& f );

    template <typename OtherPrintTraits>
    constexpr <<value_with_formatters_v_v2wf,value_with_formatters>>
        ( const value_type& v
        , const value_with_formatters<OtherPrintTraits, Fmts\...>& f );

    template <typename OtherPrintTraits>
    constexpr <<value_with_formatters_v_v2wf_rr,value_with_formatters>>
        ( const value_type& v
        , value_with_formatters<OtherPrintTraits, Fmts\...>&& f );

    template <typename\... F, typename\... FInit>
    constexpr <<value_with_formatters_v_t_i,value_with_formatters>>
        ( const value_type& v
        , {tag}<F\...>
        , FInit&&\... finit );

    template <typename Fmt, typename FmtInit, typename\... OtherFmts>
    constexpr <<value_with_formatters_vwf2_t_i,value_with_formatters>>
        ( const value_with_formatters<PrintTraits, OtherFmts\...>& f
        , {tag}<Fmt>
        , FmtInit&& fmt_init );

    constexpr const value_type& value() const;

    constexpr value_type& value();

private:

    value_type value_; // exposition only
};

} // namespace strf
----

[[value_with_formatters_v]]
====
[source,cpp,subs=normal]
----
constexpr value_with_formatters(const value_type& v);
----
Effects::
* Initializes `value_` with `v`
* Default initializes all public base class subobjects
====

[[value_with_formatters_vwf2]]
====
[source,cpp,subs=normal]
----
template <typename\... OtherFmts>
constexpr explicit value_with_formatters
    ( const value_with_formatters<PrintTraits, OtherFmts\...>& f );
----
Effects::
* Initializes `value_` with `f.value()`
* Initializes each public base class subobjects with the corresponding base class subobject of `f`
====

[[value_with_formatters_vwf2_rr]]
====
[source,cpp,subs=normal]
----
template <typename\... OtherFmts>
constexpr explicit value_with_formatters
    ( value_with_formatters<PrintTraits, OtherFmts\...>&& f );
----
Effects::
* Initializes `value_` with `static_cast<value_type&&>(f.value())`
* Initializes each public base class subobjects `b` with `std::move(bf)`, where `bf`
  is the base class subobjects in `f` that corresponds to `b`
====

[[value_with_formatters_v_v2wf]]
====
[source,cpp,subs=normal]
----
template <typename OtherPrintTraits>
constexpr value_with_formatters
    ( const value_type& v
    , const value_with_formatters<OtherPrintTraits, Fmts\...>& f );
----
Effects::
* Initializes `value_` with `v`
* Initializes each public base class subobjects with the corresponding base class subobject of `f`
====

[[value_with_formatters_v_v2wf_rr]]
====
[source,cpp,subs=normal]
----
template <typename OtherPrintTraits>
constexpr value_with_formatters
    ( const value_type& v
    , value_with_formatters<OtherPrintTraits, Fmts\...>&& f );
----
Effects::
* Initializes `value_` with `v`
* Initializes each public base class subobjects `b` with `std::move(bf)`, where `bf`
  is the base class subobjects in `f` that corresponds to `b`
====

[[value_with_formatters_v_t_i]]
====
[source,cpp,subs=normal]
----
template <typename\... F, typename\... FInit>
constexpr value_with_formatters
    ( const value_type& v
    , {tag}<F\...>
    , FInit&&\... finit );
----
Compile-time requirements::
* `sizeof\...(F) == sizeof\...(FInit)`
* There is no repeated type in `F\...`
* All types in `F\...` are also in `Fmts\...`

Effects::
* Initializes `value_` with `v`
* For each type in `F\...`, initializes the corresponding public base class subobjects
  with the corresponging value in `std::forward<FInit>(finit)\...`
* Default initializes the remaining public base class subobjects

====

[[value_with_formatters_vwf2_t_i]]
====
[source,cpp,subs=normal]
----
template <typename Fmt, typename FmtInit, typename\... OtherFmts>
constexpr value_with_formatters
    ( const value_with_formatters<PrintTraits, OtherFmts\...>& f
    , {tag}<Fmt>
    , FmtInit&& fmt_init );
----
Compile-time requirements::
* `Fmt` is one the types in `Fmts\...`

Effects::
* Initializes `value_` with `f.value()`
* Initializes the public base class subobject that corresponds to `Fmt`
  with `std::forward<FmtInit>(fmt_init)`
* Initializes the other public base class subobjects with the corresponding
  base class subobject of `f`
====


[[value_with_formatters_value]]
====
[source,cpp,subs=normal]
----
constexpr const value_type& value() const;
constexpr value_type& value();
----
Return `value_`
====





[[Formatter]]
=== Type requirement _Formatter_

// This is the requirement for a type to be a paramenter of the `value_with_formatters`
// template.
A type `Fmt` is a _Formatter_ if it has a member `fn` that is a type template
with one template type parameter such that, given any types `T` and `U`:

- `Fmt::template fn<T>` is well formed if `T` is `value_with_formatters<ValueType, Fmts\...>`.
  In this case, note that `Fmt` is in `Fmts\...` and `T` derives from `Fmt::template fn<T>`.
- `Fmt::template fn<T>` is default constructible, assuming it is well formed.
- `Fmt::template fn<T>` can be constructed from `const Fmt::template fn<U>&`,
  if both are well formed.

// Although it is not a compile-time requirement, it only makes sense to use a type `Fmt`
// in `value_with_formatters` if `Fmt::template fn<T>` contains any __format function__.
// These are member functions and they are of two kinds. In the first one, the return type
// is `T`, `T&` or `T&&` depending of
//
// [source,cpp]
// ----
// struct fmt
// {
//     template <class T>
//     class fn
//     {
//     public:
//         // ...
//
//         T&   ff1(/*...*/) &
//         {
//             // ...
//             return static_cast<T&>(*this);
//         }
//
//         T&&  ff1(/*...*/) &&
//         {
//             // ...
//             return static_cast<T&&>(*this);
//         }
//
//         T    ff1(/*...*/) const &
//         {
//             // ...
//             return static_cast<const T&>(*this);
//         }
//
//     };
// };
// ----

[[alignment_formatter]]
=== _Formatter_ `alignment_formatter`

[source,cpp,subs=normal]
----
namespace strf {

template <bool HasAlignment>
struct alignment_formatter_q
{
    template <class T>
    using fn = <<alignment_formatter_fn,alignment_formatter_fn>><T, HasAlignment>;
};

using alignment_formatter       = alignment_formatter_q<true>;
using empty_alignment_formatter = alignment_formatter_q<false>;

} // namespace strf
----

[[alignment_formatter_fn]]
==== `alignment_formatter_fn`

[source,cpp,subs=normal]
----
namespace strf {

template <class T, bool HasAlignment>
class alignment_formatter_fn;
{
public:
    // <<alignment_formatter_fn_constructors,constructors>>
    constexpr alignment_formatter_fn() noexcept;

    template <typename U, bool B>
    constexpr explitic alignment_formatter_fn(const alignment_formatter_fn<U, B>& u) noexcept;

    // <<alignment_formatter_fn_observers,observers>>
    constexpr {width_t} width() const noexcept;
    constexpr text_alignment alignment() const noexcept;
    constexpr char32_t fill() const noexcept;
    constexpr {alignment_format} get_alignmet_format() const noexcept;

    // <<alignment_formatter_fn_format_functions,format functions>>
    constexpr T&& operator<({width_t} width) && noexcept; // left
    constexpr T&& operator>({width_t} width) && noexcept; // right
    constexpr T&& operator^({width_t} width) && noexcept; // center
    constexpr T&& operator%({width_t} width) && noexcept; // split, aka internal
    constexpr T&& fill(char32_t ch) && noexcept;
};

// alignment_formatter_fn<T, false> is an empty class
template <class T>
class alignment_formatter_fn<T, false>
{
    using converted_fmt = {boost_mp_replace}< T , alignment_formatter_q<false>
                                               , alignment_formatter_q<true> >;
public:
    // <<alignment_formatter_fn_constructors,constructors>>
    constexpr alignment_formatter_fn() noexcept;

    template <typename U>
    constexpr explicit alignment_formatter_fn(const alignment_formatter_fn<U, false>&) noexcept;

    // <<alignment_formatter_fn_observers,observers>>
    constexpr {width_t} width() const noexcept;
    constexpr text_alignment alignment() const noexcept;
    constexpr char32_t fill() const noexcept;
    constexpr {alignment_format} get_alignmet_format() const noexcept;

    // <<alignment_formatter_fn_format_functions,format functions>>
    constexpr converted_fmt set_alignment_format({alignment_format} data) const noexcept;
    constexpr converted_fmt operator<({width_t} width) const noexcept;
    constexpr converted_fmt operator>({width_t} width) const noexcept;
    constexpr converted_fmt operator^({width_t} width) const noexcept;
    constexpr converted_fmt operator%({width_t} width) const noexcept;
    constexpr converted_fmt fill(char32_t ch) const noexcept;
};

} // namespace strf
----
[[alignment_formatter_fn_constructors]]
===== Constructors
====
[source,cpp,subs=normal]
----
constexpr alignment_formatter_fn() noexcept;
----
Postconditions:: `get_alignmet_format() == {alignment_format}{}`
====
====
[source,cpp,subs=normal]
----
template <typename U, bool B>
constexpr explitic alignment_formatter_fn(const alignment_formatter_fn<U, B>& u) noexcept;
----
Postconditions:: `get_alignmet_format() == u.get_alignmet_format()`
Note:: This function only participates in overload resolution if 'HasAlignment' is `true`
        or `B` is `false`
====
[[alignment_formatter_fn_observers]]
===== Observers
====
[source,cpp,subs=normal]
----
constexpr {alignment_format} get_alignmet_format() const noexcept;
----
Return value::
- `alignment_format{}`, when `HasAlignment` is `false`.
- The value corresponding to the state of this object, when `HasAlignment` is `true`.
====
====
[source,cpp]
----
constexpr {width_t} width() const noexcept;
----
Return value:: `get_alignmet_format().width`
====
====
[source,cpp]
----
constexpr text_alignment alignment() const noexcept;
----
Return value:: `get_alignmet_format().alignment`
====
====
[source,cpp]
----
constexpr char32_t fill() const noexcept;
----
Return value:: `get_alignmet_format().fill`
====

[[alignment_formatter_fn_format_functions]]
===== Format functions

// `alignment_formatter_fn<T, false>` is an empty class. Its format functions
// return `converted_fmt{*this}.`
//
// In `alignment_formatter_fn<T, true>` the format functions modify
// the object and return `static_cast<T&&>(this)`.

====
[source,cpp]
----
constexpr /*return type */ set_alignment_format({alignment_format} data) /* qualifier */ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.get_alignmet_format() == data`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)}.set_alignment_format(data)`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====
====
[source,cpp]
----
constexpr /*return type */ operator<({width_t} width) /* qualifier */ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.width() == width`
- `r.alignment == text_alignment::left`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)} < width`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====
====
[source,cpp,subs=normal]
----
constexpr /{asterisk}return type {asterisk}/ operator>({width_t} width) /{asterisk} qualifier {asterisk}/ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.width() == width`
- `r.alignment() == text_alignment::right`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)} > width`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====
====
[source,cpp,subs=normal]
----
constexpr /{asterisk}return type {asterisk}/ operator^({width_t} width) /{asterisk} qualifier {asterisk}/ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.width() == width`
- `r.alignment() == text_alignment::center`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)} ^ width`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====
====
[source,cpp,subs=normal]
----
constexpr /{asterisk}return type {asterisk}/ operator%({width_t} width) /{asterisk} qualifier {asterisk}/ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.width() == width`
- `r.alignment() == text_alignment::split`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)} % width`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====
====
[source,cpp,subs=normal]
----
constexpr /{asterisk}return type {asterisk}/ fill(char32_t ch) /{asterisk} qualifier {asterisk}/ noexcept;
----
Posconditions:: The return value `r` satisfies:
- `r.fill() == ch`
Return value::
When `HasAlignment` is `false`::: `converted_fmt{static_cast<const T&>({asterisk}this)}.fill(ch)`.
When `HasAlignment` is `true`::: `std::move(static_cast<T&>({asterisk}this))`.
====

[[alignment_format]]
==== `alignment_format`

[source,cpp,subs=normal]
----
namespace strf {

enum class text_alignment {left, right, split, center};

struct alignment_format
{
    char32_t fill = U' ';
    {width_t} width = 0;
    text_alignment alignment = text_alignment::right;
};

constexpr bool operator==(alignment_format lhs, alignment_format rhs) noexcept;
constexpr bool operator!=(alignment_format lhs, alignment_format rhs) noexcept;
} // namespace strf
----

[[int_formatter]]
=== _Formatter_ `int_formatter`

[source,cpp,subs=normal]
----
namespace strf {

template <class T, int Base>
class int_formatter_fn;

template <int Base>
struct int_formatter
{
    template <typename T>
    using fn = int_formatter_fn<T, Base>;
};

} // namespace strf
----

==== `int_formatter_fn`

[source,cpp,subs=normal]
----
namespace strf {

struct int_format
{
    unsigned precision = 0;
    bool showbase = false;
    bool showpos = false;
};

constexpr bool operator==(int_format lhs, int_format rhs) noexcept;
constexpr bool operator!=(int_format lhs, int_format rhs) noexcept;

template <class T, int Base>
class int_formatter_fn
{
public:
    constexpr int_formatter_fn() noexcept;

    template <typename U, int OtherBase>
    constexpr int_formatter_fn(const int_formatter_fn<U, OtherBase> & u) noexcept;

    // <<int_formatter_fn_observers,observers>>
    constexpr int_format get_int_format() const noexcept;
    constexpr unsigned precision() const noexcept;
    constexpr bool showbase() const noexcept;
    constexpr bool showpos() const noexcept;
    constexpr static int base() noexcept;

    // <<int_formatter_fn_format_functions, format functions>>
    constexpr T&& set_int_format(int_format data) && noexcept;
    constexpr T&& p(unsigned precision) && noexcept; // set precision
    constexpr T&& operator+() && noexcept;           // show positive sign
    constexpr T&& operator{asterisk}() && noexcept;           // show base

    constexpr T&& hex() && noexcept; // when Base == 16
    constexpr T&& dec() && noexcept; // when Base == 10
    constexpr T&& oct() && noexcept; // when Base == 8
    constexpr T&& bin() && noexcept; // when Base == 2

    constexpr /{asterisk} see below {asterisk}/ hex() && noexcept; // when Base != 16
    constexpr /{asterisk} see below {asterisk}/ dec() && noexcept; // when Base != 10
    constexpr /{asterisk} see below {asterisk}/ oct() && noexcept; // when Base != 8
    constexpr /{asterisk} see below {asterisk}/ bin() && noexcept; // when Base != 2
};
} // namespace strf
----
[[int_formatter_fn_observers]]
===== Observers
====
[source,cpp]
----
constexpr int_format get_int_format() const noexcept;
----
Return value:: The value corresponding to the state of this object.
====
====
[source,cpp]
----
constexpr unsigned precision() const noexcept;
----
Return value:: `get_int_format().precision`
====
====
[source,cpp]
----
constexpr showpos() const noexcept;
----
Return value:: `get_int_format().showpos`
====
====
[source,cpp]
----
constexpr showbase() const noexcept;
----
Return value:: `get_int_format().showbase`
====
====
[source,cpp]
----
constexpr static base() noexcept;
----
Return value:: `Base`
====

[[int_formatter_fn_format_functions]]
===== Format functions
====
[source,cpp]
----
constexpr T&& set_int_format({int_format} data) && noexcept;
----
Postconditions::  `get_int_format() == data`
Return value:: `std::move(static_cast<T&>({asterisk}this))`
====
====
[source,cpp]
----
constexpr T&& p(unsigned precision) && noexcept;
----
Postconditions::  `precision() == precision`
Return value:: `std::move(static_cast<T&>({asterisk}this))`
====
====
[source,cpp]
----
constexpr T&& operator+() && noexcept;
----
Postconditions::  `showpos() == true`
Return value:: `std::move(static_cast<T&>({asterisk}this))`
====
====
[source,cpp]
----
constexpr T&& operator*() && noexcept;
----
Postconditions::  `showbase() == true`
Return value:: `std::move(static_cast<T&>({asterisk}this))`
====

====
[source,cpp]
----
constexpr T&& hex() &&;
constexpr T&& dec() &&;
constexpr T&& oct() &&;
constexpr T&& bin() &&;
----
Compile-time requirements::
`Base == DesiredBase`, where `DesiredBase` is equal to `10` in `dec()`, `16` in `hex()`, `8` in `oct()`
and `2` in `bin()`.
Return value::
- `static_cast<T&&>({asterisk}this))`
====

====
[source,cpp]
----
constexpr /* see below */ hex() const &;     // hexadecimal base
constexpr /* see below */ dec() const &;     // decimal base
constexpr /* see below */ oct() const &;     // octal base
constexpr /* see below */ bin() const &;     // binary base
----
Compile-time requirements::
`Base != DesiredBase`, where `DesiredBase` is equal to `10` in `dec()`, `16` in `hex()`, `8` in `oct()`
and `2` in `bin()`.
Return type::
+
[source,cpp,subs=normal]
----
{boost_mp_replace}<T, int_formatter<Base>, int_formatter<DesiredBase> >
----
, where `DesiredBase` is equal to `10` in `dec()`, `16` in `hex()`, `8` in `oct()`
and `2` in `bin()`.
Return value::
- `static_cast<ReturnType>(static_cast<const T&>({asterisk}this))`, where `ReturnType` is the return type;
====

[[float_formatter]]
=== _Formatter_ `float_formatter`

[source,cpp,subs=normal]
----
namespace strf {

template <class T, {float_notation} N>
class float_formatter_fn;

template <{float_notation} N>
struct float_formatter
{
    template <typename T>
    using fn = float_formatter_fn<T, N>;
};

} // namespace strf
----

==== `float_formatter_fn`
[source,cpp,subs=normal]
----
namespace strf {

template <typename T, {float_notation} N>
class float_formatter_fn
{
public:
    constexpr float_formatter_fn() noexcept;

    template <typename U>
    constexpr explicit float_formatter_fn(const float_format_fn<U, N>& other) noexcept;

    // observers
    constexpr {float_format}<N> get_float_format() const noexcept;

    // format functions
    constexpr T&& <<float_formatter_fn_showpos,operator+>>() && noexcept;
    constexpr T&& <<float_formatter_fn_showpoint,operator{asterisk}>>() && noexcept;
    constexpr T&& <<float_formatter_fn_p,p>>(unsigned precision) && noexcept;

    constexpr T&& <<float_formatter_fn_gen_noop,gen>>() && noexcept;      // when N == {float_notation}::general
    constexpr T&& <<float_formatter_fn_sci_noop,sci>>() && noexcept;      // when N == {float_notation}::scientific
    constexpr T&& <<float_formatter_fn_fixed_noop,fixed>>() && noexcept;    // when N == {float_notation}::fixed

    constexpr /{asterisk} see below {asterisk}/ <<float_formatter_fn_gen_const,gen>>() const & noexcept; // when N != {float_notation}::general
    constexpr /{asterisk} see below {asterisk}/ <<float_formatter_fn_sci_const,sci>>() const & noexcept; // when N != {float_notation}::sci
    constexpr /{asterisk} see below {asterisk}/ <<float_formatter_fn_fixed_const,fixed>>() const & noexcept; // when N != {float_notation}::fixed

    constexpr T&& <<float_formatter_fn_set_float_format_nonconst,set_float_format>>({float_format}<N> data) && noexcept;

    template <{float_notation} N2> // where N2 != N
    constexpr /{asterisk} see below {asterisk}/ <<float_formatter_fn_set_float_format_const,set_float_format>>({float_format}<N2> data) const & noexcept;
};
} // namespace strf
----

Compile-time requirements::
`T` is `{value_with_formatters}<__SomeValueType__, F\...>`, where `F\...` contains `float_formatter<N>`.

[[float_formatter_fn_constructors]]
===== Constructors
====
[source,cpp,subs=normal]
----
constexpr float_formatter_fn() noexcept;
----
Postconditions:: `get_float_format() == {float_format}<N>{}`
====
====
[source,cpp,subs=normal]
----
template <typename U>
constexpr explicit float_formatter_fn(const float_formatter_fn<U, N>& other) noexcept;
----
Postconditions:: `get_float_format() == other.get_float_format()`
====


===== Format functions

[[float_formatter_fn_showpos]]
====
[source,cpp,subs=normal]
----
constexpr T&& operator+() && noexcept;
----
Postconditions:: `get_float_format().<<float_showpos,showpos>> == true`
Return value:: `static_cast<T&&>({asterisk}this)`
====

[[float_formatter_fn_showpoint]]
====
[source,cpp,subs=normal]
----
constexpr T&& operator{asterisk}() && noexcept;
----
Postconditions:: `get_float_format().<<float_showpoint,showpoint>> == true`
Return value:: `static_cast<T&&>({asterisk}this)`
====

[[float_formatter_fn_p]]
====
[source,cpp,subs=normal]
----
constexpr T&& p(unsigned precision) && noexcept;
----
Postconditions:: `get_float_format().<<float_precision,precision>> == precision`
Return value:: `static_cast<T&&>({asterisk}this)`
====

[[float_formatter_fn_gen_noop]]
====
[source,cpp,subs=normal]
----
constexpr T&& gen() && noexcept;
----
No effect.

Compile-time requirements::
`N == {float_notation}::general`, otherwise this function does not participate in overload resolution.
Return value:: `static_cast<T&&>({asterisk}this)`;
====

[[float_formatter_fn_gen_const]]
====
[source,cpp,subs=normal]
----
constexpr /{asterisk} see below {asterisk}/ gen() const & noexcept;
----
Compile-time requirements::
`N != {float_notation}::general`, otherwise this function does not participate in overload resolution.
Return type::
+
[source,cpp,subs=normal]
----
{boost_mp_replace}<T, float_formatter<N>, float_formatter<{float_notation}::general>>
----
Return value::
+
[source,cpp,subs=normal]
----
__ReturnType__ { static_cast<const T&>(*this)
           , {tag}<float_formatter<N>>{}
           , {change_notation}<{float_notation}::general>(get_float_format()) }
----
+
where `__ReturnType__` is the return type, which must be an instance of `{value_with_formatters}`
( since `T` is ). The above expression invokes
<<value_with_formatters_vwf2_t_i,this constructor>>.

====
[[float_formatter_fn_sci_noop]]
====
[source,cpp,subs=normal]
----
constexpr T&& sci() && noexcept;
----
No effect.

Compile-time requirements::
`N == {float_notation}::scientific`, otherwise this function does not participate in overload resolution.
Return value:: `static_cast<T&&>({asterisk}this)`;
====

[[float_formatter_fn_sci_const]]
====
[source,cpp,subs=normal]
----
constexpr /{asterisk} see below {asterisk}/ sci() const & noexcept;
----
Creates a new `{value_with_formatters}` object where `N` is `{float_notation}::scientific`.

Compile-time requirements::
`N != {float_notation}::scientific`, otherwise this function does not participate in overload resolution.

Return type::
+
[source,cpp,subs=normal]
----
{boost_mp_replace}<T, float_formatter<N>, float_formatter<{float_notation}::scientific>>
----
Return value::
+
[source,cpp,subs=normal]
----
__ReturnType__ { static_cast<const T&>(*this)
           , {tag}<float_formatter<N>>{}
           , {change_notation}<{float_notation}::scientific>(get_float_format()) }
----
+
where `__ReturnType__` is the return type, which must be an instance of `{value_with_formatters}`
( since `T` is ). The above expression invokes
<<value_with_formatters_vwf2_t_i,this constructor>>.
====

[[float_formatter_fn_fixed_noop]]
====
[source,cpp,subs=normal]
----
constexpr T&& fixed() && noexcept;
----
Compile-time requirements::
`N == {float_notation}::fixed`, otherwise this function does not participate in overload resolution.
Return value:: `static_cast<T&&>({asterisk}this)`
====

[[float_formatter_fn_fixed_const]]
====
[source,cpp,subs=normal]
----
constexpr /{asterisk} see below {asterisk}/ fixed() const & noexcept;
----
Creates a new `{value_with_formatters}` object where `N` is `{float_notation}::fixed`.

Compile-time requirements::
`N != {float_notation}::fixed`, otherwise this function does not participate in overload resolution.
Return type::
+
[source,cpp,subs=normal]
----
{boost_mp_replace}<T, float_formatter<N>, float_formatter<{float_notation}::fixed>>
----
Return value::
+
[source,cpp,subs=normal]
----
__ReturnType__ { static_cast<const T&>(*this)
           , {tag}<float_formatter<N>>{}
           , {change_notation}<{float_notation}::fixed>(get_float_format()) }
----
+
where `__ReturnType__` is the return type, which must be an instance of `{value_with_formatters}`
( since `T` is ). The above expression invokes
<<value_with_formatters_vwf2_t_i,this constructor>>.
====

[[float_formatter_fn_set_float_format_nonconst]]
====
[source,cpp,subs=normal]
----
constexpr T&& set_float_format({float_format}<N> data) && noexcept;
----
Change format data.

Postconditions::  `get_float_format() == data`
Return value:: `std::move(static_cast<T&>({asterisk}this))`
====

[[float_formatter_fn_set_float_format_const]]
====
[source,cpp,subs=normal]
----
template <{float_notation} N2}>
constexpr /{asterisk}...{asterisk}/ set_float_format({float_format}<N2> data) const & noexcept;
----
Creates a new `{value_with_formatters}` object where `N` is equal to `N2`, and the return value of `get_float_format()` is equal to `data`.

Compile-time requirements::
`N2 != N`, otherwise this function does not participate in overload resolution.
Return type::
+
[source,cpp,subs=normal]
----
`{boost_mp_replace}<T, float_formatter<N>, float_formatter<N2>>`
----

Return value::
+
[source,cpp,subs=normal]
----
__ReturnType__ { static_cast<const T&>(*this)
           , {tag}<float_formatter<N>>{}
           , {change_notation}<N2>(get_float_format()) }
----
+
where `__ReturnType__` is the return type, which must be an instance of `{value_with_formatters}`
( since `T` is ). The above expression invokes
<<value_with_formatters_vwf2_t_i,this constructor>>.
====

==== struct `float_format` [[float_format]]

[source,cpp,subs=normal]
----
namespace strf {

enum class <<float_notation,float_notation>> {fixed, scientific, general};

template <float_notation>
struct float_format
{
    unsigned precision = (unsigned)-1;
    bool showpoint = false;
    bool showpos = false;
};

template <float_notation To, float_notation From>
constexpr float_format<To> change_notation(float_format<From> x) noexcept
{
    return { x.precision, x.showpoint, x.showpos };
}

template <float_notation N>
constexpr bool operator==(float_format<N> lhs, float_format<N> rhs) noexcept;

template <float_notation N>
constexpr bool operator!=(float_format<N> lhs, float_format<N> rhs) noexcept;

} // namespace strf
----

[[float_notation]]
notation::
- `float_notation::fixed`: Prints like `123.45`
- `float_notation::scientific`: Prints like `1.2345e+02`
- `float_notation::general`: When precision is `(unsigned)-1`,
   prints in the scientfic notation if it is shorter than the fixed notation.
   When precision is different than `(unsigned)-1`, does like in `std::printf`:
   uses the scientfic notation if the exponent is less than -4 or greater
   than or equal to the precision. Trailing fractional zeros are not printed.

[[float_precision]]
precision:: When `notation == float_notation::general`, the precision is the
            number of significant digits. Otherwise it is the number of
            fractional digits. `precision == 0` has the same effect as
            `precision == 1`.

[[float_showpoint]]
showpoint:: Prints the decimal point even when there are no fractional digits.

[[float_showpos]]
showpos:: Prints the positive sign `'+'` when the value is positive.

[[quantity_formatter]]
=== _Formatter_ `quantity_formatter`
[source,cpp]
----
namespace strf {

struct quantity_formatter
{
    template <class T>
    using fn = quantity_formatter_fn<T>;
};

} // namespace strf
----
==== `quantity_formatter_fn`
[source,cpp]
----
namespace strf {

template <class T>
class quantity_formatter_fn
{
public:
    constexpr quantity_formatter_fn(std::size_t count) noexcept;
    constexpr quantity_formatter_fn() noexcept;

    template <typename U>
    constexpr explicit quantity_formatter_fn(const quantity_formatter_fn<U>& u) noexcept
        : _count(u.count())
    {
    }

    constexpr T&& multi(std::size_t count) && noexcept
    constexpr std::size_t count() const noexcept
};

} // namespace strf
----
===== Constructors
====
[source,cpp,subs=normal]
----
constexpr quantity_formatter_fn() noexcept;
----
Postconditions:: `count() == 1`
====
====
[source,cpp,subs=normal]
----
template <typename U>
constexpr explicit quantity_formatter_fn(const quantity_formatter_fn<U>& u) noexcept;
----
Postconditions:: `count() == u.count()`
====

===== Format functions
====
[source,cpp,subs=normal]
----
constexpr T&& multi(std::size_t count) && noexcept
----
Postconditions:: `count() == count`
Return value:: `static_cast<T&&>({asterisk}this)`
====

