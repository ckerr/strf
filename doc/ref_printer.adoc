////
Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////
:printer: <<printer,printer>>
:printer_impl: <<printer_impl,printer_impl>>
:printer_traits: <<printer_traits,printer_traits>>
:printer_type_getter_c: <<printer_type_getter_c,printer_type_getter_c>>

:get_facet: <<get_facet,get_facet>>
:tag: <<tag,tag>>
:rank: <<rank,rank>>

== Printable

[[printer]]
=== Class template `printer`

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
class printer
{
public:
    using char_type = CharOut;
    virtual ~printer() {}
    virtual void print_to(<<basic_outbuff,basic_outbuff>><CharT>&) const = 0;
};

} // namespace strf
----

[[Printable]]
=== Type requirement _Printable_

The type `T` satisfies _Printable_ if
Given,

- `CharT`, a character type.
- `FPack`, a type that is an instance of `<<facets_pack,facets_pack>>`
- `fp`, an lvalue reference of type `const FPack`.
- `preview`, an lvalue reference of type `<<print_preview,print_preview>><preview_width::no, preview_size::no>&`
- `x`, an expression of type `const T`.
- `chtag`, an expression of type `{tag}<CharT>`

The expression below is valid
[source,cpp,subs=normal]
----
static_cast< const {printer}<sizeof(CharT)>& >
    ( {printer_impl}<CharT, FPack, T>{fpack, preview, x, chtag} )
----

////
What are customization point objects and how to use them?
https://stackoverflow.com/questions/53495848/what-are-customization-point-objects-and-how-to-use-them

////
[[PrintableWithWidthPreview]]
=== Type requirement _PrintableWithWidthPreview_

The type `T` satisfies _PrintableWitdhPreview_ if it satisfies
<<Printable,_Printable_>> and
Given,

- `CharT`, a character type.
- `FPack`, a type that is an instance of `<<facets_pack,facets_pack>>`
- `fp`, an lvalue reference of type `const FPack`.
- `preview`, an lvalue reference of type `<<print_preview,print_preview>><preview_size::no, preview_with::yes>&`.
- `x`, an expression of type `const T`.

The expression below is valid
[source,cpp,subs=normal]
----
static_cast< const {printer}<sizeof(CharT)>& >
    ( {printer_impl}<CharT, FPack, T>{fpack, preview, x, chtag} )
----

And

- The poscondition `(rw_pre - rw_pos == w || rw_pos \<= 0)` is satisfied, where `rw_pre` and `rw_pos` are the value of `prev.remaining_width()` before and after the expression above is evaluated, respectively, and `w` is the predicted width of the content that the returned printer writes ( in `print_to` ).

NOTE: The pratical effect of a type being _PrintableWithWidthPreview_ is that it can be
used in <<aligned_join, aligned joins>>.
[[PrintableWithSizePreview]]
=== Type requirement _PrintableWithSizePreview_ if it satisfies
<<Printable,_Printable_>> and

The type `T` satisfies _PrintableWithSizePreview_ if
Given,

- `CharT`, a character type.
- `FPack`, a type that is an instance of `<<facets_pack,facets_pack>>`
- `fp`, an lvalue reference of type `const FPack`.
- `preview`, an lvalue reference of type `<<print_preview,print_preview>><preview_size::yes, preview_width::no>&`
- `x`, an expression of type `const T`.

The expression below is valid
[source,cpp,subs=normal]
----
static_cast< const {printer}<sizeof(CharT)>& >
    ( {printer_impl}<CharT, FPack, T>{fpack, preview, x, chtag} )
----

And

- The poscondition `(s_pos - s_pre == s)` is satisfied, where `s_pos` and `s_pre` are the value of `prev.get_size()` before and after the expression above is evaluated respectively, and `s` -- the estimated number of characters that the returned printer writes in `<<printer,print_to>>` -- does not need to be exact but must be such that for any value `ob` of type `<<basic_outbuff,basic_outbuff>><CharT>&`, if `ob.<<underlying_outbuff_size,size>>()` is less than or equal to `s`, then `p.print_to(ob)` is guaranted to not call `ob.<<underlying_outbuff_recycle,recycle>>()`, where value of the above expression.

[NOTE]
====
The pratical effect of a type being _PrintableWithSizePreview_,
is that it be used in `<<destination_calc_size,destination_calc_size>>`, _i.e._,
when `reserve_calc` is used.
For example, in the expression below, the type of `arg0`, `arg1`, `arg2`, `etc` must all be _PrintableWithSizePreview_:
[source,cpp]
----
auto str = make_string.reserve_calc()(arg0, arg1, arg2, etc);
----
====

[[make_fmt]]
=== Type requirement _FmtPrintable_

The type `T` satisfies _FmtPrintable_ if

- given `x`, an expression of type `const T`

The expression below is valid
[source,cpp,subs=normal]
----
make_fmt({rank}<5>(), x)
----
and

- The return type is <<Printable,_Printable_>>, and it is an instance
of the `<<value_with_format,value_with_format>>` class template.
////
- `make_fmt({rank}<5>(), x).value() == x`
////

////
NOTE: `make_fmt` is a customization point to associate format functions to
input types.
All the <<format_function_aliases,format function aliases>> require the
argument's type to be _FmtPrintable_.
Printing <<formatted_range, formatted ranges>> also requires that the
range element type be _FmtPrintable_.
////

NOTE: The practical of a value being of a _FmtPrintable_ type,
is that you can apply <<format_function_aliases,format functions>>
over it. Also, to print <<formatted_range, formatted ranges>>
, the range element type must be _FmtPrintable_.


[[print_preview]]
=== Class template `print_preview`
[source,cpp,subs=normal]
----
namespace strf {

enum class preview_width: bool { no = false, yes = true };
enum class preview_size : bool { no = false, yes = true };

template <preview_size SizeRequired, preview_width WidthRequired>
class print_preview
    : public size_preview<static_cast<bool>(SizeRequired)>
    , public width_preview<static_cast<bool>(WidthRequired)>
{
public:

    static constexpr bool size_required = static_cast<bool>(SizeRequired);
    static constexpr bool width_required = static_cast<bool>(WidthRequired);
    static constexpr bool nothing_required = ! size_required && ! width_required;

    constexpr print_preview() noexcept = default;
    constexpr explicit print_preview(<<width_t,width_t>> initial_width) noexcept;
};

} // namespace strf
----
==== Constructors
====
[source,cpp,subs=normal]
----
constexpr print_preview() noexcept;
----
::
[horizontal]
Effect:: Default-construct each of the base classes.
====
====
[source,cpp,subs=normal]
----
constexpr explicit print_preview(<<width_t,width_t>> initial_width) noexcept;
----
::
Compile-time requirement:: `WidthRequired` is `preview_width::yes`, otherwise this constructor
does not participate in overload resolution.
Effect:: Initializes `<<width_preview, width_preview>>` base
with `initial_width`.
====
[[size_preview]]
=== Class template `size_preview`
[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class size_preview
{
public:
    explicit constexpr size_preview() noexcept;
    explicit constexpr size_preview(std::size_t initial_size) noexcept;

    constexpr void add_size(std::size_t) noexcept;
    constexpr std::size_t get_size() const noexcept;
};
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
explicit constexpr size_preview() noexcept;
----
::
Postcondition:: `get_size() == 0`
====
====
[source,cpp]
----
explicit constexpr size_preview(std::size_t initial_size) noexcept;
----
::
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `get_size() == initial_size`
====
====
[source,cpp]
----
constexpr void add_size(std::size_t s) noexcept;
----
::
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` ::: `(get_size() - previous_size == s)`, where `previous_size` is the return value of `get_size()` before this call.
====
====
[source,cpp]
----
constexpr void get_size() const noexcept;
----
::
Return value::
When `Active` is `false`::: `0` (always)
When `Active` is `true` ::: The internally stored size value.
====
[[width_preview]]
=== Class template `width_preview`

[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class width_preview
{
public:
    constexpr width_preview() noexcept;
    explicit constexpr width_preview(<<width_t,width_t>> initial_width) noexcept;
    constexpr void subtract_width(<<width_t,width_t>>) noexcept;
    constexpr void checked_subtract_width(std::ptrdiff_t w) noexcept;
    constexpr void clear_remaining_width() noexcept;
    constexpr <<width_t,width_t>> remaining_width() const noexcept;
}
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
constexpr width_preview() noexcept;
----
::
Postcondition:: `remaining_width() == 0`
====
====
[source,cpp,subs=normal]
----
constexpr width_preview(<<width_t,width_t>> initial_width) noexcept;
----
::
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `remaining_width() == initial_width`
====
====
[source,cpp,subs=normal]
----
void subtract_width(<<width_t,width_t>> w) noexcept;
----
::
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == previous_w - w
----
where `previous_w` is the return value of `remaining_width()` before this call.
====
====
[source,cpp,subs=normal]
----
void checked_subtract_width(<<width_t,width_t>> w) noexcept;
----
::
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == (w < previous_w ? previous_w - w : 0)
----
where `previous_w` is the return value of `remaining_width()` before this call.
====
====
[source,cpp,subs=normal]
----
void checked_subtract_width(std::ptrdiff_t w)
----
::
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == (w < previous_w.ceil() ? previous_w - (std::int16_t)w : 0)
----
where `previous_w` is the return value of `remaining_width()` before this call.
====

=== Type alias template `printer_impl` [[printer_impl]]
[source,cpp,subs=normal]
----
template <typename CharOut, typename FPack, typename Arg>
usign printer_impl = typename
    decltype({get_facet}<printer_type_getter_c, Arg>(std::declval<FPack>()))
    :: template printer;
----

=== Facet category `printer_type_getter_c` [[printer_type_getter_c]]
[source,cpp,subs=normal]
----
struct printer_type_getter_c;

struct printer_type_getter
{
    using category = printer_type_getter_c;

    template <typename CharT, typename FPack, typename PrintableType>
    using type = typename {printer_traits}<CharT, PrintableType>
        ::template printer_type<FPack>;
};

struct printer_type_getter_c
{
    constexpr static printer_type_getter get_default() noexcept;
};
----
=== Class template `printer_traits` [[printer_traits]]
[source,cpp,subs=normal]
----
template <typename CharT, typename T>
class printer_traits
{
public:

    template <typename FPack>
    using printer_type = typename
        decltype(get_printer_traits( {tag}<CharT>()
                                   , std::declval<const T&>() ))
        :: template printer_type<FPack>;
};
----

The `printer_traits` class template is a customization point.
The user can add printable types by specializing this template,
or by overloading `get_printer_traits`.

The `FPack` template paramenter of `printer_type`
is expected to laways be an instance of `<<facets_pack,facets_pack>>`.
And the type `printer_type<FPack>` shall be such that the
expression below is valid:
----
static_cast< const {printer}<sizeof(CharT)>& >
    ( printer_type<FPack>{fpack, preview, x, chtag} )
----
, where:

- `fp`, an lvalue reference of type `const FPack`.
- `preview`, an lvalue reference of type `<<print_preview,print_preview>><preview_size::no, preview_width::no>&`
- `x`, an expression of type `const T`.
- `chtag`, an expression of type `{tag}<CharT>`