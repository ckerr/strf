////
Distributed under the Boost Software License, Version 1.0.

See accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt
////
:printer: <<printer,printer>>
:printer_type: <<printer_type,printer_type>>
:printer_traits: <<printer_traits,printer_traits>>
:printer_type_getter_c: <<printer_type_getter_c,printer_type_getter_c>>

:print_preview: <<print_preview, print_preview>>
:facets_pack: <<facets_pack, facets_pack>>
:value_with_formatters: <<value_with_formatters, value_with_formatters>>


:PrintTraits: <<PrintTraits,PrintTraits>>
:Printable: <<Printable,Printable>>
:PrinterInput: <<PrinterInput,PrinterInput>>
:print_traits_of: <<print_traits_of,print_traits_of>>
:print_override_c: <<print_override_c,print_override_c>>
:make_default_printer_input: <<make_default_printer_input,make_default_printer_input>>
:make_printer_input: <<make_printer_input,make_printer_input>>

:basic_outbuff: <<outbuff_hpp#basic_outbuff,basic_outbuff>>
:get_facet: <<get_facet,get_facet>>
:tag: <<tag,tag>>
:rank: <<rank,rank>>
:join: <<join,join>>


== Requirements of printable types

This section provides what one needs to be known to add a new printable type
or override an existing one.

[[Printable]]
=== Type requirement _Printable_

A type `T` is _Printable_ if:

* `print_traits_of<T>` is defined and is a  _{PrintTraits}_ type
* `print_traits_of<T>::forwarded_type` is implicitly convertible from `T`

[[print_traits_of]]
=== Type alias template `print_traits_of`

[source,cpp,subs=normal]
----
namespace strf {

struct print_traits_tag;

template <typename T> print_traits;

template <typename T> using print_traits_of = /{asterisk} see below\... {asterisk}/;

} // namespace strf
----

`print_traits_of<T>` is:

*  `print_traits_of<std::remove_cvref<T>>`, if `T` is a reference type or has any cv-qualifier
*  otherwise, it is `Traits`, when `T` is `{value_with_formatters}<Traits, /{asterisk}\... {asterisk}/>`
*  otherwise, it is `print_traits<T>` if such template specialization is defined
*  otherwise, it is `decltype(tag_invoke(print_traits_tag{}, std::declval<T>()))`

=== Type alias template `forwarded_printable_type` [[forwarded_printable_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename T>
using forwarded_printable_type = /{asterisk} see below\... {asterisk}/;

} // namespace strf
----

* `forwarded_printable_type<T>` is `T`, when `T` a `{value_with_formatters}</{asterisk}\... {asterisk}/>`
* otherwise, it is `typename {print_traits_of}<T>::forwarded_type`

[[PrintTraits]]
=== Type requirement _PrintTraits_

Given

* `T`, a _PrintTraits_ type.
* `P`, a _{Printable}_ type such that `{print_traits_of}<P>` is `T`.

==== Member types
[[PrintTraits_forwarded_type]]
====
[source,cpp]
----
T::forwarded_type
----
`forwarded_type` must be implicitly convertible from `P`,
and must be copy-constructible. And its copy-constructor should be fast.
( `forwarded_type` is usually `P` or `const P&` )

`forwarded_type` is used intead of `P` as the storage type in some
situations ( for example, the objects created by `fmt` and `{join}` ).
====
[[PrintTraits_facet_tag]]
====
[source,cpp]
----
T::facet_tag
----
The type that is used as the tag type in `<<get_facet,get_facet>>`.
It shall not be a reference type, and shall not contain cv-qualifiers.
Usually is it `std::remove_cv_t<std::remove_reference<forwarded_type>>`
====
[[PrintTraits_formatters]]
====
.( Optional )
[source,cpp]
----
T::formatters
----
A type alias to `{tag}<F\...>`, where all types in `F\...` satisfy __<<Formatter,Formatter>>__.
It affects the return type of `<<fmt,fmt>>`.
====

[[PrintTraits_functions]]
==== Member static function templates

Given

* `T`, a _PrintTraits_ type.
* `CharT`, a character type
* `fpack`, a value of type `{facets_pack}</{asterisk}\... {asterisk}/>`
* `preview`, an lvalue of type `{print_preview}</{asterisk}\... {asterisk}/>`
* `v`, a value of type `T::forwarded_type` or `{value_with_formatters}<T, F\...>`,
   where `F\...` is such that `T::formatters` is an alias to `{tag}<F\...>`.

The following syntax is satisfied:
====
[source,cpp,subs=normal]
----
T::template make_printer_input<CharT>(preview, fpack, v)
----
[horizontal]
Return type:: A _{PrinterInput}_ type.
Return value:: A value `r` such that `&r.preview == &preview`
====

=== Type requirements _PrinterInput_ [[PrinterInput]]

Given

* `CharT`, a character type
* `Preview`, an instance of the `{print_preview}` class template
* `X`, a _PrinterInput_ type for types `CharT` and `Preview`
* `x`, a value of type `X` 

====
[source,cpp,subs=normal]
----
T::char_type
----
A type alias to `CharT`.
====

====
[source,cpp,subs=normal]
----
T::preview_type
----
A type alias to `Preview`.
====

====
[source,cpp,subs=normal]
----
T::printer_type
----
A type that is constructible from `X` and convertible to `const {printer}<CharT>&`,
such that the sequence:

[source,cpp,subs=normal]
----
std::size_t s  = x.preview.<<size_preview_get_size,get_size>>();
typename T::printer_type p{x};
std::size_t predicted_size = x.preview.<<size_preview_get_size,get_size>>() - s;
std::size_t dest_size      = dest.<<outbuff_hpp#basic_outbuff_space,space>>();
static_cast<const printer<CharT>&>(p).<<printer,print_to>>(dest);
----
statisfies the following postconditions when `Preview::<<print_preview,size_required>>` is `true`:

*  if `predicted_size \<= dest_size` is `true` then `dest.recycle()` is not called.
====

====
[source,cpp,subs=normal]
----
x.preview
----
A lvalue reference of type `Preview`.
====

=== Function template `make_default_printer_input` [[make_default_printer_input]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Preview, typename FPack, typename Arg>
constexpr auto make_default_printer_input
    ( Preview& preview, const FPack& fp, const Arg& arg)
    noexcept(/{asterisk} see below\... {asterisk}/)
    \-> /{asterisk} see below\... {asterisk}/

} // namespace strf
----

The expression `make_default_printer_input<CharT>(preview, fp, arg)` is equivalent to
[source,cpp,subs=normal]
----
{print_traits_of}<Arg>::template <<PrintTraits_functions,make_printer_input>><CharT>(preview, fp, arg);
----

=== Facet category `print_override_c` [[print_override_c]]

This facet category affects the return type and value of `{make_printer_input}`.
This way, it enables the user change how a printable type is printed,
by making the library an the alternative __{PrinterInput}__ object.
A facet of this category should **aways** be <<constrain,constrained>> to the
printable type intended to be overriden.

[source,cpp,subs=normal]
----
namespace strf {

struct print_override_c {
    static constexpr bool constrainable = true;

    constexpr static <<no_print_override,no_print_override>> get_default() noexcept {
        return {};
    }
};

} // namespace strf
----

==== Struct `no_print_override` [[no_print_override]]

`no_print_override` is the default facet of `print_override_c` category.

[source,cpp,subs=normal]
----
namespace strf {

struct no_print_override {
    using category = print_override_c;

    template <typename CharT, typename Preview, typename FPack, typename Arg>
    constexpr static auto make_printer_input(Preview& preview, const FPack& fp, Arg&& arg)
        noexcept(noexcept({make_default_printer_input}<CharT>(preview, fp, arg)))
    {
        return {make_default_printer_input}<CharT>(preview, fp, arg);
    }
};

} // namespace strf
----

=== Function template `make_printer_input` [[make_printer_input]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Preview, typename FPack, typename Arg>
constexpr auto make_printer_input(Preview& preview, const FPack& fp, const Arg& arg)
{
    auto tag = typename {print_traits_of}<Arg>::<<PrintTraits,facet_tag>>;
    auto f = {get_facet}<{print_override_c}, tag>(fp);
    return f.template make_printer_input<CharT>(preview, fp, arg);
}

} // namespace strf
----

=== Type alias template `printer_type` [[printer_type]]

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT, typename Preview, typename FPack, typename Arg>
using printer_input_type = decltype
    ( {make_printer_input}<CharT>( std::declval<Preview&>()
                               , std::declval<const FPack&>()
                               , std::declval<Arg>() ) );

template <typename CharT, typename Preview, typename FPack, typename Arg>
using printer_type = typename printer_input_type<CharT, Preview, FPack, Arg>::printer_type;

} // namespace strf
----

[[printer]]
=== Class template `printer`

[source,cpp,subs=normal]
----
namespace strf {

template <typename CharT>
class printer {
public:
    using char_type = CharOut;
    virtual ~printer() {}
    virtual void print_to({basic_outbuff}<CharT>&) const = 0;
};

} // namespace strf
----

=== Class template `print_preview` [[print_preview]]

[source,cpp,subs=normal]
----
namespace strf {

enum class preview_width: bool { no = false, yes = true };
enum class preview_size : bool { no = false, yes = true };

template <preview_size SizeRequired, preview_width WidthRequired>
class print_preview
    : public size_preview<static_cast<bool>(SizeRequired)>
    , public width_preview<static_cast<bool>(WidthRequired)>
{
public:

    static constexpr bool size_required = static_cast<bool>(SizeRequired);
    static constexpr bool width_required = static_cast<bool>(WidthRequired);
    static constexpr bool nothing_required = ! size_required && ! width_required;

    constexpr print_preview() noexcept = default;
    constexpr explicit print_preview(<<width_t,width_t>> initial_width) noexcept;
};

} // namespace strf
----
==== Constructors
====
[source,cpp,subs=normal]
----
constexpr print_preview() noexcept;
----
[horizontal]
Effect:: Default-construct each of the base classes.
====
====
[source,cpp,subs=normal]
----
constexpr explicit print_preview(<<width_t,width_t>> initial_width) noexcept;
----
Compile-time requirement:: `WidthRequired` is `preview_width::yes`, otherwise this constructor
does not participate in overload resolution.
Effect:: Initializes `<<width_preview, width_preview>>` base
with `initial_width`.
====
[[size_preview]]
=== Class template `size_preview`
[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class size_preview
{
public:
    explicit constexpr size_preview() noexcept;
    explicit constexpr size_preview(std::size_t initial_size) noexcept;

    constexpr void add_size(std::size_t) noexcept;
    constexpr std::size_t get_size() const noexcept;
};
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
explicit constexpr size_preview() noexcept;
----
Postcondition:: `get_size() == 0`
====
====
[source,cpp]
----
explicit constexpr size_preview(std::size_t initial_size) noexcept;
----
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `get_size() == initial_size`
====
====
[source,cpp]
----
constexpr void add_size(std::size_t s) noexcept;
----
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` ::: `(get_size() - previous_size == s)`, where `previous_size` is the return value of `get_size()` before this call.
====
[[size_preview_get_size]]
====
[source,cpp]
----
constexpr void get_size() const noexcept;
----
Return value::
When `Active` is `false`::: `0` (always)
When `Active` is `true` ::: The internally stored size value.
====
[[width_preview]]
=== Class template `width_preview`

[source,cpp,subs=normal]
----
namespace strf {
template <bool Active>
class width_preview
{
public:
    constexpr width_preview() noexcept;
    explicit constexpr width_preview(<<width_t,width_t>> initial_width) noexcept;
    constexpr void subtract_width(<<width_t,width_t>>) noexcept;
    constexpr void checked_subtract_width(std::ptrdiff_t w) noexcept;
    constexpr void clear_remaining_width() noexcept;
    constexpr <<width_t,width_t>> remaining_width() const noexcept;
}
} // namespace strf
----

==== Member functions
====
[source,cpp]
----
constexpr width_preview() noexcept;
----
Postcondition:: `remaining_width() == 0`
====
====
[source,cpp,subs=normal]
----
constexpr width_preview(<<width_t,width_t>> initial_width) noexcept;
----
Compile-time requirement:: `Active` is `true`, otherwise this constructor
does not participate in overload resolution.
Postcondition:: `remaining_width() == initial_width`
====
====
[source,cpp,subs=normal]
----
void subtract_width(<<width_t,width_t>> w) noexcept;
----
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == previous_w - w
----
where `previous_w` is the return value of `remaining_width()` before this call.
====
====
[source,cpp,subs=normal]
----
void checked_subtract_width(<<width_t,width_t>> w) noexcept;
----
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == (w < previous_w ? previous_w - w : 0)
----
where `previous_w` is the return value of `remaining_width()` before this call.
====
====
[source,cpp,subs=normal]
----
void checked_subtract_width(std::ptrdiff_t w)
----
Postcondition::
When `Active` is `false`::: None
When `Active` is `true` :::
+
[source,cpp,subs=normal]
----
remaining_width() == (w < previous_w.ceil() ? previous_w - (std::int16_t)w : 0)
----
where `previous_w` is the return value of `remaining_width()` before this call.
====

