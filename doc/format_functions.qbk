[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/format_functions.cpp]

[#format_functions]
[section Format functions]

The "conventional" input types that are ( or will be ) supported are:

* an integer ( `int, long, long long, unsigned int, unsigned long or unsigned long long`)
* a string ( a raw string, a `std::basic_string`, `std::basic_string_view`  ot `boost::basic_string_view`)
* a single character ( with the same type as the output character type, otherwise compilation fails )
* a `bool` ['( to do )]
* a `void*` ['( to do )] 
* a floating point ['( to do )]

In addition to those, there are also some [link special_input_types.special_input_types "special" input types], but these are covered in another section.

The library provides some functions ( actually function templates ) to be used to
specify formatting of the conventional input arguments.
For example, in order to print some integer in hexadecimal, you can use the `hex` function template:

[trivial_hex_sample]

Actually, `hex` is just a syntactic sugar that that calls `fmt`:

``
template <typename T>
constexpr auto hex(const T& value)
{
    return fmt(value).hex();
}
``

The [*`fmt`] function template returns an object that contains formatting
information in addition to the value to be printed.
The formatting can be modified with the member functions
listed in the table below. All these member functions return `*this`,
so that you can use many of them, /e.g./, `fmt(x).hex().showbase()^20` .

The return type of `fmt(arg)` depends on the type of `arg`, and may not contain
some of the member functions below. That's why `hex("blah blah")`, for example
does not compile, since hexadecimal formatting does not apply to strings.

[table
[[member function] [effect] [input types]]

[
[`operator>(int width)`]
[right adjustment]
[all ( integer, floating point, character, string, `void*`, `bool`) ]
]


[[`operator<(int width)`] [left adjustment] [all]]
[[`operator^(int width)`] [centered adjustment] [all]]
[
[`operator%(int width)`]
[internal adjustment (as in [@http://en.cppreference.com/w/cpp/io/manip/left `std::internal`])]
[integer and floating point]
]
[[`fill(char32_t ch)`][sets the fill character to [~ch]] [all]]
[[`p(int precision)`][sets the precision] [integer and floating point]]
[[`dec()`] [decimal base] [integer and floating point]]
[[`hex()`] [hexadecimal base] [integer and floating point]]
[[`oct()`] [octal base] [integer]]
[
[`uppercase(bool b)`]
[if [~b] is `true`, convert some characters to uppercase (as in [@http://en.cppreference.com/w/cpp/io/manip/uppercase `std::uppercase`])]
[integer and floating point]
]

[
[`showpos(bool b)`]
[if [~b] is `true`, print the positive sign for non-negative numbers (as in [@http://en.cppreference.com/w/cpp/io/manip/showpos `std::showpos`])]
[integer and floating point]
]

[
[`showbase(bool b)`]
[if [~b] is `true`, print the numeric base indication (as in [@http://en.cppreference.com/w/cpp/io/manip/showbase `std::showbase`])]
[integer and floating point]
]
[[`operator+()`][same as `showpos(true)`][integer and floating point]]
[[`operator~()`][same as `showbase(true)`][integer]]
[[`multi(int count)`][print the character [~count] times][character]]

[
[`encoding(encoding<CharT>)`]
[specify the encoding of the input string (see [link encoding_conversion.encoding_conversion encoding] ) ]
[string and (to do) character]
]

[
[`sani()`]
[sanitizes the input string according to its encoding
 (see [link encoding_conversion.encoding_conversion.sanitization sanitization] )
]
[string and (to do) character]
]

]

[h4 Syntactic sugars]

[table Syntactic sugars
[[expression] [equivalent to]]
[[`hex(x)`][`fmt(x).hex()`]]
[[`uphex(x)`][`fmt(x).hex().uppercase(true)`]]
[[`dec(x)`][`fmt(x).dec()`]]
[[`oct(x)`][`fmt(x).oct()`]]
[[`right(x, width)`][`fmt(x) > width`]]
[[`left(x, width)`][`fmt(x) < width`]]
[[`center(x, width)`][`fmt(x) ^ width`]]
[[`internal(x, width)`][`fmt(x) % width`]]
[[`right(x, width, fill)`]   [`fmt(x).fill(fill) > width`]]
[[`left(x, width, fill)`]    [`fmt(x).fill(fill) < width`]]
[[`center(x, width, fill)`]  [`fmt(x).fill(fill) ^ width`]]
[[`internal(x, width, fill)`][`fmt(x).fill(fill) % width`]]
[[`multi(x, count)`] [`fmt(x).multi(count)`]]
[[`sani(x)`] [`fmt(x).sani()`]]
[[`ascii(x)`][`fmt(x).encoding(ascii())`]]
[[`iso_8859_1(x)`  ][`fmt(x).encoding(iso_8859_1())`]]
[[`iso_8859_15(x)` ][`fmt(x).encoding(iso_8859_15())`]]
[[`windows_1252(x)`][`fmt(x).encoding(windows_1252())`]]
[[`utf8(x)`        ][`fmt(x).encoding(utf8())`]]
[[`mutf8(x)`       ][`fmt(x).encoding(mutf8())`]]
[[`utf16(x)`       ][`fmt(x).encoding(utf16<std::remove_cvref_t>(decltype(x[0]))>()`]]
[[`utf32(x)`       ][`fmt(x).encoding(utf32<std::remove_cvref_t>(decltype(x[0]))>()`]]
[[`utfw(x)`        ][`fmt(x).encoding(utfw())`]]
]

[h4 Example]

[formatting_samples]

[endsect]