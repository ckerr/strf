[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section API Reference /(todo)/]


[h3 Class template `facets_pack`]

[table
[[`template <typename ... FPE>`[br]
`class facets_pack;`]]
[[
Class template facets_pack is used to store facets object.
For each [~F] in `FPE...`, there is a value of [~F] in `facets_pack<FPE...>`.
[variablelist
   [[Compile time requirements]
    [All types in `FPE...` must satisfy the
    [link FacetsPackElementRequirements `FacetsPackElement`]]]]]]]

[h4 Constructors]

[table
[[`constexpr facets_pack(const Facets& ... facets)`]]
[[[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from a
      const reference of the corresponding argument `facets...`]]]]]]
      
[table
[[`constexpr facets_pack(const facets_pack& cp)`]]
[[[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from the
      a const reference of the corresponding element in `cp`]]]]]]

[/
[table
[[`facets_pack(facets_pack&& cp)`]]
[[
[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from the
      a rvalue reference of the corresponding element in `cp`]]]]]]
]


[#FacetsPackElementRequirements]
[h3 Concept `FacetsPackElement`]

A given a type [~F] is a `FacetsPackElement`, if [_any of] the following conditions is true:

* [~F] satisfies the [link FacetRequirements `Facet`] requirements
  and `facet_stored_by_value<F>` is `true`
* [~F] is an instance of [link facets_pack `facets_pack`].
* [~F] is an instance of [link constrained_fpe `constrained_fpe`].
  [/`<`[~F2]`, `[~Filter]`>`,
  where [~F2] satisfies the
  [link FacetsPackElementRequirements `FacetsPackElement`] requirements.]
* [~F] is `const `[~F2]`&`, where [~F2] satisfies one of the previous requirements.
* [~F] is `const `[~F2]`&`, where [~F2] satisfies [link FacetRequirements `Facet`]
  requirements, and `facet_stored_by_value<F2>` is `false`.
  
[#FacetRequirements]
[h3 Concept `Facet`]

A given a type [~F] is a `Facet` only if [_all] the following conditions are met:

* If [~F] is abstract or not CopyConstructible, then
  [link facet_stored_by_value `facet_stored_by_value`]`<`[~F]`>`
  must be `false`.
* [link facet_category `facet_category`]`<`[~F]`>`
  satisfies the [link FacetCategoryRequirements `FacetCategory`]
  requirements.
* [~F] satisfies the specific requirements associated to
  [link facet_category `facet_category`]`<`[~F]`>`.


[#FacetCategoryRequirements]
[h3 Concept `FacetCategory`]

A given a type [~FCat] is a `FacetCategory` only if:

* There is a list of requirements, /i.e./ a Concept,
  associated ( even if only informally ) to [~FCat].

* [~FCat] has a static member function named `get_default` that takes
  no argument and whose return type is either [~F] or `const `[~F]`&`,
  where [~F] is a type that satisfies the requirements associated to
  [~FCat].
  

[#facet_traits]
[h3 Class template `facet_traits`]

This class template provides the [link FacetRequirements Facets] informations.
If you create a new facet, you can either define such informations as
members of the facet, or specialize `facet_traits`.

``
template <typename Facet>
class facet_trait
{
public:
    using category = /* Facet::category or void */;
    constexpr static bool store_by_value = /* Facet::store_by_value or true */;
};
``
[itemized_list
 [`facet_trait<`[~Facet]`>::store_by_value` is equal to [~Facet]`::store_by_value`
  is such expression is well formed and implicitly convetible to `bool`,
  otherwise it is `false`.]
 [`facet_trait<`[~Facet]`>::category` is a type alias to
  `Facet::category` if such member exist and is a type, otherwise it is `void`.]]

[h4 Specialization]

``
template <typename F>
class facet_trait<const F>
{
public:
    using category = typename facet_trait<F>::category;
    constexpr static bool store_by_value = facet_stored_by_value<F>::store_by_value;
};
``

[#facet_category]
[h3 Type alias template `facet_category`]

`facet_category` is just a syntatic sugar:

``
template <typename Facet>
using facet_category = facet_traits<Facet>::typename category;
``

[#facet_stored_by_value]
[h3 Variable template `facet_stored_by_value`]

[table
[[
  `template <typename T>`[br]
  `constexpr bool facet_stored_by_value;`
]]
[[
  [variablelist
    [[Value]
     [`facet_traits<T>::store_by_value` if such expression
       is well formed and implicitly convertible to `bool`,
       otherwise the value is `true`.]]]
]]
]


[h3 Function template `pack`]

[table
[[ 
   `template <typename ... Types>`[br]
   `constexpr facets_pack<VTypes...>  pack(const Types& ... args)`
]]
[[ 
  [variablelist
    [[Effect]
     [Creates a `facets_pack` object from `args`.]]
    [[Return Type]
     [`facets_pack<VTypes...>`, where for each `Ti` in `Types...`,
      the corresponding `Vi` in `VTypes...` is:
      [itemized_list
        [`const F&` , if `Vi` is `std::reference_wrapper<F>`]
        [`const Vi` , if `Vi` `facet_stored_by_value<Vi>` is `false`]
        [`Ti` , otherwise]]]]]
]]
]


[#get_facet]
[h3 Function template `get_facet`]

[table
[[
  `template <typename FCat, typename Tag, typename ... T>`[br]
  `constexpr decltype(auto) get_facet(const facets_pack<T...>& fp);`
]]

[[
  [variablelist
   [[Compile time requiments]
    [`FCat` satisfes [link FacetCategoryRequirements `FacetCategory`]
        requirements]]
   [[Effect]
    [If [link has_facet `has_facet`]`<FCat, Tag>(fp)` then return
     [link do_get_facet `do_get_facet`]`<FCat, Tag>(fp)`
     otherwise return `FCat::get_default()`.]]
   ]
]]      
]
[#has_facet]
[h3 Hypothetical function template `has_facet`]

[table
[[
`template <typename FCat, typename Tag, typename FPE>`[br]
`constexpr bool has_facet(const FPE& fpe)`
]]
[[
  [variablelist
    [[Note]
     [This function template is not part of the library.
      It is only document to help to explain
      the [link get_facet `get_facet`] function template]]

  [[Compile time requirements]
   [[itemized_list
     [`FCat` satisfes [link FacetCategoryRequirements `FacetCategory`]
      requirements]
     [`FPE` satisfies the [link FacetsPackElementRequirements `FacetsPackElement`]
      requirements]]]]
     
  [[Effect]
   [[itemized_list
     [If `FPE` is a [link facets_pack `facets_pack`] then return whether there
      is any element `elm` in `fpe` such that `has_facet<FCat, Tag>(elm)`
      is `true`.]
     [If `FPE` is [link constrained_fpe `constrained_fpe`]`<FPE, Filter>`,
      then return `Filter<Tag>::value && has_facet<FCat, Tag>(fpe.get())`.]
     [If `FPE` satisfies the [link FacetRequirements `Facet`] requirements,
      return `std::is_same_v<FCat, `[link facet_category `facet_category`]
      `<FPE>>`]]]] 
   ]
]]
]

[#do_get_facet]
[h3 Hypothetical function template `do_get_facet`]
[table
[[
`template <typename FCat, typename Tag, typename FPE>`[br]
`constexpr decltype(auto) do_get_facet(const FPE& fpe);`
]]

[[
[variablelist

    [[Note]
     [This function template is not part of the library.
      It only is documented to help to explaine the
      [link get_facet `get_facet`] function template]]
      
    [[Compile time requiments]
     [[itemized_list
      [`FCat` satisfes [link FacetCategoryRequirements `FacetCategory`]
       requirements.]
      [`FPE` satisfies the [link FacetsPackElementRequirements `FacetsPackElement`]
       requirements.]
      [`has_facet<FCat, Tag>(fpe)` is `true`.]]]]

    [[ Effect]
     [[itemized_list
      [If `FPE` is a [link facets_pack `facets_pack`], then return
       `do_get_facet<FCat, Tag>(elm)` where [~elm] is the last
       element in `fpe` such that `has_facet<FCat, Tag>(elm)` is `true`.]
      [If `FPE` is a [link constrained_fpe `constrained_fpe`], then
       return `do_get_facet(fpe.get())`]
      [Otherwise return `fpe`]]]]

    [[Return type]
     [`const F&` where F is a type that satisfies the [link
      FacetRequirements `Facet`] requirements]]

 
   ]
]]
]

[#constrained_fpe]
[h3 Class template `constrained_fpe`]

[table
[[
  `template <template <typename> class Filter, typename FPE>`[br]
  `class constrained_fpe;`
]]
[[
  The class template `constrained_fpe` is designed to be used in
  [link facets_pack `facets_pack`].
  `constrained_fpe<Filter, FPE>` holds a value of `FPE` that will
  only be returned by [link get_facet `get_facet`]`<Category, Tag>`
  if `Filter<Tag>::value` is `true`.

  [variablelist

[/
   [[Template parameters]
    [[* `FPE`] The type of the element that `constrained_fpe<Filter, FPE>` stores]
    [[* `Filter`] A class template that indicated whether a type `T` ]]
]

   [[Compile time requirements]
    [[itemized_list
     [For any type [~T], `Filter<T>` has a member variable `value` that is a
      static constexpr value whose type is implicitly convertible to `bool`.]     
     [`FPE` satisfies [link FacetsPackElementRequirements `FacetsPackElement`]
      requirements.]
     [[link is_constrainable_v `is_constrainable_v`]`<FPE>` is `true`]]]]]
]]
]
      

[h4 Constructors]

[table
[[`constexpr constrained_fpe(const FPE& fpe)`]]
[[
  [variablelist
   [[Effect]
    [Initializes the element of the `constrained_fpe` with `fpe`.]]]
    
]]
]


[table
[[`constexpr constrained_fpe(const constrained_fpe& other)`]]
[[
  Implicitly-defined copy constructor.
  [variablelist
   [[Effect]
    [Initializes the element of the `constrained_fpe` from
     the const reference of the element of `other`]]
   [[Compile time requirement]
    [`std::is_copy_constructible<FPE>::value`]]]
    
]]
]

[table
[[`constexpr constrained_fpe(constrained_fpe&& other)`]]
[[
  Implicitly-defined move constructor.
  [variablelist
   [[Effect]
    [Initializes the element of the `constrained_fpe` from
     the rvalue reference of element of `other`]]
   [[Compile time requirement]
    [`std::is_move_constructible<FPE>::value`]]]
]]
]

[h4 Member functions]

[table
[[`constexpr const FPE& get() const`]]
[[
  [variablelist
   [[Effect]
    [returns the stored element.]]]
]]
]

[#is_constrainable_v]
[h3 Variable template `is_constrainable_v`]

[table
[[
  `template <typename FPE>`[br]
  `constexpr bool is_constrainable_v;`
]]
[[
  [variablelist
    [[Compile time  requirement]
     [`FPE` satisfies [link FacetsPackElementRequirements `FacetsPackElement`]
      requirements.]]
    [[Value]
     [[itemized_list
      [If `FPE` is `facets_pack<T...>`, the value is `(is_constrainable_v<T> && ...)`]
      [If `FPE` is `const T&`, the value is `is_constrainable_v<T>`]
      [If `FPE` is [link constrained_fpe `constrained_fpe`]`<Filter, T>`,
       the value is `true`]
      [else the value is `facet_traits<FPE>::constrainable` if such expression
       is well formed and implicitly convertible to `bool`, else it is `true`]]]]]
]]
]

[#constrain]
[h3 Function template `constrain`]

[table
[[
  `template <template <typename> class Filter, typename T>`[br]
  `constexpr constrained_fpe<Filter, U> constrain(const T& arg);`
]]
[[
  `constrain` is just a syntatic sugar to construct instances of
  [link constrained_fpe `constrained_fpe`]

  [variablelist
    [[Effect]
     [Create [link constrained_fpe `constrained_fpe`] object from `arg`]]
    [[Return type]
     [ `constrained_fpe<Filter, U>`, where `U` is
       [itemized_list
         [`const F&`, if `T` is `std::reference_wrapper<F>`]
         [`const T&`, if `facet_stored_by_value<T>` is `false`]
         [`T`, otherwise]]]]
    [[Compile type requirements]
     [`T` is a type such that `U` satisfies the
      [link FacetsPackElementRequirements `FacetsPackElement`]
      requirements.]]]
]]
]

[#value_with_format]
[h3 Class template `value_with_format`]






``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::fn<T>`. ]
      [`Fmt::fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::fn<T>` can be constructed from `const Fmt::fn<U>&`
       , assuming both are well formed. ] ] ] ]    


[#printer]
[h3 Abstrac class template `printer`]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual bool write(output_buffer<CharT>& ob) const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[h4 Public virtual member functions]

[#printer_write]
[table
[[
  `virtual bool write(`[link output_buffer `output_buffer`]`<CharT>& ob) const = 0;`
]]
[[
  [variablelist
    [[Effect]
     [Writes text into `ob`]]
    [[Return]
     [`true` on success, `false` otherwise. On failure, this function shall also
      call `ob.`[link ouput_buffer_set_error `set_error`]`(`[~some_error_code]`)`.]]
    [[Post condition]
     [If `ob.size() <= necessary_size()` then this function must not call
      `ob.recycle()`]]]
]]
]

[#printer_necessary_size]
[table
[[
  `virtual std::size_t necessary_size() const = 0;`
]]
[[
   [variablelist
    [[Note]
     [This function is only called by [link destination `destination`]
      when [link destination_reserve_calc `reserve_calc`] is used.]]
    [[Effect]
      [Calculates how many characters [link printer_write `write`]
       function writes. The result does not need to be exact, but
       must not be less than the exact value.]]]
]]
]


[#printer_remaining_width]
[table
[[
  `virtual int remaining_width( int w ) const = 0;`
]]
[[
   [variablelist
    [[Effect]
     [ /To-do/ ]]]
     [/Returns the same as `std::max(0, w - this_width)`,
      where `this_width` is the width of the content written by `write()`.
      This function is used in [link joins `joins`]. The implementation
      may have to use the [link width_calculation facets for width calculation]]
]]
]


[#output_buffer]
[h3 Class template `output_buffer`]

[#min_buff_size]
``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

template <typename CharT>
class output_buffer
{
public:

    using char_type = CharT;

    virtual ~output_buffer();

    virtual bool recycle() = 0;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;

    void advance_to(CharT* p) noexcept;
    void advance(std::size_t n) noexcept;

    void set_error(std::error_code ec) noexcept;
    void set_error(std::errc e) noexcept;
    void set_encoding_error() noexcept;
    std::error_code get_error() const noexcept;
    bool has_error() const noexcept;

protected:

    output_buffer(CharT* buff_begin, CharT* buff_end) noexcept;
    output_buffer(CharT* buff_begin, std::size_t buff_size) noexcept;

    void set_pos(CharT* p) noexcept;
    void set_end(CharT* e) noexcept;
};

}}} // namespace boost::stringify::v0
``
[table
[[`public: virtual bool recycle() = 0;`]]
[[[variablelist
     [[ Effects]
      [ Consumes the content in the range \u005B ['initial_pos], `pos()` \u0029,
        where ['initial_pos] is the value returned by `pos()` after the previous
        call to `recycle()` and before any call to `advance()`
        and `advance_to(p)`.]
      [ On success, calls `set_pos(`[~new_pos]`)` and optionally
        `set_end(`[~new_end]`)`.
        On failure, calls `set_error(`[~some_error]`)`.  ]]
     [[ Return value]
      [ `true` on success and `false` otherwise.]]
     [[ Postcondition]
      [ on sucess: size() >= min_buff_size]]]]]]

[table
[[`public: std::size_t size() const noexcept;`]]
[[[variablelist
   [[Return value]
    [`end() - pos()`]]]]]]

[table
[[`public: char_type* pos() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The memory position where the content shall be written]]]]]]

[table
[[`public: char_type* end() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The end of memory position where the content shall be written]]]]]]

[table
[[`public: void advance_to(char_type* p) noexcept;`]]
[[[variablelist
   [[Effect]
      [update pos] ]
   [[Precondition]
      [`pos() <= p && p <= end()`] ]
   [[Postcondition]
      [`pos() == p`]]]]]]

[table
[[`public: void advance(std::size_t n) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`pos() + n <= end()`] ]
  [[Effect]
     [same as `advance(pos() + n)`]]]]]]

[table
[[`public: void set_error(std::error_code ec) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`has_error() == true`]]]]]]
     
[table
[[`public: void set_error(std::errc e) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::make_error_code(e))`]]]]]]
    
[table
[[`public: void set_encoding_error() noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::errc::illegal_byte_sequence)`]]]]]]

[table
[[`public: std::error_code get_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [The value passed to `set_error` the first time it was called]]]]]]

[table
[[`public: bool has_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [Whether `set_error` has been called ]]]]]]

[table
[[`protected: void set_pos(char_type* p) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`pos() == p`]]]]]]

[table
[[`protected: void set_end(char_type* e) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`end() == e`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, char_type* buff_end) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`buff_begin <= buff_end`]]
  [[Postconditions]
     [\u2022 `pos() == buff_begin` ]
     [\u2022 `pos() == buff_end`   ]
     [\u2022 `has_error() == false`]
     [\u2022 `get_error() == std::error_code{}`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, std::size_t buff_size) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `output_buffer(buff_begin, buff_begin + buff_size)` ]]]]]]
     




[#nodiscard_error_code_class]
[h3 Class `nodiscard_error_code`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class [[nodiscard]] nodiscard_error_code: public std::error_code
{
public:
    using std::error_code::error_code;

    nodiscard_error_code(const std::error_code& ec) noexcept
        : std::error_code(ec)
    {}
};

}}}
``

[#stringify_error]
[h3 Class `stringify_error`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class stringify_error: public std::system_error
{
public:
    using std::system_error::system_error;
};

}}}
``





[endsect]