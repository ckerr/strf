[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section API Reference /(todo)/]

[#facet_traits]
[h3 Class template `facet_traits`]

The purpose of this class template is to be specialized when
a new facet is to be added to the library but it is not
possible to add the members `category` or `store_by_value`
in it.

``
template <typename F>
class facet_trait
{
public:
    using category = /* Facet::category or void */;
    constexpr static bool store_by_value = /* Facet::store_by_value or true */;
};
``
[itemized_list
 [`facet_trait<`[~F]`>::store_by_value` is equal to [~F]`::store_by_value`
  is such expression is well formed and implicitly convetible to `bool`,
  otherwise it is `false`.]
 [`facet_trait<`[~F]`>::category` is a type alias to
  `F::category` if such member exist is a type, otherwise it is `void`.]]

[h4 Specialization]

``
template <typename F>
class facet_trait<const F>
{
public:
    using category = typename facet_trait<F>::category;
    constexpr static bool store_by_value = facet_trait<F>::store_by_value;
};
``

[#facet_category]
[h3 Type alias template `facet_category`]

`facet_category` is just a syntatic sugar:

``
template <typename F>
using facet_category = facet_traits<F>::typename category;
``

[#facet_stored_by_value]
[h3 Variable template `facet_stored_by_value`]

`facet_stored_by_value` is just a syntatic sugar:

``
template <typename F>
constexpr bool facet_stored_by_value = facet_traits<F>::store_by_value;
``
[#constrained_facet]
[h3 Class template `constrained_facet`]

/TO-DO/

[#constrain]
[h3 Function template `constrain`]
`constrain` is just a syntatic sugar to construct instances of
[link constrained_facet `constrained_facet`]


[table
[[
`template <template <typename> class Filter, typename F>`[br]
`constexpr constrained_facet<Filter, F> constrain(const F& f);`
]]
[[
]]
]


/TO-DO/


[#FacetCategoryRequirements]
[h3 Concept `FacetCategory`]

A given a type [~FCat] is a `FacetCategory` only if [~FCat] has a static
member function named `get_default` that takes no argument and whose return
type is either [~F] or `const `[~F]`&`, where [~F] is a type such that
`std::is_same_v<`[~FCat]`, `[link facet_category `facet_category`]`<`[~F]`>>`
is `true`.


[#FacetRequirements]
[h3 Concept `Facet`]

A given a type [~F] is a `Facet` only if all the following conditions are met:

* If [~F] is abstract or not CopyConstructible, then
  [link facet_stored_by_value `facet_stored_by_value`]`<`[~F]`>`
  must be `false`.
* [link facet_category `facet_category`]`<`[~F]`>`
  satisfies the [link FacetCategoryRequirements `FacetCategory`]
  requirements

[#FacetPackElementRequirement]
[h3 Concept `FacetPackElement`]

A given a type [~F] is a `FacetPackElement`, if any of the following conditions is met:

* [~F] satisfies the [link FacetRequirements `Facet`] requirements.
* or [~F] is [link constrained_facet `constrained_facet`]`<`[~F2]`, `[~Filter]`>`,
  where [~F2] satisfies the
  [link FacetPackElementRequirement `FacetPackElement`] requirements.
* or [~F] is `std::reference_wrapper<`[~F2]`>` or
 `std::reference_wrapper<const `[~F2]`>`, where [~F2] satisfies the
  [link FacetPackElementRequirement `FacetPackElement`] requirements.


[h3 Class template `facets_pack`]

``
template <typename ... Facets>
class facets_pack;
``
For each [~F] in [~Facets]`...` there is either a value of [~F] or a
reference to `const `[~F] in an object of type `facets_pack<Facets...>`.
It is a reference only if [~F] satisfies the [link FacetRequirements Facet]
requirements and [link facet_stored_by_value `facet_stored_by_value`]`<`[~F]`>`
is `false`, otherwise it is a value of [~F]. In any case, [~F] must satisfy
the [link FacetPackElementRequirement `FacetPackElement`] requirements.

[h4 Constructors]


[table
[[`constexpr facets_pack(const Facets& ... facets)`]]
[[[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from a
      const reference of the corresponding argument `facets...`]]]]]]
      
[table
[[`constexpr facets_pack(const facets_pack& cp)`]]
[[[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from the
      a const reference of the corresponding element in `cp`]]]]]]

[/
[table
[[`facets_pack(facets_pack&& cp)`]]
[[
[variablelist
    [[Effect]
     [Construct each element of `facets_pack<Facets...>` from the
      a rvalue reference of the corresponding element in `cp`]]]]]]
]


[h3 Function template `pack`]

[table
[[
`template <typename ... Facets>`[br]
`constexpr facets_pack<Facets...>  pack(const Facets& ... facets)`
]]
[[
[variablelist
     [[ Effect]
      [return `facets_pack<Facets...>{facets ...}`]]]
]]]


[#strip_facet]
[h3 Function template `strip_facet` (/to-do/)]

[table
[[
`template <typename FPE>`[br]
`constexpr const auto& strip_facet(const FPE& elm)`
]]
[[
  [variablelist
  [[Compile time requirements]
   [[itemized_list
     [`FPE` satisfies [link FacetPackElementRequirement `FacetPackElement`] requirements]]]]
  [[Effect]
   [[itemized_list
     [If `FPE` is [link constrained_facet `constrained_facet`]`<FPE2, Filter>`,
      then return `strip_facet(elm.get())`.]
     [If `FPE` is `std::reference_wrapper<FPE2>`
      then return `strip_facet(elm.get())`.]
     [Otherwise return `elm`]]]]
   [[Note]
    [This function template is not used anywhere in the library.
    It has been defined only to help to document the [link get_facet
    `get_facet`] function template.]]
   ]
]]
]

[#facet_matches]
[h3 Function template `facet_matches` (/to-do/)]

[table
[[
`template <typename FCat, typename Tag, typename FPE>`[br]
`constexpr bool facet_matches(const FPE& elm)`
]]
[[
  [variablelist
  [[Compile time requirements]
   [[itemized_list
     [`FPE` satisfies [link FacetPackElementRequirement `FacetPackElement`] requirements]
     [`FCat` satisfes [link FacetCategoryRequirements `FacetCategory`] requirements]]]]
  [[Effect]
   [[itemized_list
     [If `FPE` is [link constrained_facet `constrained_facet`]`<FPE2, Filter>`,
      then return `Filter<Tag>::value && facet_matches(elm.get_facet())`.]
     [If `FPE` is `std::reference_wrapper<FPE2>`
      then return `facet_matches(elm.get())`.]
     [Otherwise return `std::is_same_v<FCat, `[link facet_category
     `facet_category`]`<FPE>>`]]]]
   [[Note]
    [This function template is not used anywhere in the library.
    It has been defined only to help to document the [link get_facet
    `get_facet`] function template.]]
   ]
]]
]

[#get_facet]
[h3 Function template `get_facet`]
[table
[[
`template <typename FCat, typename Tag, typename ... F>`[br]
`constexpr decltype(auto) get_facet(const facets_pack<F...>& fp);`
]]

[[
[variablelist
     [[ Effect]
     [
       Return [link strip_facet `strip_facet`]`(elm)` where [~elm] is the last
       element in `fp` such that
       [link facet_matches `facet_matches`]`<FCat, Tag>(elm)` is `true`.
       
       If there is not such element in `fp`, then return `FCat::get_default()`.
     ]]

     [[Return type]
     [
       Same as [link strip_facet `strip_facet`]`(elm)` or `FCat::get_default()`
       depending on whether `fp` contains an element [~elm] such that
       [link facet_matches `facet_matches`]`<FCat, Tag>(elm)` is `true`.

       Note: while [link strip_facet `strip_facet`] aways return
       a const reference, `FCat::get_default()` may return by value.
     ]]]
]]
]

[#value_with_format]
[h3 Class template `value_with_format`]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::fn<T>`. ]
      [`Fmt::fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::fn<T>` can be constructed from `const Fmt::fn<U>&`
       , assuming both are well formed. ] ] ] ]    



[#printer]
[h3 Class template `printer`]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual bool write(output_buffer<CharT>& ob) const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[itemized_list
  [ [*write()] shall write the content into the [link output_buffer `output_buffer<CharT>`]
        argument and return `true` on success. Otherwise, it shall call
        `ob.set_error(`[~some_error_code]`)` and return `false`. ]
  [ [*necessary_size()] shall return the amount of characters written
        by `write()`, or a little more if the exact calculation is difficult,
        but never less. It is called when the output type needs to preallocate
        memory ( see [link syntax_reserve `reserve_auto()`] function ).]
  [ [*remaining_width(w)] shall return the same as `std::max(0, w - this_width)`,
        where `this_width` is the width of the content written by `write()`.
        This function is used in [link joins `joins`]. The implementation
        may have to use the [link width_calculation facets for width calculation]
        ( /to do/: this needs to be better documented ) ]
] [/itemized_list]



[#output_buffer]
[h3 Class template `output_buffer`]

[#min_buff_size]
``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

template <typename CharT>
class output_buffer
{
public:

    using char_type = CharT;

    virtual ~output_buffer();

    virtual bool recycle() = 0;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;

    void advance_to(CharT* p) noexcept;
    void advance(std::size_t n) noexcept;

    void set_error(std::error_code ec) noexcept;
    void set_error(std::errc e) noexcept;
    void set_encoding_error() noexcept;
    std::error_code get_error() const noexcept;
    bool has_error() const noexcept;

protected:

    output_buffer(CharT* buff_begin, CharT* buff_end) noexcept;
    output_buffer(CharT* buff_begin, std::size_t buff_size) noexcept;

    void set_pos(CharT* p) noexcept;
    void set_end(CharT* e) noexcept;
};

}}} // namespace boost::stringify::v0
``
[table
[[`public: virtual bool recycle() = 0;`]]
[[[variablelist
     [[ Effects]
      [ Consumes the content in the range \u005B ['initial_pos], `pos()` \u0029,
        where ['initial_pos] is the value returned by `pos()` after the previous
        call to `recycle()` and before any call to `advance()`
        and `advance_to(p)`.]
      [ On success, calls `set_pos(`[~new_pos]`)` and optionally
        `set_end(`[~new_end]`)`.
        On failure, calls `set_error(`[~some_error]`)`.  ]]
     [[ Return value]
      [ `true` on success and `false` otherwise.]]
     [[ Postcondition]
      [ on sucess: size() >= min_buff_size]]]]]]

[table
[[`public: std::size_t size() const noexcept;`]]
[[[variablelist
   [[Return value]
    [`end() - pos()`]]]]]]

[table
[[`public: char_type* pos() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The memory position where the content shall be written]]]]]]

[table
[[`public: char_type* end() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The end of memory position where the content shall be written]]]]]]

[table
[[`public: void advance_to(char_type* p) noexcept;`]]
[[[variablelist
   [[Effect]
      [update pos] ]
   [[Precondition]
      [`pos() <= p && p <= end()`] ]
   [[Postcondition]
      [`pos() == p`]]]]]]

[table
[[`public: void advance(std::size_t n) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`pos() + n <= end()`] ]
  [[Effect]
     [same as `advance(pos() + n)`]]]]]]

[table
[[`public: void set_error(std::error_code ec) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`has_error() == true`]]]]]]
     
[table
[[`public: void set_error(std::errc e) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::make_error_code(e))`]]]]]]
    
[table
[[`public: void set_encoding_error() noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::errc::illegal_byte_sequence)`]]]]]]

[table
[[`public: std::error_code get_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [The value passed to `set_error` the first time it was called]]]]]]

[table
[[`public: bool has_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [Whether `set_error` has been called ]]]]]]

[table
[[`protected: void set_pos(char_type* p) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`pos() == p`]]]]]]

[table
[[`protected: void set_end(char_type* e) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`end() == e`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, char_type* buff_end) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`buff_begin <= buff_end`]]
  [[Postconditions]
     [\u2022 `pos() == buff_begin` ]
     [\u2022 `pos() == buff_end`   ]
     [\u2022 `has_error() == false`]
     [\u2022 `get_error() == std::error_code{}`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, std::size_t buff_size) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `output_buffer(buff_begin, buff_begin + buff_size)` ]]]]]]
     




[#nodiscard_error_code_class]
[h3 Class `nodiscard_error_code`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class [[nodiscard]] nodiscard_error_code: public std::error_code
{
public:
    using std::error_code::error_code;

    nodiscard_error_code(const std::error_code& ec) noexcept
        : std::error_code(ec)
    {}
};

}}}
``

[#stringify_error]
[h3 Class `stringify_error`]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class stringify_error: public std::system_error
{
public:
    using std::system_error::system_error;
};

}}}
``





[endsect]