[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section API Reference /(todo)/]


[h3 The `nodiscard_error_code` class]
[#nodiscard_error_code_class]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class [[nodiscard]] nodiscard_error_code: public std::error_code
{
public:
    using std::error_code::error_code;

    nodiscard_error_code(const std::error_code& ec) noexcept
        : std::error_code(ec)
    {}
};

}}}
``

[#stringify_error]
[h3 The `stringify_error` class]
``
namespace boost{
namespace stringify{
inline namespace v0 {

class stringify_error: public std::system_error
{
public:
    using std::system_error::system_error;
};

}}}
``

[#printer]
[h3 The `printer` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual bool write(output_buffer<CharT>& ob) const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[itemized_list
  [ [*write()] shall write the content into the [link output_buffer `output_buffer<CharT>`]
        argument and return `true` on success. Otherwise, it shall call
        `ob.set_error(`[~some_error_code]`)` and return `false`. ]
  [ [*necessary_size()] shall return the amount of characters written
        by `write()`, or a little more if the exact calculation is difficult,
        but never less. It is called when the output type needs to preallocate
        memory ( see [link syntax_reserve `reserve_auto()`] function ).]
  [ [*remaining_width(w)] shall return the same as `std::max(0, w - this_width)`,
        where `this_width` is the width of the content written by `write()`.
        This function is used in [link joins `joins`]. The implementation
        may have to use the [link width_calculation facets for width calculation]
        ( /to do/: this needs to be better documented ) ]
] [/itemized_list]




[#value_with_format]
[h3 The `value_with_format` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::fn<T>`. ]
      [`Fmt::fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::fn<T>` can be constructed from `const Fmt::fn<U>&`
       , assuming both are well formed. ] ] ] ]    










[#output_buffer]
[h3 The `output_buffer` class template]

[#min_buff_size]
``
namespace boost { namespace stringify { inline namespace v0 {

constexpr std::size_t min_buff_size = 60;

template <typename CharT>
class output_buffer
{
public:

    using char_type = CharT;

    virtual ~output_buffer();

    virtual bool recycle() = 0;

    CharT* pos() const noexcept;
    CharT* end() const noexcept;
    std::size_t size() const noexcept;

    void advance_to(CharT* p) noexcept;
    void advance(std::size_t n) noexcept;

    void set_error(std::error_code ec) noexcept;
    void set_error(std::errc e) noexcept;
    void set_encoding_error() noexcept;
    std::error_code get_error() const noexcept;
    bool has_error() const noexcept;

protected:

    output_buffer(CharT* buff_begin, CharT* buff_end) noexcept;
    output_buffer(CharT* buff_begin, std::size_t buff_size) noexcept;

    void set_pos(CharT* p) noexcept;
    void set_end(CharT* e) noexcept;
};

}}} // namespace boost::stringify::v0
``
[table
[[`public: virtual bool recycle() = 0;`]]
[[[variablelist
     [[ Effects]
      [ Consumes the content in the range \u005B ['initial_pos],
       `pos()` \u0029 , where ['initial_pos] is value returned by `pos()`
        before any call to `advance()`  and `advance_to(p)` and after
        the previous call to `recycle()`.]
      [ On success, calls `set_pos(`[~new_pos]`)` and optionally
        `set_end(`[~new_end]`)`.
        On failure, calls `set_error(`[~some_error]`)`.  ]]
     [[ Return value]
      [ `true` on success and `false` otherwise.]]
     [[ Postcondition]
      [ on sucess: size() >= min_buff_size]]]]]]

[table
[[`public: std::size_t size() const noexcept;`]]
[[[variablelist
   [[Return value]
    [`end() - pos()`]]]]]]

[table
[[`public: char_type* pos() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The memory position where the content shall be written]]]]]]

[table
[[`public: char_type* end() const noexcept;`]]
[[[variablelist
   [[Returns]
    [The end of memory position where the content shall be written]]]]]]

[table
[[`public: void advance_to(char_type* p) noexcept;`]]
[[[variablelist
   [[Effect]
      [update pos] ]
   [[Precondition]
      [`pos() <= p && p <= end()`] ]
   [[Postcondition]
      [`pos() == p`]]]]]]

[table
[[`public: void advance(std::size_t n) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`pos() + n <= end()`] ]
  [[Effect]
     [same as `advance(pos() + n)`]]]]]]

[table
[[`public: void set_error(std::error_code ec) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`has_error() == true`]]]]]]
     
[table
[[`public: void set_error(std::errc e) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::make_error_code(e))`]]]]]]
    
[table
[[`public: void set_encoding_error() noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `set_error(std::errc::illegal_byte_sequence)`]]]]]]

[table
[[`public: std::error_code get_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [The value passed to `set_error` the first time it was called]]]]]]

[table
[[`public: bool has_error() const noexcept;`]]
[[[variablelist
  [[Return value]
     [Whether `set_error` has been called ]]]]]]

[table
[[`protected: void set_pos(char_type* p) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`pos() == p`]]]]]]

[table
[[`protected: void set_end(char_type* e) noexcept;`]]
[[[variablelist
  [[Postcondition]
     [`end() == e`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, char_type* buff_end) noexcept;`]]
[[[variablelist
  [[Precondition]
     [`buff_begin <= buff_end`]]
  [[Postconditions]
     [\u2022 `pos() == buff_begin` ]
     [\u2022 `pos() == buff_end`   ]
     [\u2022 `has_error() == false`]
     [\u2022 `get_error() == std::error_code{}`]]]]]]

[table
[[`protected: output_buffer(char_type* buff_begin, std::size_t buff_size) noexcept;`]]
[[[variablelist
  [[Effect]
     [Calls `output_buffer(buff_begin, buff_begin + buff_size)` ]]]]]]
     








[endsect]