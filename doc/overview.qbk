[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/overview.cpp]

[section Overview]

[warning
This library is not part of the Boost C++ Libraries yet.
It is still in an early stage of development and subject to change without
preserving backwards compatibility.
]


[section A tour of the library]

Most of the code snippets in this documentation use [link output_types `to_string`].
Not the `std::to_string` from the standard library, but one that you can think
as a generalization with variadic arguments.
For example:

[first_example]

The "conventional" input types that are ( or will be ) supported are:

* an integer ( `int`, `long`, `long long`, `unsigned int`, `unsigned long` or `unsigned long long`)
* a string ( a raw string, a `std::basic_string`, `std::basic_string_view` or `boost::basic_string_view`)
* a single character ( with the same type as the output character type, otherwise compilation fails )
* a `bool` ['( to do )]
* a `void*` ['( to do )] 
* a floating point ['( to do )]

There are also the some [link special_input_types.special_input_types "special" input types], wich include [link ranges ranges] and [link joins joins]. But they are covered in another section.

And at last there are the input types that are returned from format functions, which carry format information in addition to the value to be printed.

[#format_functions]
[section Format Functions]

You can see in the previous snippet that this library uses format
functions \u2014 like `hex` \u2014 to specify formatting.
Actually `hex` is just a syntatic sugar. `hex(value)` simply returns
`fmt(value).hex()`. And the return type of `fmt(value)` have format
member functions as those in the table below: 

[table
[[member function] [effect] [input types]]

[
[`operator>(int width)`]
[right adjustment]
[all ( integer, floating point, character, string, `void*`, `bool`) ]
]

[[`operator<(int width)`] [left adjustment] [all]]
[[`operator^(int width)`] [centered adjustment] [all]]
[
[`operator%(int width)`]
[internal adjustment (as in [@http://en.cppreference.com/w/cpp/io/manip/left `std::internal`])]
[integer and floating point]
]
[[`fill(char32_t ch)`][sets the fill character to [~ch]] [all]]
[[`p(int precision)`][sets the precision] [integer and floating point]]
[[`dec()`] [decimal base] [integer and floating point]]
[[`hex()`] [hexadecimal base] [integer and floating point]]
[[`oct()`] [octal base] [integer]]

[
[`showpos(bool b)`]
[if [~b] is `true`, print the positive sign for non-negative numbers (as in [@http://en.cppreference.com/w/cpp/io/manip/showpos `std::showpos`])]
[integer and floating point]
]

[
[`showbase(bool b)`]
[if [~b] is `true`, print the numeric base indication (as in [@http://en.cppreference.com/w/cpp/io/manip/showbase `std::showbase`])]
[integer and floating point]
]
[[`operator+()`][same as `showpos(true)`][integer and floating point]]
[[`operator~()`][same as `showbase(true)`][integer]]
[[`multi(int count)`][print the character [~count] times][character]]

]

The return type of these format member functions
also have some these of format member functions,
so that you can call them in a row. For example:

[format_functions_example]

The additional syntatic sugars are:

[table
[[expression] [equivalent to]]
[[`hex(x)`][`fmt(x).hex()`]]
[[`dec(x)`][`fmt(x).dec()`]]
[[`oct(x)`][`fmt(x).oct()`]]
[[][]]
[[`right(x, width)`][`fmt(x) > width`]]
[[`left(x, width)`][`fmt(x) < width`]]
[[`center(x, width)`][`fmt(x) ^ width`]]
[[`internal(x, width)`][`fmt(x) % width`]]
[[][]]
[[`right(x, width, fill)`]   [`fmt(x).fill(fill) > width`]]
[[`left(x, width, fill)`]    [`fmt(x).fill(fill) < width`]]
[[`center(x, width, fill)`]  [`fmt(x).fill(fill) ^ width`]]
[[`internal(x, width, fill)`][`fmt(x).fill(fill) % width`]]
[[][]]
[[`multi(x, count)`] [`fmt(x).multi(count)`]]
]

[/
[h4 Example]
[formatting_samples]
]
[endsect]
[#usage_syntax]
[section Main usage syntax]

Here is another difference of `to_string` from `std::to_string`:
it's not a function, but an object ( actually a constexpr ).
It has member functions that are invoked as in the
[@https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter
named parameter idiom].

And the same applies the all others /"leading expressions"/:

[/ Railroad diagram generated from the EBNF below, in online generator bottlecaps.de/rr 
 
 syntax ::= 'leading_expression' 
  ( '.reserve( size )' | '.reserve_calc()' | '.facets( facets... )' ) * 
  ( '.as(  assembly_string ) ( arguments... ) ' 
  | '.as(  assembly_string, arguments... ) ' 
  | '( arguments... ) ' ) 
] 

[$../syntax.png]
[footnote This railroad diagram was generated on [@http://bottlecaps.de/rr bottlecaps.de/rr]]

[section Leading expression]

The [*leading expression] is the part of the syntax that varies according to
the output type.

[#output_types]

[/
The "`ec_`" prefix means that an `std::error_code` is returned.
While the other expressions use exceptions.
]

[table
[ []  [Destination type] [Leading expression]]

[ [1] [`std::string`]
  [ [link to_string [*`to_string `]]]]

[ [2] [`std::u16string`]
  [ [link to_u16string [*`to_u16string `]]]]

[ [3] [`std::u32string`]
  [ [link to_u32string [*`to_u32string `]]]]

[ [4] [`std::wstring`]
  [ [link to_wstring [*`to_wstring `]]]]

[ [5] [`std::basic_string <`[~CharT]`, `[~Traits]`, `[~Alloc]`>`]
  [ [link to_basic_string [*`to_basic_string`]]`<`[~CharT]`, `[~Traits]`, `[~Alloc]`>`]]

[ [6] [`std::basic_string <`[~CharT]`, `[~Traits]`, `[~Alloc]`>&`]
  [ [link append [*`append`]]`(`[~destination]`)`]]

[ [7] [`std::basic_string <`[~CharT]`, `[~Traits]`, `[~Alloc]`>&`]
  [ [link assign [*`assign`]]`(`[~destination]`)`]]

[ [8]  [[~CharT]`*`]
  [ [link write_char_ptr_count [*`write`]]`(`[~destination]`, `[~limit]`)`]]

[ [9] [[~CharT]`*`]
  [ [link write_char_ptr_range [*`write`]]`(`[~destination]`, `[~end]`)`]]

[ [10] [[~CharT[size]]]
  [ [link write_char_arr [*`write`]]`(`[~destination]`)`]]

[ [11] [ `FILE*` ( using narrow functions) ]
  [ [link write_FILE [*`write`]]`<`[~CharT]`>(`[~destination]`, `[~count_ptr]`)`]]

[ [12]  [ `FILE*` ( using wide functions) ]
  [ [link wwrite_FILE [*`wwrite`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [13] [ `std::basic_streambuf <`[~CharT]`, `[~Traits]`>&`]
  [ [link write_std_streambuf [*`write`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [14]
  [`std::basic_string <`[~CharT]`, `[~Traits]`, `[~Alloc]`>&`]
  [ [link ec_append [*`ec_append`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [15] [`std::basic_string <`[~CharT]`, `[~Traits]`, `[~Alloc]`>&`]
  [ [link ec_assign [*`ec_assign`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [16]  [[~CharT]`*`]
  [ [link ec_write_char_ptr_count [*`ec_write`]]`(`[~destination]`, `[~limit]`, `[~count_ptr]`)`]]

[ [17] [[~CharT]`*`]
  [ [link ec_write_char_ptr_range [*`ec_write`]]`(`[~destination]`, `[~end]`, `[~count_ptr]`)`]]

[ [18] [[~CharT[size]]]
  [ [link ec_write_char_arr [*`ec_write`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [19] [ `FILE*` ( using narrow functions) ]
  [ [link ec_write_FILE [*`ec_write`]]`<`[~CharT]`>(`[~destination]`, `[~count_ptr]`)`]]

[ [20]  [ `FILE*` ( using wide functions) ]
  [ [link ec_wwrite_FILE [*`ec_wwrite`]]`(`[~destination]`, `[~count_ptr]`)`]]

[ [21] [ `std::basic_streambuf <`[~CharT]`, `[~Traits]`>&`]
  [ [link ec_write_std_streambuf [*`ec_write`]]`(`[~destination]`, `[~count_ptr]`)`]]

]

where:

* [~CharT] can be `char`, `char16_t`, `char32_t` or `wchar_t`
* [~end] is [~CharT]*
* [~limit] is `std::size_t`. It determines the maximum number of characters that can be written, including the termination character.
* [~count_ptr] is optional. The number of successfully written characters will be assigned to [~*count_ptr]. Its type is `std::streamsize*` when [~destination] is `std::basic_streambuf <`[~CharT]`, `[~Traits]`>` and `std::size_t*` otherwise.
* 7) [~Alloc] is optional. If omitted, it is `std::allocator<`[~CharT]`>`
* 7-10) [~Traits] is optional. If omitted, it is `std::char_traits<`[~CharT]`>`
* 11 and 20) [~CharT] is optional. If omitted, it is `char`
* 11, 12, 20 and 21) `std::fflush` is [_not] called
* 14 to 21) Although the error policy is to return `std::error_code`, there is no guarantee that no exception is thrown.

[endsect]

[#syntax_reserve]
[section Reserve]
The following member functions only have effect in some output types ( /leading expressions/ 1 to 7 in [link output_types previous table], or when you create the [link OutputBuffer reserve] method when defining your own output type ). 

* [link dispatcher_reserve `reserve_calc()`] : The necessary amount of characters is calculated and reserved in the destination object.
* [link dispatcher_reserve `reserve(std::size_t size)`] : Reserve `size` characters.

If none of these function is called, then no reservation is done.

[syntax_reserve]

[endsect]
[#assembly_string]
[section Assembly string]

The [link assembly_string_syntax assembly string] is what in other formatting
libraries would be called as the /format string/,
with the difference that it does not specify any formatting:
``
auto s = strf::to_string.as("{} in hexadecimal is {}", x, strf::hex(x));
``
Its main purpose is to enable the use of translation tools like
[@https://en.wikipedia.org/wiki/Gettext gettext]. You can customize
how the library handles parsing errors in the with the
[link asm_string_error `asm_invalid_arg`] enumeration.

[endsect]


[/===========================================]

[include facets.qbk]

[/===========================================]

[endsect] [/syntax]

[section Encoding conversion]

[#tour_encoding_conversion]
Did you notice that the thousand separator is specified as
a `char32_t` instead of `char`? That means you can use any
Unicode code point, as long as it is supported by the
output encoding, which by default is UTF-8 for `char`.
However others character sets are available:

[numpuct__with_alternative_encoding]

It is also possible to specify the encoding of each input
string individually:

[input_string_encoding]

As well as converting string of different character types:

[input_output_different_char_types]

And If you don't want to convert any encoding but just
to sanitize an input string, you can use still the `cv` function,
since it aways imply sanitization, even when the input and output
encodings are the same:

[sani_utf8]

The library provides three options of how handle encoding errors.
The default one is to replace any invalid input sequence by the
[@https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
replacement character "\uFFFD"] (U+FFFD). When the input is UTF-8,
the library follows the practice recommended by the Unicode
Standard.
[footnote
  Search for ['"Best Practices for Using U+FFFD"] in
  [@https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf Chapter 3]
  of Unicode Standard. ]
The second option is to [link encoding_error_ignore omit]
the invalid sequence, and the third one is to [link encoding_error_stop
stop everything] and emit an error, /i.e./, to return an error code
or throw an exception.
You can also choose whether surrogates are
treated as errors or not (as explained [link allow_surrogates here]).

[/
Another cool thing you can do is to print ranges:

[input_range]

And another is to align a group of argument as one:

[join_basic_sample]
]
[/
However, facets here are not limited to localisation.
They have been conceived to customise all sort of things,
like the width calculation method, and encoding error handling.
]

[endsect] [/encoding]
[endsect] [/tour of the library]

[section Why to use Boost.Stringify]


[variablelist


[/
  [Good performance]
  [ It may not be best in all scenarios, but it is good,
    and there is probably some room for optimizations.

    See the [link run_time_benchmarks benchmarks].
  ]
  [[br]]
]

[ [ Extensibility]
  [ Boost.Stringify allows you not only to add input types but also output types.
    Qt users, for instance, might be interested in a `to_string`-equivalent that
    creates a `QString` instead of an `std::string`. Take a look at
    [@../../example/extend_output_toQString.cpp this implementation] to see how
    easy this is. Or perhaps you might want to implement an alternative way
    to write to files based on lower level system functions instead of `fprintf`
    in order to get better performance.

    On the other hand, if your interest is to add a new input type, know that you can
    also provide formatting options for this new type.
    There is at least one that is probably desirable,
    which is alignment (a.k.a. justification). This one is particularly easy to
    implement in Boost.Stringify ( and difficult in others ).
    See the [link ipv4_example examples].

    And sometimes what you want is not exactly adding an input type,
    but to implement some kind of solution that generates textual content,
    like, for example, a converter of binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64].
    If you implement it as an extension of Boost.Stringify, as demonstrated
    [link base64_example here], then it automatically gains support to the
    full range of [link output_types output types] available in the library.
[/
    then the wide
    range of [link output_types output types] provided by the library
    became available

    And sometimes what you want is not exactly adding an entry type
    but to achieve something equivalent to a function that generates
    a textual content. For example, to convert binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64], as demonstrated
    [link base64_example here].
    If your solution is implemented as an extension of Boost.Stringify,
    then it incorporates the wide range of [link output_types output types]
    provided by the library.
]
  ]
  [[br]]
]

[
  [Fits in your error handling policy]
  [
    Some code bases use error codes, while others use exceptions.
    To suits both worlds, the library provides [link output_types
    /leading expressions/] for each kind.

    Also, the user can customise how the library handles
    [link encoding_policy encoding errors] as well as
    [link asm_string_error assembly string errors].
  ]
  [[br]]
]

[ [Internationalization]
  [ It is not because this is a locale-independent library that
    you cannot customize numeric punctuation, since you can do that
    with [link numpunct facets]. And it is actually a good thing
    that don't need to change the global locale to achieve that.

    Also, Boost.Stringify is probably the most suitable library to be used
    with translation tools like [@https://en.wikipedia.org/wiki/Gettext gettext]
    , for the following reasons:

    [variablelist

    [ [Assembly string translation hints]
      [ [/Usually it is not the programmer who do the translations.]
        The [link assembly_string_syntax assembly string syntax] allows you
        to insert comments intended to help the person who translates it.
      ]
    ]

    [ [Formatting decoupled from translation]
      [ Because formatting is not in the assembly string, but in the
        format functions, you can change the formatting without
        changing each translation of the assembly string.
      ]
    ]

    [ [Safety]
      [ You may not like the verbosity of [link format_functions format
        functions], which is a legitime dislike.
        However, you should also dislike the error-proneness of format strings.
        Although mistakes in the formatting string can be
        caught at compile-time in some cases \u2014
        as warnings when using `printf` in some compilers, and
        as compilation errors notably in [@http://fmtlib.net {fmt}]
        \u2014 this doesn't work if the format string is returned by a
        function like [@https://en.wikipedia.org/wiki/Gettext gettext].
        Then `printf` has undefined behaviour,
        and other libraries may throw exceptions which is still not an
        adequate solution. A run-time error is only acceptable
        when it's not the program's fault; otherwise it's a bug.
        Format functions, on the other hand, always give you a compilation error.

        It's true that mistakes can also happen in the assembly string
        but the probability is much lower. Besides, you can
        [link asm_string_error customize] how such errors are handled.
[/
        Besides, a future version of the library will enable you to customise the
        error handling there just [link encoding_error as in encoding conversion].
        So that you can choose one that makes it easier to identify such bugs.
        For example: to replace the erroneous part by a character like
        [@https://en.wiktionary.org/wiki/%EF%BF%BC U+FFFD] when `NDEBUG`
        is defined and to terminate the program otherwise.
        ]
      ]
    ]
    ]
  ]
  [[br]]
]

[ [More accurate width calculation]
  [ All formatting libraries provide width and alignment formatting.
    But they assume that the width of a string is always its size.
``
    // Prints with three pading spaces less than you'd like
    printf("Full name: %80s\n", u8"Frédéric François Chopin");
``
[br]
    [/ That is not adequate when it is in UTF-8 and contains non-ASCII characters.]
    But in Boost.Stringify you can customize, via [link width_calculation facets],
    how the width is calculated. Three options are available:

    [itemized_list
      [ Assume that width is equal to size: This it's how is done in
        the other libraries and is the default option and naturally
        has the best performance]

      [ Width is the number of codepoints]

      [ You provide a function that tells the width of each codepoint.
        After all, there are codepoints whose width is equal to 1 ( the
        [@https://en.wikipedia.org/wiki/En_(typography) /en/ width],
        or /halfwidth/ characters ), others have width  2
        ([@https://en.wikipedia.org/wiki/Em_(typography) /em/ width],
        or /fullwidth/ ) and some have width zero ( like non-printable
        and combining characters ).]]
  ]
  [[br]]
]


[
  [Some capabilities not present in most of the other formatting libraries]
  [
  [itemized_list
    [[link output_types Append to string]]
    [[link syntax_reserve Reserve string capacity]]
    [[link joins Joined input arguments]]
    [[link ranges Range input argument]]
    [[link numpunct Numeric punctuation for octal and hexadecimal]]
    [Easy [link encoding_facets encoding conversion and sanitization]]
    [Support for all character types: `char`, `wchar_t`, `char32_t` and `char16_t`.]
  ]
]
[[br]]
]
]



[endsect]

[section Using it as a static library]

[def __STRINGIFY_CPP__
[@../../build/stringify.cpp build/stringify.cpp]
]

Boost.Stringify is prepared to be used as a header-only library by default. But it can also be used as a static library. That reduces the [link compilation_benchmarks code bloat].
[/
And to build the library, since there is only one source file ( __STRINGIFY_CPP__ ), probably the best way it to just copy this file to your own project, and configure the use the build system of your choice to generate the library file from it.
]
Probably the best way to build the library is to create a project in the build system of your own choice. This should be easy since there is only one source file ( __STRINGIFY_CPP__ ) to compile. The code that uses it as a static library must have the macro `BOOST_STRINGIFY_NOT_HEADER_ONLY` defined.


[endsect]

[endsect] [/Overview]