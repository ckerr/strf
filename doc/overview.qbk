[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/overview.cpp]

[section Overview]

[warning
This library is not part of the Boost C++ Libraries yet.
It is still in an early stage of development and subject to change without
preserving backwards compatibility.
]


[section A brief tutorial]


Most of the code snippets in this documentation use [link output_types `to_string`].
Not the std::to_string from the standard library, but an own `to_string`
which you can consider as a generalisation.
One notable difference is that this `to_string` can take multiple arguments.
Another is that it returns `expected<std::string, std::error_code>` instead of
simply `std::string`. This is also not the same __STD_EXPECTED__ that's under
a proposal to the standard, but it is very close to, and it will eventually be
replaced by it in future releases. Or perhaps by Boost.Outcome, or perhaps by
another approach. Error handling is very prone to debate, you know.

Anyway, let's code:

[first_example]

You can see that [link format_functions format functions] \u2014
like `hex` \u2014 are used to format the arguments.
Among them, operator overload commonly is used
 to make the expression less verbose.
For example, `operator~()` is used to print the base indication,
( the "0x" prefix ) and `operator>(int)` to align to the right
and to set the width. For example:

[format_functions_example]

This library does not use a format string like printf,
[@https://www.boost.org/doc/libs/release/libs/format/ Boost.Format]
and [@http://fmtlib.net {fmt}].
But if you need to apply a translation tool like
[@https://en.wikipedia.org/wiki/Gettext gettext], you can use
what is called here as the [link assembly_string assembly string],
which is very similar, but does not specify formatting:
:
``
auto s = strf::to_string.as("{} in hexadecimal is {}") (x, strf::hex(x));
``
Now you see can another difference of `to_string`: it is not a function
like `std::to_string`, but a function object ( actually it's a constexpr ).
It has member functions that are invoked as in the
[@https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter
named parameter idiom].
One of these functions has remarkable purpose: to receive
[link facets facets objects].
These are not the same as the facets handled by `std::locale`,
though they are, again, analogous.
Remember that this is a locale-independent library.
Things are always printed as in the C-locale, unless
you explicitly specify otherwise, which you do with facets.
For example, to customise numeric punctuation:

[basic_numpuct_example]

However, facets here are not limited to localisation.
They have been conceived to customise all sort of things,
like the width calculation method, and encoding error handling.

Also, this library is not limited to `to_string`. You can, for instance,
append to string, instead of creating one. Or, to write to a `FILE*`,
or to a `std::streambuf&`, or to a `char*`, or to your own output type.
All you need is to replace the `to_string` expression ( which is
referred here as a [link output_types /leading expression/] )
by some other. For example:

[output_FILE]

But before learning further how to use this library,
you may first want to see more reasons of why to choose it over others.

[endsect]

[section Why to use Boost.Stringify]


[variablelist


[/
  [Good performance]
  [ It may not be best in all scenarios, but it is good,
    and there is probably some room for optimizations.

    See the [link run_time_benchmarks benchmarks].
  ]
  [[br]]
]

[
  [Easy encoding conversion and sanitization]
  [
    Input and output character types don't need to be the same in Boost.Stringify:
      [input_output_different_char_types][br]

    And even if the character types are same, the encodings don't have to be:
      [windows_1252_to_utf8][br]

    And even if the encodings are the same, you may be interested in just
    sanitizing the input:
      [sani_utf8][br]

    As you can see, the codepoint U+FFFD ( or '\uFFFD' ) is used to signalise
    erroneous input. This is the default behaviour; you can [link
    encoding_error choose another].
  ]
  [[br]]
]


[ [More accurate width calculation]
  [ All formatting libraries provide width and alignment formatting.
    But they assume that the width of a string is always its size.
    That is not adequate when it is in UTF-8 and contains non-ASCII characters.
    The exception is Boost.Stringify that allows you to choose, via facets,
    how the width is calculated. Three options are available:

    [itemized_list
      [ Assume that width is equal to size: This it's how is done in
        the other libraries and is the default option and naturally
        has the best performance]

      [ Width is number of codepoints]

      [ You provide a function tells the width of each codepoint.
        After all, there are codepoints whose width is equal to 1 ( the
        [@https://en.wikipedia.org/wiki/En_(typography) /en/ width],
        or /halfwidth/ characters ), others have width  2
        ([@https://en.wikipedia.org/wiki/Em_(typography) /em/ width],
        or /fullwidth/ ) and some have width zero ( like non-printable
        and combining characters ).]]

    [link width_calculation This section] explains how to choose.
    The differences in performance are shown in the
    [link width_calculation_benchmarks here].
  ]
  [[br]]
]

[ [ Extensibility]
  [ Boost.Stringify allows you not only to add input types but also output types.
    Qt users, for instance, might be interested in a `to_string`-equivalent that
    creates a `QString` instead of an `std::string`. Take a look at
    [@../../example/extend_output_toQString.cpp this implementation] to see how
    easy this is. Or perhaps you might want to implement an alternative way
    to write to files based on lower level functions instead of `fprintf` in order
    to get better performance.

    On the other hand, if your interest is to add a new input type, know that you can
    also provide formatting options for this new type.
    There is at least one that is probably desirable,
    which is alignment (a.k.a. justification). This one is particularly easy in
    Boost.Stringify. See the [link ipv4_example examples].

    And sometimes what you want is not exactly adding an input type,
    but to implement some kind of solution that generates textual content,
    like, for example, a converter of binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64].
    If you implement it as an extension of Boost.Stringify, as demonstrated
    [link base64_example here], then it automatically gains support to the
    full range of [link output_types output types] available in the library.
[/
    then the wide
    range of [link output_types output types] provided by the library
    became available

    And sometimes what you want is not exactly adding an entry type
    but to achieve something equivalent to a function that generates
    a textual content. For example, to convert binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64], as demonstrated
    [link base64_example here].
    If your solution is implemented as an extension of Boost.Stringify,
    then it incorporates the wide range of [link output_types output types]
    provided by the library.
]
  ]
  [[br]]
]

[
  [Fits in your error handling policy]
  [ Some code bases use error code, while others use exceptions.
    Boost.Stringify uses ( an own implementation of ) __STD_EXPECTED__ to
    suit both worlds. Also, the user can customise how the library handles
    [link encoding_error encoding errors] and (to-do) assembly string errors.
  ]
  [[br]]
]

[ [Internationalization]
  [ It is not because this is a locale-independent library that
    you cannot use numeric punctuation. You can do this with [link
    numpunct facets]. And actually, it's a good thing that
    you don't need to change the global locale to achieve that.    
    
    Also, Boost.Stringify is probably the most suitable library to be used
    with translation tools like [@https://en.wikipedia.org/wiki/Gettext gettext]
    , for the following reasons:

    [variablelist

    [ [Assembly string translation hints]
      [ [/Usually it is not the programmer who do the translations.]
        The [link assembly_string assembly string syntax] allows you to
        insert comments intended to help the person who translates it.        
      ]
    ]

    [ [Formatting decoupled from translation]
      [ Because formatting is not in the assembly string, but in the
        format functions, you can change the formatting without
        changing each translation of the assembly string.
      ]
    ]

    [ [Safety]
      [ You may not like the verbosity of [link format_functions format
        functions], which is a legitime dislike.
        However, you should also dislike the error-proneness of format strings.
        Although mistakes in the formatting string can be
        caught at compile-time in some cases \u2014
        as warnings when using `printf` in some compilers, and
        as compilation errors notably in [@http://fmtlib.net {fmt}]
        \u2014 this doesn't work if the format string is returned by a
        function like [@https://en.wikipedia.org/wiki/Gettext gettext].
        Then `printf` has undefined behaviour,
        and other libraries throw an exception which is still not an
        adequate solution. A run-time error is only acceptable
        when it's not the program's fault; otherwise it's a bug.
        Format functions, on the other hand, always give you a compilation error.
    
        It's true that mistakes can also happen in the [link assembly_string
        assembly string], but the probability is much lower.
        Besides, a future version of the library will enable you to customise the
        error handling there just [link encoding_error as in encoding conversion].
        So that you can choose one that makes it easier to identify such bugs.
        For example: to replace the erroneous part by a character like
        [@https://en.wiktionary.org/wiki/%EF%BF%BC U+FFFD] when `NDEBUG`
        is defined and to terminate the program otherwise.
      ]
    ]
    ]
  ]
  [[br]]
]





[
  [Some capabilities not present in most of the other formatting libraries]
  [
  [itemized_list
    [[link output_types Append to string]]
    [[link syntax_reserve Reserve string capacity]]
    [[link joins Joined input arguments]]
    [[link ranges Range input argument]]
    [[link numpunct Numeric punctuation for octal and hexadecimal]]
    [Support for all character types: `char`, `wchar_t`, `char32_t` and `char16_t`.]
  ]
]
[[br]]
]
]



[endsect]

[section Using it as a static library]

[def __STRINGIFY_CPP__
[@../../build/stringify.cpp build/stringify.cpp]
]

Boost.Stringify is prepared to be used as a header-only library by default. But it can also be used as a static library. That reduces the [link compilation_benchmarks code bloat].
[/
And to build the library, since there is only one source file ( __STRINGIFY_CPP__ ), probably the best way it to just copy this file to your own project, and configure the use the build system of your choice to generate the library file from it.
]
Probably the best way to build the library is to create a project in the build system of your own choice. This should be easy since there is only one source file ( __STRINGIFY_CPP__ ) to compile. The code that uses it as a static library must have the macro `BOOST_STRINGIFY_NOT_HEADER_ONLY` defined.


[endsect]

[endsect] [/Overview]