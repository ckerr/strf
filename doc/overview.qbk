[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/overview.cpp]

[section Overview]

[warning
This library is not part of the Boost C++ Libraries yet.
It is still in an early stage of development and subject to change without
preserving backwards compatibility.
]


[section A tour of the library]

Most of the code snippets in this documentation use [link output_types `to_string`].
Not the std::to_string from the standard library, but one that you can think
as a generalization with variadic arguments.
For example:

[first_example]

You can see that [link format_functions format functions] \u2014
like `hex` \u2014 are used to format the arguments.
Among them, operator overload commonly is used
 to make the expression less verbose.
For example, `operator~()` is used to print the base indication,
( the "0x" prefix ) and `operator>(int)` to align to the right
and to set the width.

[format_functions_example]

There is no format string like in `printf`,
[@https://www.boost.org/doc/libs/release/libs/format/ Boost.Format]
or [@http://fmtlib.net {fmt}].
But in case you need to use a translation tool like
[@https://en.wikipedia.org/wiki/Gettext gettext],
the library provides an alternative syntax with
what is called here as the [link assembly_string assembly string],
which is like format string, but without any formatting.
``
auto s = strf::to_string.as("{} in hexadecimal is {}") (x, strf::hex(x));
``
Now can you see that `to_string` is not a function
like `std::to_string`, but a function object ( actually it's a constexpr ).
It has member functions that are invoked as in the
[@https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Named_Parameter
named parameter idiom].
One of these functions has remarkable purpose: to receive
[link facets facet objects].
These are not the same as the facets handled by `std::locale`,
but they are analogous.
Keep in mind that this is a locale-independent library.
So things are always printed as in the C-locale, unless
you explicitly specify otherwise, which you do with facets.
For example, to customise numeric punctuation:

[basic_numpuct_example]

[#tour_encoding_conversion]
By the way, did you notice that the thousand separator is
a `char32_t` instead of `char`? This means you can use any
Unicode code point, as long as it is supported by the
output encoding, which by default is UTF-8 for `char`.
But others character sets are available:

[numpuct__with_alternative_encoding]

It is also possible to specify the encoding of each input
string individually:

[input_string_encoding]

As well as converting string of different character types:

[input_output_different_char_types]

Of course, errors can happen when you convert encodings.
The library provides three options of how they can be handled.
The default one is to replace any invalid input sequence by the
[@https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
replacement character "\uFFFD"] (U+FFFD). When the input is UTF-8,
the library follows the practice recommended by the Unicode
Standard.
[footnote
  Search for ['"Best Practices for Using U+FFFD"] in
  [@https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf Chapter 3]
  of Unicode Standard. ]
The second possible handling is to omit the invalid sequence,
and the third is to return an error code. You can also choose
whether surrogates are treated as errors or not.

Another cool thing you can do is to print ranges:

[input_range]

And another is to align a group of argument as one:

[join_basic_sample]

[/
However, facets here are not limited to localisation.
They have been conceived to customise all sort of things,
like the width calculation method, and encoding error handling.
]


Of course, this library is not limited to `to_string`. You can, for instance,
append to string, instead of creating one. Or, to write to a `FILE*`,
or to a `std::streambuf&`, or to a `char*`, or to your own output type.
All you need is to replace the `to_string` expression ( which is
referred here as a [link output_types /leading expression/] )
by some other. For example:

[output_FILE]
[/
But before learning further how to use this library,
you may first want to see more reasons of why to choose it over others.
]
[endsect]

[section Why to use Boost.Stringify]


[variablelist


[/
  [Good performance]
  [ It may not be best in all scenarios, but it is good,
    and there is probably some room for optimizations.

    See the [link run_time_benchmarks benchmarks].
  ]
  [[br]]
]

[
  [Easy encoding conversion and sanitization]
  [
    As show in the [link tour_encoding_conversion tour], you can use the library
    to translate from one encoding to another. But even if the input and output
    encodings are the same, you may consider the `cv` function to sanitize the
    input string.

      [sani_utf8][br]

  ]
  [[br]]
]


[ [More accurate width calculation]
  [ All formatting libraries provide width and alignment formatting.
    But they assume that the width of a string is always its size.
    That is not adequate when it is in UTF-8 and contains non-ASCII characters.
    Boost.Stringify allows you to choose, via facets,
    how the width is calculated. Three options are available:

    [itemized_list
      [ Assume that width is equal to size: This it's how is done in
        the other libraries and is the default option and naturally
        has the best performance]

      [ Width is the number of codepoints]

      [ You provide a function that tells the width of each codepoint.
        After all, there are codepoints whose width is equal to 1 ( the
        [@https://en.wikipedia.org/wiki/En_(typography) /en/ width],
        or /halfwidth/ characters ), others have width  2
        ([@https://en.wikipedia.org/wiki/Em_(typography) /em/ width],
        or /fullwidth/ ) and some have width zero ( like non-printable
        and combining characters ).]]

    [link width_calculation This section] explains how to choose.
    The differences in performance are shown
    [link width_calculation_benchmarks here].
  ]
  [[br]]
]

[ [ Extensibility]
  [ Boost.Stringify allows you not only to add input types but also output types.
    Qt users, for instance, might be interested in a `to_string`-equivalent that
    creates a `QString` instead of an `std::string`. Take a look at
    [@../../example/extend_output_toQString.cpp this implementation] to see how
    easy this is. Or perhaps you might want to implement an alternative way
    to write to files based on lower level system functions instead of `fprintf`
    in order to get better performance.

    On the other hand, if your interest is to add a new input type, know that you can
    also provide formatting options for this new type.
    There is at least one that is probably desirable,
    which is alignment (a.k.a. justification). This one is particularly easy to
    implement in Boost.Stringify ( and difficult in others ).
    See the [link ipv4_example examples].

    And sometimes what you want is not exactly adding an input type,
    but to implement some kind of solution that generates textual content,
    like, for example, a converter of binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64].
    If you implement it as an extension of Boost.Stringify, as demonstrated
    [link base64_example here], then it automatically gains support to the
    full range of [link output_types output types] available in the library.
[/
    then the wide
    range of [link output_types output types] provided by the library
    became available

    And sometimes what you want is not exactly adding an entry type
    but to achieve something equivalent to a function that generates
    a textual content. For example, to convert binary data to
    [@https://en.wikipedia.org/wiki/Base64 Base64], as demonstrated
    [link base64_example here].
    If your solution is implemented as an extension of Boost.Stringify,
    then it incorporates the wide range of [link output_types output types]
    provided by the library.
]
  ]
  [[br]]
]

[
  [Fits in your error handling policy]
  [
    Some code bases use error codes, while others use exceptions.
    To suits both worlds, the library provides [link output_types
    /leading expressions/] that use error codes ( and
    are prefixed with "`ec_`") and others that use exceptions.

    [/ To suits both worlds, part of the [link output_types
    /leading expressions/] is based on error code, and
    the other part is based on exceptions.]

    Also, the user can customise how the library handles
    [link encoding_policy encoding errors] and
    [link asm_string_error assembly string errors].
  ]
  [[br]]
]

[ [Internationalization]
  [ It is not because this is a locale-independent library that
    you cannot customize numeric punctuation, since you can do that
    with [link numpunct facets]. And it is actually a good thing
    that don't need to change the global locale to achieve that.

    Also, Boost.Stringify is probably the most suitable library to be used
    with translation tools like [@https://en.wikipedia.org/wiki/Gettext gettext]
    , for the following reasons:

    [variablelist

    [ [Assembly string translation hints]
      [ [/Usually it is not the programmer who do the translations.]
        The [link assembly_string assembly string syntax] allows you to
        insert comments intended to help the person who translates it.
      ]
    ]

    [ [Formatting decoupled from translation]
      [ Because formatting is not in the assembly string, but in the
        format functions, you can change the formatting without
        changing each translation of the assembly string.
      ]
    ]

    [ [Safety]
      [ You may not like the verbosity of [link format_functions format
        functions], which is a legitime dislike.
        However, you should also dislike the error-proneness of format strings.
        Although mistakes in the formatting string can be
        caught at compile-time in some cases \u2014
        as warnings when using `printf` in some compilers, and
        as compilation errors notably in [@http://fmtlib.net {fmt}]
        \u2014 this doesn't work if the format string is returned by a
        function like [@https://en.wikipedia.org/wiki/Gettext gettext].
        Then `printf` has undefined behaviour,
        and other libraries may throw exceptions which is still not an
        adequate solution. A run-time error is only acceptable
        when it's not the program's fault; otherwise it's a bug.
        Format functions, on the other hand, always give you a compilation error.

        It's true that mistakes can also happen in the [link assembly_string
        assembly string], but the probability is much lower.
        Besides, you can [link asm_string_error customize how such errors are handled].
[/
        Besides, a future version of the library will enable you to customise the
        error handling there just [link encoding_error as in encoding conversion].
        So that you can choose one that makes it easier to identify such bugs.
        For example: to replace the erroneous part by a character like
        [@https://en.wiktionary.org/wiki/%EF%BF%BC U+FFFD] when `NDEBUG`
        is defined and to terminate the program otherwise.
        ]
      ]
    ]
    ]
  ]
  [[br]]
]


[
  [Some capabilities not present in most of the other formatting libraries]
  [
  [itemized_list
    [[link output_types Append to string]]
    [[link syntax_reserve Reserve string capacity]]
    [[link joins Joined input arguments]]
    [[link ranges Range input argument]]
    [[link numpunct Numeric punctuation for octal and hexadecimal]]
    [Support for all character types: `char`, `wchar_t`, `char32_t` and `char16_t`.]
  ]
]
[[br]]
]
]



[endsect]

[section Using it as a static library]

[def __STRINGIFY_CPP__
[@../../build/stringify.cpp build/stringify.cpp]
]

Boost.Stringify is prepared to be used as a header-only library by default. But it can also be used as a static library. That reduces the [link compilation_benchmarks code bloat].
[/
And to build the library, since there is only one source file ( __STRINGIFY_CPP__ ), probably the best way it to just copy this file to your own project, and configure the use the build system of your choice to generate the library file from it.
]
Probably the best way to build the library is to create a project in the build system of your own choice. This should be easy since there is only one source file ( __STRINGIFY_CPP__ ) to compile. The code that uses it as a static library must have the macro `BOOST_STRINGIFY_NOT_HEADER_ONLY` defined.


[endsect]

[endsect] [/Overview]