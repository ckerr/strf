[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[section Overview]

[warning
This library is not part of the Boost C++ Libraries yet.
It is still in an early stage of development and subject to change without
preserving backwards compatibility.
]

Boost.Stringify is a locale-independent format library with some unique features.


[h3 Why ( and why not ) to use Boost.Stringify]

[h4 Pros]

* It supports many [link output_types.output_types destination types]
* It is highly extensible.
    * When adding [link extend_input.extend_input new input types], you can create your own new format options, as well as new [link section_facets facet categories]
    * You can also add [link extend_output.extend_output new destination types]. If you work, for instance, with some non standard string type ( as is usual in C++ ), you will probably find it easy to extend Boost.Stringify to write into this string type.
* Supports [link encoding_conversion.encoding_conversion Encoding conversion].
* It's UTF-8 and UTF-16 friendly:
    * You can customize [link facet_width_calculation.width_calculation how the width is calculated], choosing more accurate methods than just assuming that width equals to length.
    * The [link format_functions fill] and [link numpunct punctuation] characters are `char32_t`, which gives you options beyond the ASCII table when the destination character type is `char`.
* Supports all character types: `char`, `wchar_t`, `char32_t` and `char16_t`.
* Provides some interesting [link special_input_types.special_input_types special input types].

[h4 Cons]

* [link benchmarks.benchmarks.compilation_performance Code bloat]
* Requires a C++14 compiler
* No support for date and time input (yet)
* Tends to be more verbose than libraries based on format string ( like printf )


[h3 As static library or header-only]

[def __STRINGIFY_CPP__
[@../../build/stringify.cpp build/stringify.cpp]
]

By default Boost.Stringify is prepared to be used as a header-only library. But it can also be used as a static library. This reduces the [link benchmarks.benchmarks.compilation_performance code bloat].

[/
And in order to build the library, since there is only one source file ( __STRINGIFY_CPP__ ), probably the best way it to just copy this file to your own project, and configure the use the build system of your choice to generate the library file from it.
]

Probably the best way build the library is to create a project in the build system of your own choice to do this. This should be easy, since there is only one source file ( __STRINGIFY_CPP__ ) to compile

Also, the code that uses it as static library must have the macro  `BOOST_STRINGIFY_NOT_HEADER_ONLY` defined.


[endsect]

