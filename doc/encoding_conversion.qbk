[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/encoding_conversion.cpp]
[#encoding_facets]
[section:encoding_conversion Encoding conversion]

By default, the encoding for `char` is UTF-8 and for `wchar_t` is UTF-16 if `sizeof(wchar_t) == 2`, and UTF-32 if `sizeof(wchar_t) == 4`. However it will be possible to select alternatives encodings. The functions below provide the currently supported encodings:

[table:encodings
[ [function] [description] ]

[
[`encoding<char> utf8();`]
[The UTF-8 encoding. This is the default for `char`.]
]

[/
[`encoding<char> mutf8();`]
[The [@https://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8 Modified UTF-8] encoding]
]

[/
[`encoding<char> cesu8(); // TODO `]
[The [@https://en.wikipedia.org/wiki/CESU-8 CESU-8] encoding. /(not implemented yet)/]
]

[
[`encoding<char> iso_8859_1();`]
[The [@https://en.wikipedia.org/wiki/ISO/IEC_8859-1 ISO/IEC 8859-1] encoding]
]

[
[`encoding<char> iso_8859_15();`]
[The [@https://en.wikipedia.org/wiki/ISO/IEC_8859-15 ISO/IEC 8859-15] encoding]
]

[
[`encoding<char> windows_1252();`]
[The [@https://en.wikipedia.org/wiki/Windows-1252 Windows-1252] encoding]
]

[/
[`encoding<char> ascii();`]
[Pure ASCII. Any character greater than `0xf9` is treated as error]
]


[
[`encoding<char16_t> utf16();`]
[The UTF-16 encoding.]
]

[
[`encoding<char32_t> utf32();`]
[The UTF-32 encoding.]
]

[
[`encoding<wchar_t> utfw();`]
[This is the default ( actually the only currently available ) encoding for `wchar_t`. [br] It is UTF-16 if `sizeof(wchar_t) == 2` and UTF-32 if  `sizeof(wchar_t) == 4`.]
]

]

[section:encoding_class The `encoding` class template]

The class `encoding<`[~CharT]`>` basically just stores an encoding identification. Its objects are small and fast to copy and to compare.

```
namespace boost {
namespace stringify {
inline namespace v0 {

template <typename CharT> struct encoding_category;

template <typename CharT> class encoding {
public:

    using category = encoding_category<CharT>;

    constexpr encoding(const encoding&);
    constexpr encoding& operator=(const encoding&);
    constexpr bool operator==(encoding> other) const;
    constexpr bool operator!=(encoding other) const;
};

} } } // namespace boost::stringify::v0
```
The `encoding<`[~CharT]`>` is also a facet that specify the encoding associated to character type [~CharT], both for input and output.
You can also use it to apply an encoding to a single input string with `cv` function. 

[arg_encoding]

[endsect]

[#encoding_policy]
[section The `encoding_policy` facet]

```
namespace boost {
namespace stringify {
inline namespace v0 {

enum class error_handling
{
    replace, stop, ignore
};

class encoding_policy
{
public:

    constexpr encoding_policy
        ( error_handling err_hdl
        , bool allow_surr = false );
        
    constexpr encoding_policy(const encoding_policy&);
    constexpr encoding_policy& operator=(const encoding_policy& other);
    constexpr bool operator==(const encoding_policy& other) const;

    constexpr bool allow_surr() const;
    constexpr stringify::v0::error_handling err_hdl() const;
};

} } } // namespace boost::stringify::v0
```
The `error_handling` enumeration specifies how invalid sequences are
handled:

[itemized_list

[[#encoding_error_replace] [*`error_handling::replace`:] This is the default.
Each invalid sequence is replace by the
[@https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character
replacement character "\uFFFD"] (U+FFFD). When the input is UTF-8,
the library follows the practice recommended by the Unicode
Standard.
[footnote
  Search for ['"Best Practices for Using U+FFFD"] in
  [@https://www.unicode.org/versions/Unicode10.0.0/ch03.pdf Chapter 3]
  of Unicode Standard. ]
[error_handling_ignore]
]


[[#encoding_error_stop] [*`error_handling::stop`:] Stop the transcoding and emit
`std::make_error_code(std::errc::illegal_byte_sequence)`.
[error_handling_stop]
]


[[#encoding_error_ignore] [*`error_handling::ignore`:] The illegal byte sequence is removed
from the transcoding.
[error_handling_ignore]
]

]

[/
You may have noticed that there is no support for the [@https://en.wikipedia.org/wiki/UTF-8#WTF-8 WTF-8] encoding. WTF-8 is a variant of UTF-8 where surrogates code points are allowed. If WTF-8 were supported, then we would also need an analogous equivalent of UTF-16 and UTF-32. So instead, the `allow_surrogates` facet was created to specify whether the surrogates are allowed
]
[#allow_surrogates]
The flag `allow_surr` specifies wheter the surrogates are allowed.
In UTF-16 this means to allow unpaired surrogates (high surrogate not followed by a low surrogate, or a low surrogate not proceeded by a high surrogate). In ASCII and ASCII extensions this facets has no effect.

[allow_surrogates]

[endsect]

[endsect]