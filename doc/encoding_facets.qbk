[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/custom_encoding_error_handling.cpp]

[#encoder_facet]

[section:encoders Encoding facets]

This are the facets used to encode the output. By using a different facet instead of the default you can specify which is the output encoding, as well as how invalid codepoints are handled.

Here the facet category is an insntace of the `encoding_category` template;

``
template <typename CharT> struct encoding_category;
``
The table below lists the facets the library corrently provides. You are not limited to those, since you can implement your own facets.

[table

[[facet category] [facets this library provides] [default facet object]]

[
[`encoding_category<char>`]
[
  [link encoding_facets.encoders.u8encoder `u8encoder`] class template
]
[
  An object identical as the return of
  [link encoding_facets.encoders.u8encoder.make_u8encoder `make_u8encoder`]`()`
]
]

[
[`encoding_category<char16_t>`]
[  [link encoding_facets.encoders.u16encoder `u16encoder`] class template]
[
  An object identical as the return of
  [link encoding_facets.encoders.u16encoder.make_u16encoder `make_u16encoder`]`<char16_t>()`
]
]

[
[`encoding_category<char32_t>`]
[[link encoding_facets.encoders.u32encoder `u32encoder`]`<char32_t>` class]
[An instance of [link encoding_facets.encoders.u32encoder `u32encoder`]`<char32_t>]
]

[
[`encoding_category<wchar_t>`]
[
  If `sizeof(wchar_t) == 2` :
  [link encoding_facets.encoders.u16encoder `u16encoder`] class template
  [br]
  If `sizeof(wchar_t) == 4` :
  [link encoding_facets.encoders.u32encoder `u32encoder`]`<wchar_t>` class
]
[
  If `sizeof(wchar_t) == 2` : an object identical as the return of
  [link encoding_facets.encoders.u16encoder.make_u16encoder `make_u16encoder`]`<wchar_t>()`
  [br]
  If `sizeof(wchar_t) == 4` : an instance of
  [link encoding_facets.encoders.u32encoder `u32encoder`]`<wchar_t>`
]
]
]

[section Requirements of the `encoder_category<`[~CharT]`>` category]
A facet of the `encoder_category<`[~CharT]`>` category shall:

* derives from `encoder<CharT>` class
* be non-abstract and [@http://en.cppreference.com/w/cpp/concept/CopyConstructible CopyConstructible] ( as in all facet categories )

[h4 The [^encoder] class template]
``
template <typename CharT> class encoder
{
public:

    using category = encoder_category<CharT>;

    virtual ~encoder();

    virtual std::size_t length(char32_t ch) const = 0;

    virtual bool encode
        ( output_writer<CharT>& destination
        , std::size_t count
        , char32_t ch
        ) const = 0;

};
``

* The [*`encode`] member function shall write the code point `ch` into `destination` `count` times. It shall return `true` on success. Returning `false` will prevent subsequent calls.

* The [*`length`] member function shall return how many instance of `CharT` are needed to represent code point `ch`.

[endsect]


[section:u8encoder The `u8encoder` class template]

``
template <typename F>
// requires requires(F func, output_writer<char>& out, std::size_t count)
// {
//    { func(out, count) } -> bool;
// }
class u8encoder: public encoder<char>
{

public:

    u8encoder(F error_handling_function, bool wtf8 = false);

    u8encoder(const u8encoder& other);

    u8encoder(u8encoder&& other);

    ~u8encoder();

    u8encoder &  wtf8(bool _ = true) &;
    u8encoder && wtf8(bool _ = true) &&;
    u8encoder    wtf8(bool _ = true) const &;

    std::size_t length(char32_t ch) const noexcept override;

    bool encode
        ( output_writer<char>& destination
        , std::size_t count
        , char32_t ch
        ) const override;
};

``
`u8encoder<F>::encode(destination, count, ch)` writes `count` times into `destination` the code point `ch`, if it is a valid code point. Otherwise it calls and returns `error_handling_function(destination, count)`. It return `false` on the ocurrence of a such failure that there is not point in writing anything else.

The `wtf8` flag determinates wheter the surrogates halves ( the code points in the range U+D800 to U+DFFF ) are considered valid ( if it's `true` then they valid ). The code points greater than U+10FFFF are aways considered invalid. 


[h4:make_u8encoder Helper functions]
[#put_utf8_replacement_char]
``
bool put_utf8_replacement_char
    ( output_writer<char>& destination
    , std::size_t count
    )
{
    // writes u8"\uFFFE" count times
    return destination.repeat(count, '\xEF', '\xBF', '\xBD'); 
}

auto make_u8encoder(bool wtf8 = false)
{
    using F = bool(*)(output_writer<char>&, std::size_t>;
    return u8encoder<F>{put_utf8_replacement_char, wtf8};
}
``
``
template <typename F>
auto make_u8encoder(F error_handling_func, bool wtf8 = false)
{
    return u8encoder<F>{error_handling_func, wtf8};
}
``
[endsect]

[section:u16encoder The `u16encoder` class template]

``
template <typename CharT, typename F>
// requires requires(F func, output_writer<CharT>& out, std::size_t count)
// {
//    { func(out, count) } -> bool;
// }
class u16encoder: public encoder<CharT>
{

public:

    u16encoder(F error_handling_function, bool tolerate_surrogates = false);

    u16encoder(const u16encoder& cp);

    u16encoder(u16encoder&& mv);

    ~u16encoder();

    u16encoder &  tolerate_surrogates(bool b = true) &;
    u16encoder && tolerate_surrogates(bool b = true) &&;
    u16encoder    tolerate_surrogates(bool b = true) const &;

    std::size_t length(char32_t ch) const noexcept override;

    bool encode
        ( output_writer<CharT>& destination
        , std::size_t count
        , char32_t ch
        ) const override;

};
``
`u16encoder<F>::encode(destination, count, ch)`  writes `count` times into `destination` the code point `ch`, if it is a valid code point. Otherwise it calls and returns `error_handling_function(destination, count)`. `false` is returned on the ocurrence of a such failure that there is not point in writing anything else into `destination`.

If the the flag `tolerate_surrogates` is `true`, then the code points in the range U+D800 to U+DFFF (the surrogates halves) are allowed, and are translated just as the other code points below U+10000. The code points greater than U+10FFFF are aways considered invalid.

[h4:make_u16encoder The `make_u16encoder` helper functions]
[#put_utf16_replacement_char]
``
template <typename CharT>
bool put_utf16_replacement_char
    ( output_writer<CharT>& destination
    , std::size_t count
    )
{
    return destination.repeat(count, 0xFFFE); 
}

template <typename CharT>
auto make_u16encoder(bool tolerate_surrogates = false)
{
    using F = bool(*)(output_writer<CharT>&, std::size_t>;
    return u16encoder<CharT, F>{put_utf16_replacement_char, tolerate_surrogates};
}
``
``
template <typename CharT, typename F>
auto make_u16encoder(F error_handling_func, bool tolerate_surrogates = false)
{
    return u8encoder<F>{error_handling_func, tolerate_surrogates};
}
``

[h4 The default UTF-16 encoder]

By default, UTF-16 is encoded using `u16encoder` with the `tolerate_surrogates` flag set to `false` and the `error_handling_function` equal to `put_utf16_replacement_char`.

[endsect]

[section Customizing the encoder error handling function ( for `u8encoder` and `u16encoder`) ]

[/
The function object that handles the invalid code point in `u8encoder` and `u16encoder` receives two paramenters:
]

Both `u8encoder` and `u16encoder` receive in their constructors a function object [~`error_handling_function`] that handles invalid code points. This function receives two parameters:

* the [~destination], whose type is [link output_writer `output_writer`]`<CharT>&`
* the [~count], whose type is std::size_t. This is the number of times the failed code point was meant to be written if it was valid.

Its return is of type  `bool` and tells whether the writing process shall continue after this failure.

There are basically three kinds of error handler function that you can implement. If you want to: 

* replace the invalid code point by some other character, then write this character into [~destination] using the member functions of [link output_writer `output_writer`]. Take [link put_utf8_replacement_char put_utf8_replacement_char] and [link put_utf16_replacement_char put_utf16_replacement_char] as examples.
* cause an error code, then call `destination.set_error(`[~code]`)` and then return `false`.
* throw an exception, then, well, just throw it.

[caution The error handler function must not write into `destination` more than `(4 * `[~count]`)` bytes ( or `(4 * `[~count]`)` instances of `char` in the case of `u8encoder` or `(2 * `[~count]`)` instances of [~CharT] in the case of `u16encoder`). That's because `u8encoder::length(ch)` and `u16encoder::lenght(ch)` return `4` and `2` respectively when `ch` is an invalid code point. And this value in turn is used to calculate the total length to be passed to the [link OutputWriter_reserve `reserve`] function]

[h4 Example]

[custom_encoding_error_handling]

[endsect]

[section:u32encoder The `u32encoder` class template]

This class template exists and is mentioned here just for completeness. What it does is to convert UTF-32 into, well, UTF-32. It has to exists in order to avoid compilation/linkage error, since every category needs a default facet object.


``
template <typename CharT> class u32encoder: public encoder<CharT>
{
public:

    std::size_t length(char32_t) const noexcept override;

    bool encode
        ( stringify::v0::output_writer<CharT>& destination
        , std::size_t count
        , char32_t ch
        ) const override;
};
``

[endsect]
[endsect]