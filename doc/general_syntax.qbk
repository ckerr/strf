[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/trivial_sample.cpp]
[import ../example/v0/syntax_samples.cpp]
[section Syntax]

[/ Railroad diagram generated from the EBNF below, in online generator bottlecaps.de/rr

  syntax ::= 'leading_expression'
  ( '.no_reserve()' | '.reserve( size )' | '.reserve_auto()' | '.facets( facets... )' ) *
  ( '(  assembly_string )' ? (' .error_code( arguments... ) ' | ' .exception( arguments... ) '))
]

[#syntax_diagram]

[$../syntax.png]
[footnote This railroad diagram was generated on [@http://bottlecaps.de/rr bottlecaps.de/rr]]

The ['[*leading expression]] is the part of the expression the varies according to the output type, as show in [link output_types.output_types this table].

The [link section_assembly_string ['[*assembly string]]] is analogous to what in others format libraries is called as the /format string/, except that it does not format any of the arguments. Formatting is specified instead with [link format_functions format functions].

Example:

[trivial_sample]

In order to reduce code bloat and increase performance, it is recommended to use the assembly string if it reduces the number of arguments.

[h3 Arguments]

The "conventional" input types that are ( or will be ) supported:

* an integer ( `int, long, long long, unsigned int, unsigned long or unsigned long long`)
* a string ( a raw string or a `std::basic_string` or `std::basic_string_view`)
* a single character
* a `bool` ['( todo )]
* a `void*` ['( todo )]
* a floating point ['( todo )]

In addition to those, there are also some [link special_input_types.special_input_types "special" input types], that are explained in another section.

As shown in the diagram, there two different ways you can inject the arguments:

[#syntax_args_form2]
[variablelist
[[ \u2022 /leading_expression/  \u00b7\u00b7\u00b7 ` .error_code(`[~args ...]`)`]
 [This expression call and returns the return the [link OutputWriterConcept `finish_error_code()`] member function of the writer object. This varies according to the leading expression as described [link ReturnTypes here], but should be `std::error_code` or some type that contains an `std::error_code` ( like __STD_EXPECTED__`<some_type, std::error_code>` )]
]
]

[#syntax_args_form3]
[variablelist
[[ \u2022 /leading_expression/  \u00b7\u00b7\u00b7 ` .exception(`[~args ...]`)`]
 [This form use exceptions instead of error codes. It calls and returns the return of [link OutputWriterConcept `finish_exception()`] instead of `finish()`. So instead of returning an `std::error_code` ( or an object that contains an `std::error_code` ) it throws an exception created from such `std::error_code`, if such `std::error_code` is not empty. The return types are listed [link ReturnTypes_throw here].
]

]
]

[#syntax_reserve]
[h3 Reserving output size]

The following member functions only have effect in some output types ( cases 1 to 7 in [link output_types.output_types this table], or when you create the [link OutputWriterConcept reserve] method when defining your own output type ). 

* [*`reserve_auto()`] : The necessary amount of characters is calculated and reserved in the destination object. This is the default.
* [*`reserve(std::size_t size)`] : The calculation is skipped and the specified `size` is used instead.
* [*`no_reserve()`] : No reservation is done.

[syntax_reserve]


[endsect]

