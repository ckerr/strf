[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/facets.cpp]

[#section_facets]
[section Facets]

The facets are injected with the `with` member function:

[trivial_facets_sample]

It is possible to constrain a facet to only apply to certain input types: 

[facet_filters]

The order of the facets matters. In the presence of two or more facets of the same category that apply to the same input type, the later wins.

[facet_overriding]

Occasionaly you may want to reuse a certain combination of facets several times. In order to avoid  retyping it again and again, you can store it into a /ftuple/ ( a tuple of facets ).

[basic_ftuple_sample]

And you can create an ftuple from others ftuples:

[ftuple_of_ftuple]


[/
ftuples may resemble `std::locale` a little, but there are two differences:
 (1) `ftuple` class template solve most things at compilation time in order to gain performance, and (2) facets here are not necessarily related to localization.
]


[/

Each of the following sub-sections describe a facet category.

Facets are policy classes that comply the [*/Requirements/] described bellow. `F` represents the class name, and `f` represents an instance of `F`. In addition to the items listed in /Requirements/, all facets must have:

* A [*copy constructor]. And it should be a fast, because facets are passed by copy in many operations - especially during the construction of an ftuple. Fortunately, this should not be difficult since there is no need to provide any non-const member function. Hence if you need to implement a facet that needs to use some large complex data structure, you can just ensure that such structure never changes and then your facet can just hold a shared_ptr to it, and copy just that shared_ptr in its copy contructor, instead of the whole structure.

* The [*`category`] member type. [/, which identifies the category.]

]

[/
If ever you implement an facet, it's important to provide a fast copy constructor, because facets are passed by copy in many operations - especially during the construction of an ftuple. Fortunately, this should not be difficult since there is no need to provide any non-const member function. So if need to implement a facet that needs to use some large complex data structure, you can just ensure that such structure never changes and then your facet can just hold a shared_ptr to it, and copy just that shared_ptr in its copy contructor, instead of the whole structure.
]



[/

Facets are policy classes. They are not based on inheritance like the facets used in std::locale. As a result, a facet may be an empty type, i.e., with size equal to 1 byte. And so it is even possible that an ftuple that contains several facets be also an empty type.


You don't need to pay attention to the policy requirements, unless you need to implement a new facet because none of the Boost.Stringify

providing the purpose, requirements, some expressions 


The following sub-sections describe the policy requirements of each facet category. But you usually only need to know them if you extend Boost.Stringify to add support to a new input type.

Because Boost.Stringify already provides expressions ( which may be functions, varaible templates, constexpr, etc ) that create facets object for most situations. Some of them instantiate empty types, usually paried with another that creates the equivalent as an non empty type, whose value can de choosed at execution time. For instance ...

You will note something common in all facet policies: the member type [^category] and the member class template ...
This is the basic requimerent for all facets.

]




[endsect]

