[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/v0/facets.cpp]

[#section_facets]
[section Facets]

While [link format_functions format functions] aim to customize some things,
others customizations are handled by /facets/.
Every /facet/ belongs to some /facet category/. 


[table
[[facet category][what it controls][where is used]]

[
[[link width_calculation `width_calculation_category`]]
[how the width is calculated]
[[link joins joins] and all conventional types]
]

[
[[link numpunct `numpunct_category<10>`]]
[numeric punctuation for decimal base]
[integers and floating points numbers]
]


[
[[link numpunct `numpunct_category<16>`]]
[numeric punctuation for hexadecimal base]
[integers and floating points numbers]
]

[
[[link numpunct `numpunct_category<8>`]]
[numeric punctuation for octal base]
[integers numbers]
]

]


Each facet category corresponds to a concept, /i.e./ a set of requirements that a class must satisfy. A class that satisfy such requirements is a facet of such facet category. Hence, facets are policy classes. And for each facet category there is a representative class, which is not a facet and whose name, by convention, is the name of the category. This class always have static member function named `get_default` which has no parameter and returns a reference to a constant object, whose type is a facet of this category. Also a facet must have member type named `category` which is an alias to the representative class of its category.

For example, the `width_calculator` class is a facet:

``
namespace boost { namespace stringify { inline namespace v0 {

struct width_calculator_category;

class width_calculator
{
public:
    using category = boost::stringify::v0::width_calculator_category;
    // ...
};


struct width_calculator_category
{
    static const width_calculator& get_default();
};


}}}
``
In order to use a facet object, you pass it to the [link syntax_diagram `facets`] function:

[basic_facet_sample]

[#constrained_facets]
[h4 Constrained facets]

Using the `constrain` function template you can instantiate /constrained facet/, which it a facet that only apply to certain input types.

``
template <template <class> class Filter, typename Facet>
auto constrain(const Facet& facet) -> /*implementation defined*/ ;
``

The first template parameter of `constrain` ( named here as `Filter` ) is a template type that must follow the same design of `std::is_signed`, `std::is_pointer` and those others metafunctions defined in <type_traits>. It must contains a `value` member constant conversible to bool that tells wheter a given input type shall be under the influence of the given facet:

[constrained_facet_sample]

Some type traits are provided to be used in the `constrain` function template.

[table
[[trait] [description]]
[[`is_int_number`] [matches `short`, `int`, `long`, `long long` and the corresponding unsigned types]]
[[`is_char`]       [matches `char`, `wchar_t`, `char16_t`, and `char32_t`]]
[[`is_string`]     [matches strings inputs]]
]

[h4 Facets overriding]

You can pass several facets in one call, as well as call `.facets()` several times. Calling `.facets(a, b, c)` is equivalent to `.facets(a).facets(b).facets(c)`. If two facets objects of the same category apply to the same input type, then the later overrides the first.

[facets_overriding]

[#ftuple]
[h4 The `ftuple` class template]
The purpose of the `ftuple` class template is to group several facets objects.
``
template <typename ... Facets>
class ftuple
{
public:

    ftuple(const Facets & ...);
    ftuple(const ftuple& );
    ftuple(ftuple&& );

    template <typename FacetCategory, typename InputType>
    const auto& get_facet() const  {  /* ... */  }
};

``
``
template <typename ... Facets>
ftuple<Facets> make_ftuple(const Facets& ... facets)
{
    return ftuple<Facets>{facets ...};
}
``
``
template <typename FacetCategory, typename InputType, typename ... Facets>
constexpr const auto& get_facet(const ftuple<Facets...>& ft)
{
    return ft.template get_facet<FacetCategory, InputType>();
}
``
Passing an ftuple to the `.facets` function is equivalent to pass all the facet objects it contains ( internally they would be grouped in a ftuple anyway ).

[/
The purpose of the `ftuple` class template is similar to that of `std::locale`: to group several facets objects. The difference is that the facets here are not necessarily related to localization. And also that `ftuple` solves most of things at compilation time, very much like `std::tuple`. Passing an ftuple to the `.facets` function is equivalent to pass all the facet objects it contains ( internally they would be grouped in a ftuple anyway ).
]
[/
An ftuple can be created with the `make_ftuple` function template.
]
[/
You can use an `ftuple` in order to group several facets objects, so that you can reuse without retyping them again and again.
]
[/
You can store many facets objects into a /ftuple/ (a tuple of facets), so that you can reuse such group of facets without needing to retype them all again and again.
]


[table Equivalences
[ [expression] [equivalent expression] ]
[
[`make_ftuple(a1, a2, ... , make_ftuple(b1, b2, ...), c1, c2, ...)`]
[`make_ftuple(a1, a2, ... , b1, b2, ... , c1, c2, ...)`]
]
[
[[~leading_expression]` .facets( make_ftuple(a1, a2, ...) )` ]
[[~leading_expression]` .facets(a1, a2, ...) ` ]
]
[
[[~leading_expression]` .facets(a1, a2, ... , b1, b2, ...)` ]
[[~leading_expression]` .facets(a1, a2, ...) .facets(b1, b2, ...) ` ]
]
]


You will probably only use the `get_facet` function template if you ever extend the library for a [link extend_input.extend_input new input type]. It returns a reference to a constant facet object inside the `ftuple` that belongs to the given `FacetCategory` and that can be applied to `InputType` ( since facets can be [link constrained_facets constrained] to apply to only certain input types ). If the `ftuple` does not contain such facet, then `FacetCategory::get_default()` is returned.

[note 
Passing a facet object to `make_ftuple` or to `constrain` creates a [_copy] of it into the `ftuple` or into the constrained facet object. In order to avoid copying, you can pass instead a [@http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper `std::reference_wrapper`]. However all facets are designed to provide a fast copy. The [link numpunct str_grouping] is probably the slowest one, since it contains internally a `std::string`.
]



[get_facet_sample]


[endsect]

