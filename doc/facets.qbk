[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/facets.cpp]

[#facets]
[section:facets Facets]

Every /facet/ belongs to some /facet category/. 

[table
[[facet category][what it controls][constrainable][where is used]]

[
[[link width_calculation `width_calculation_category`]]
[how the width is calculated]
[yes]
[[link joins joins] and all conventional types]
]

[
[[link numpunct `numpunct_category<10>`]]
[numeric punctuation for decimal base]
[yes]
[integers and floating points numbers]
]


[
[[link numpunct `numpunct_category<16>`]]
[numeric punctuation for hexadecimal base]
[yes]
[integers and floating points numbers]
]

[
[[link numpunct `numpunct_category<8>`]]
[numeric punctuation for octal base]
[yes]
[integers numbers]
]

[
[[link encoding_conversion.encoding_conversion.encodings encoding]]
[encoding]
[no]
[]
]

[
[[link encoding_error encoding_error]]
[encoding error handling]
[no]
[]
]

[
[[link encoding_conversion.encoding_conversion.allow_surrogates allow_surrogates]]
[tells whether surrogate code points are allowed]
[no]
[]
]


]


Each facet category corresponds to a concept, /i.e./ a set of requirements that a class must satisfy. A class that satisfies such requirements is a facet of such facet category. Hence, facets are policy classes. Also, for each facet category, there is a representative class, which is not a facet and whose name, by convention, is the name of the category. This class always have a static member function named `get_default` which has no parameter and returns a reference to a constant object, whose type is a facet of this category. Also, a facet must have member type named `category` which is an alias to the representative class of its category.

For example, the `width_calculator` class is a facet:

``
namespace boost { namespace stringify { inline namespace v0 {

struct width_calculator_category;

class width_calculator
{
public:
    using category = boost::stringify::v0::width_calculator_category;
    // ...
};


struct width_calculator_category
{
    static const width_calculator& get_default();
};


}}}
``
To use a facet object, you pass it to the [link syntax_diagram `facets`] function:

[basic_facet_sample]

[#constrained_facets]
[h4 Constrained facets]

With the `constrain` function template you can instantiate /constrained facet/, which is a facet that only applies to certain input types.

``
template <template <class> class Filter, typename Facet>
auto constrain(const Facet& facet) -> /*implementation defined*/ ;
``

The first template parameter of `constrain` ( named here as `Filter` ) is a template type that must follow the same design of `std::is_signed`, `std::is_pointer` and those others metafunctions defined in <type_traits>. It must contain a `value` member constant convertible to bool that tells whether a given input type shall be under the influence of the given facet:

[constrained_facet_sample]

The library provides some type trait of this kind:

[table
[[trait] [description]]
[[`is_int_number`] [matches `short`, `int`, `long`, `long long` and the corresponding unsigned types]]
[[`is_char`]       [matches `char`, `wchar_t`, `char16_t`, and `char32_t`]]
[[`is_string`]     [matches strings inputs]]
]

[h4 Overriding facets]

You can pass several facets in one call, as well as call `.facets()` several times. Calling `.facets(a, b, c)` is equivalent to `.facets(a).facets(b).facets(c)`. If two facets objects of the same category apply to the same input type, then the latter overrides the first.

[facets_overriding]

[#facets_pack]
[h4 The `facets_pack` class template]
The purpose of the `facets_pack` class template is to group several facets objects.
``
template <typename ... Facets>
class facets_pack
{
public:

    facets_pack(const Facets & ...);
    facets_pack(const facets_pack& );
    facets_pack(facets_pack&& );

    template <typename FacetCategory, typename InputType>
    const auto& get_facet() const  {  /* ... */  }
};

``
``
template <typename ... Facets>
facets_pack<Facets> pack(const Facets& ... facets)
{
    return facets_pack<Facets>{facets ...};
}
``
``
template <typename FacetCategory, typename InputType, typename ... Facets>
constexpr const auto& get_facet(const facets_pack<Facets...>& ft)
{
    return ft.template get_facet<FacetCategory, InputType>();
}
``
Passing a `facets_pack` to the `.facets` function is equivalent to pass all the facet objects it contains ( internally they are be grouped in a `facets_pack` anyway ).


[table Equivalences
[ [expression] [equivalent expression] ]
[
[`pack(a1, a2, ... , pack(b1, b2, ...), c1, c2, ...)`]
[`pack(a1, a2, ... , b1, b2, ... , c1, c2, ...)`]
]
[
[[~leading_expression]` .facets(pack(a1, a2, ...))` ]
[[~leading_expression]` .facets(a1, a2, ...) ` ]
]
[
[[~leading_expression]` .facets(a1, a2, ... , b1, b2, ...)` ]
[[~leading_expression]` .facets(a1, a2, ...) .facets(b1, b2, ...) ` ]
]
]


You will probably only use the `get_facet` function template if you ever extend the library for a [link extend_input.extend_input new input type]. It returns a reference to a constant facet object inside the `facets_pack` that belongs to the given `FacetCategory`, and that applies to `InputType` ( since facets can be [link constrained_facets constrained] to apply to only certain input types ). If the `facets_pack` does not contain such facet, then `FacetCategory::get_default()` is returned.

[note 
Passing a facet object to `pack` or to `constrain` creates a [_copy] of it into the `facets_pack` or into the constrained facet object. In order to avoid copying, you can pass instead a [@http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper `std::reference_wrapper`]. However all facets are designed to provide a fast copy. The [link numpunct str_grouping] is probably the slowest one, since it contains internally a `std::string`.
]



[get_facet_sample]


[endsect]

