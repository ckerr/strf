[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[import ../example/facets.cpp]

[#overview_facets]
[section:facets Facets]

These are not the same as the facets handled by `std::locale`,
but they are analogous.
Keep in mind that this is a locale-independent library.
So things are always printed as in the C-locale, unless
you explicitly specify otherwise, which you do by passing /facet
objects/ to the [link dispatcher_facets facets] function.
For example, to customise numeric punctuation:

[basic_facet_sample]

Every /facet/ belongs to a /facet category/. 
Each facet category corresponds to a concept, /i.e./ a set of requirements that a class must satisfy. A class that satisfies such requirements is a facet of such facet category. And for each facet category there is class with the same name.
[/
This class always have a static member function named `get_default` which has no parameter and returns a reference to a constant object, whose type is a facet of this category. Also, a facet must have member type named `category` which is an alias to the representative class of its category.
]

For example, [link monotonic_grouping `monotonic_grouping`]`<10>` and [link str_grouping
`str_grouping`]`<10>` are both facets of the category `numpunct_category<10>`.
Both has the same purpose: to customize numeric punctuation, however
`monotonic_grouping` is much faster.


[table
[[facet category][what it controls][constrainable][where is used]]

[
[[link width_calculation `width_calculation_category`]]
[how the width is calculated]
[yes]
[[link joins joins] and all conventional types]
]

[
[[link numpunct `numpunct_category<10>`]]
[numeric punctuation for decimal base]
[yes]
[integers and floating points numbers]
]

[
[[link numpunct `numpunct_category<16>`]]
[numeric punctuation for hexadecimal base]
[yes]
[integers and floating points numbers]
]

[
[[link numpunct `numpunct_category<8>`]]
[numeric punctuation for octal base]
[yes]
[integers numbers]
]

[
[[link encoding_facets encoding_category]]
[encoding]
[no]
[]
]

[
[[link encoding_error encoding_error_category]]
[encoding error handling]
[yes]
[]
]

[
[[link surrogate_policy surrogate_policy_category]]
[surrogates allowance]
[yes]
[]
]

[
[[link tr_string_error tr_string_error_category]]
[ /Tr-string/ parsing error handling]
[no]
[In /tr-strings/]
]

]


[#constrained_facets]
[h4 Constrained facets]

With the [link constrain `constrain`] function template you can create /constrained facet/, which is a facet that only applies to certain input types. Its template parameter is a template type that contain a `value` member constexpr convertible to bool that tells whether a given input type is under the influence of the given facet:

[constrained_facet_sample]

The library provides some type traits of this kind:

[table
[[trait] [description]]
[[`is_int_number`] [matches `short`, `int`, `long`, `long long` and the corresponding unsigned types]]
[[`is_char`]       [matches `char`, `wchar_t`, `char16_t`, and `char32_t`]]
[[`is_string`]     [matches strings inputs]]
]

[h4 Overriding facets]

If there are two or more facets object passed to the `facets` function of the same category and that apply to the same input type, then the last one wins:

[facets_overriding]

[h4 The `facets_pack` class template]

If you have two or more facet object that are used several times,
consider storing them into [link facets_pack `facets_pack`] object.
The `facets_pack` has some similarities to `std::tuple`, and
there is the `pack` fuction template that create `facets_pack`,
analogous as to how `std::make_tuple` creates `std::tuples`;

``
template <typename ... Facets>
class facets_pack;

template <typename ... Facets>
facets_pack<Facets> pack(const Facets& ... facets);
``

Passing a `facets_pack` object to the `facets` member function
is equivalent to pass all the facet objects it contains. For example,
`to_string.facets(f1, pack(f2, f3), f4)(args ...)` is equivalent to
`to_string.facets(f1, f2, f3, f4)`. And `f1`, `f2`, `f3` and `f4`
don't have to be facet objects. Actually [link FacetsPackElementRequirements
anything] that can be passed to `facets` member function can
be stored in a `facets_pack`, and vice-versa.

[/
[table Equivalences
[ [expression] [equivalent expression] ]
[
[`pack(a1, a2, ... , pack(b1, b2, ...), c1, c2, ...)`]
[`pack(a1, a2, ... , b1, b2, ... , c1, c2, ...)`]
]
[
[[~leading_expression]` .facets(pack(a1, a2, ...))` ]
[[~leading_expression]` .facets(a1, a2, ...) ` ]
]
[
[[~leading_expression]` .facets(a1, a2, ... , b1, b2, ...)` ]
[[~leading_expression]` .facets(a1, a2, ...) .facets(b1, b2, ...) ` ]
]
]
]

[note 
Facets are usually stored by copy in `facets_pack`. You can avoid this with [@http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper `std::reference_wrapper`]. However all facets are designed to provide a fast copy, with the exception perhaps of [link numpunct str_grouping] that contains internally a `std::string`.
]


[endsect]

