[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[#section_input_types]
[section:special_input_types Special input types]

[/
Actually, there is nothing really special about this category. The only difference from the "conventional" input types, is here the /secondary argument/ is different.
]

[#joins]
[section Joins]

[import ../example/joins.cpp]

Joins aligns a sub-list of arguments as if they where one argument.

Syntax:

* [~join_expression]` (`[~arguments]`...)`

where, the [~join_expression] is one of the following:

* `join_left(`[~width]`)`
* `join_left(`[~width]`, `[~fill_character]`)`
* `join_right(`[~width]`)`
* `join_right(`[~width]`, `[~fill_character]`)`
* `join_center(`[~width]`)`
* `join_center(`[~width]`, `[~fill_character]`)`
* `join_internal(`[~width]`, `[~num_args_before_fill]`)`
* `join_internal(`[~width]`, `[~fill_character]`, `[~num_args_before_fill]`)`

where:

* [~width] is `int`
* [~num_args_before_fill] is `int`
* [~fill_character] is `char32_t`

[h4 Example]

[joins_example]

You may want to use joins without the purpose of alignment, but solely to treat a whole sub-list of arguments as one.
This is something you way need to do in case you are using an [link assembly_string assembly string], especially if you can not edit the assembly string.

[join_with_assembly_string_part1]
[join_with_assembly_string_part2]
[join_with_assembly_string_part3]

[endsect]

[section Facets]
[import ../example/facets_pack_as_input.cpp]

You can apply some facet objects to only a subset of the arguments using the following syntax :

* `facets(`[~facets_obj]`...) (`[~arguments]`...)`

[facets_pack_input]

Notice that an argument in the sub list can be of any type that is possible in the outer list.
It could be, for instance, another facets_pack:

[facets_pack_input_2]

When using an assembly string, be aware that the sub-list of argument is treated as it where just one argument:

[facets_pack_input_in_assembly_string]

[endsect]

[#ranges]
[section Range]
[import ../example/range_input.cpp]

Syntax:

* `range(`[~range_expression]`)`
* `range(`[~range_expression]`, `[~separator]`)`
* `fmt_range(`[~range_expression]`)`
* `fmt_range(`[~range_expression]`, `[~separator]`)`

* `range(`[~first]`, `[~last]`)`
* `range(`[~first]`, `[~last]`, `[~separator]`)`
* `fmt_range(`[~first]`, `[~last]`)`
* `fmt_range(`[~first]`, `[~last]`, `[~separator]`)`

, where:

* [~range_expression] is a range that provides the multi-pass guarantee.
* [~first], [~last] are [@https://en.cppreference.com/w/cpp/named_req/ForwardIterator ForwardIterators].
* [~separator] is a raw string ( of `char`, `wchar_t`, `char16_t` or `char32_t`)

Example:

[range_sample]

You can use the format functions to format the range's elements

[range_sample_2]

The expression `fmt_range(`[~args]`...)` is equivalent to `fmt(range(`[~args]...`)`

[range_sample_3]

[endsect]

[section Assembly string ['(to do)]]
[import ../example/assembly_string_input.cpp]

[note It is not decided yet whether this will ever be implemented]

syntax:

* `as(`[~assembly_string]`) (`[~arguments]...`)`

[assembly_string_as_input]

[endsect]

[endsect]


