[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]


[section:extend_input How to add a new input type]

[/
Probably you only need to read the first example to know how to add most the input types you desire. There, we a print a IPv4 address, which is very simple since it is always four integer numbers separated by dots. Of course, there is no need to determinate each digit of the each of these numbers, since we use the library to print the numbers.
]

[variablelist
  [ [ Step 1]
    [ Overload `make_printer` function template like this:
      ``
      template <typename CharT, typename FacetsPack>
      printer_type make_printer( boost::stringify::output_writer<CharT>&
                               , const FacetsPack fp&
                               , your_input_type );
      ``
      where
      [itemized_list
        [ `CharT` is the output character type and it's determined by the output type.
           For instance, it is `char16_t` when `to_u16string` is used. ]
        [ `FacetsPack` is always an instance of [link facets_pack facets_pack] class template ]
        [ `printer_type` must be a concrete move-constructible type that inherits from
          [link printer `printer`]`<CharT>`. So actually there is still a previous step which
          is to define `printer_type`. However in the most simple ( and probably common )
          case this is unnecessary, because you can just return a call to another overload
          of `make_printer`. ]
      ] [/itemized_list]
    ]
  ] [/end step 1]
  [ [Step 2]
    [ [_If] you want to provide formatting options for this new type,
      then use the [link value_with_format `value_with_format`] class template to define
      another input type that contains both the input value and the format functions.
      ``
      using your_input_type_with_format = boost::stringify::value_with_format< your_input_type
                                                                             , format_classes ... >;
      ``
      Then overload the `make_fmt` function like this:
      ``
      your_input_type_with_format make_fmt(boost::stringify::tag, your_input_type);
      ``
    ]
    [ [br] And define another overload of `make_printer` that takes `your_input_type_with_format`
      ``
      template <typename CharT, typename FacetsPack>
      printer_type_2 make_printer( boost::stringify::output_writer<CharT>&
                                 , const FacetsPack fp&
                                 , your_input_type_with_format );
      ``
    ]
  ] [/ end step 2]
] [/ end of variable_list ]


[#printer]
[h3 The `printer` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual void write() const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[itemized_list
  [ [*write()] shall write the content into the [link output_writer `output_writer<CharT>`]
        that is passed in `make_printer` to construct the printer. ]
  [ [*necessary_size()] shall return the amount of characters written
        by `write()`, or a little more if the exact calculation is difficult,
        but never less. It is called when the output type needs to preallocate
        memory ( see [link syntax_reserve `reserve_auto()`] function ).]
  [ [*remaining_width(w)] shall return the same as `std::max(0, w - this_width)`,
        where `this_width` is the width of the content written by `write()`.
        This function is used in [link joins `joins`]. The implementation
        may have to use the [link width_calculation facets for width calculation]
        ( /to do/: this needs to be better documented ) ]
] [/itemized_list]


[#value_with_format]
[h3 The `value_with_format` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::fn<T>`. ]
      [`Fmt::fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::fn<T>` can be constructed from `const Fmt::fn<U>&`
       , assuming both are well formed. ] ] ] ]    



[#ipv4_example]
[section:ipv4_example Example 1: IPv4 address]
[import ../example/extend_input_ipv4.cpp]

Suppose `ipv4address` below is the input type:

[ipv4address_type]

Here, we can simply create a [link joins join] and return the result of calling
`make_printer` over it:

[make_printer_ipv4address]

[warning Watch out for dangling references: the expression
`join(/*...*/) (arg1, arg2, arg3)` instantiates an object
that holds [_references] to `arg1`, `arg2` and `arg3`,
which are commonly temporaries.
The following code like has undefined behavior:
``
  j = strf::join()(123); // a temporary int created here
  return make_printer(out, fp, j); // j holds a dangling reference
``
]

And it's done:

[ipv4_basic_sample]

[h4 Adding alignment formatting options]

Now let's go further and enable alignment, /a.k.a./ justification.
First, we use the [link value_with_format `value_with_format`] class template to define another input type that contains both an `ipv4address` value as well as the formatting stuff:

[ipv4address_with_format]

Now we define an overload of `make_printer` for `ipv4address_with_format`.

[make_printer_fmt_ipv4]

And it's done:

[formatted_ipv4address]

[endsect]

[section Example 2: IPv6 address]
[import ../example/extend_input_ipv6.cpp]

Now our input type represents an [@https://en.wikipedia.org/wiki/IPv6_address IPv6 address]:

[ipv6address]


[h4 Creating new format functions]

An IPv6 address can be represented in different ways. For example the three
representations below are equivalent:

* 2001:db8:0000:0000:0000:0000:0000:0001
* 2001:db8:0:0:0:0:0:1
* 2001:db8::1

So let's create the format functions named `big()` and `small()`
to select the longest and shortest representation respectively,
leaving the intermediate one as the default.

[ipv6_format]

[/
[note Notice that `big()` and `small()` are declared with the rvalue ref-qualifier
( the token '&&' after the parameter list ) and return `*this` as `derived_type &&`.
This is the convention for format functions. It is what allows constructions
like `hex(200).uppercase().showbase().fill(U'.') > 20`]
]

Now we define a class that gathers the IPv6 address value
with the formatting information and then we define the `make_fmt` function.
In addition to the formatting option that enables the abbreviated
representation, let's add support to alignment formatting, just
as we did in the [link ipv4_example IPv4 example].

[ipv6addr_with_format]

[#dynamic_join_printer]
[h4 The `dynamic_join_printer` class template]

It is not possible to simply use a [link joins join] as we did in the
[link ipv4_example IPv4 example] when the elements that composes the
[link joins join] are not known at compilation time.

Fortunately, the library provides an alternative solution
for cases like that: the `dynamic_join_printer`
class template.

``
template <typename CharOut>
class dynamic_join_printer: public stringify::v0::printer<CharOut>
{
public:

    dynamic_join_printer(stringify::v0::output_writer<CharOut>& out);

    void write() const override;
    std::size_t necessary_size() const override;
    int remaining_width(int w) const override;

protected:

    virtual void compose(stringify::v0::printers_receiver<CharOut>& out) const = 0;

    virtual stringify::v0::alignment_format<void> formatting() const
    {
        return {}; // by default the width is zero
    }
};
``

The `printers_receiver` class template is simply:
``
template <typename CharOut>
class printers_receiver
{
public:

    virtual ~printers_receiver();

    virtual bool put(const stringify::v0::printer<CharOut>& ) = 0;
};
``
When the `put` member function returns `false` there is no point
in calling it again with the remaining printers. This does not
necessarily mean that an error happened.
[/
For example, the implementation of `remaining_width`
creates a `printer_receivers` whose `put` function
returns false when the remaining width is already zero.
]

[h4 The printer]

We create a class template the derives from
[link dynamic_join_printer dynamic_join_printer]

[ipv6_printer]

The constructor:
[ipv6_printer__contructor]

[caution The `facets_pack` object that is passed in the constructor of a
printer class may be a temporary object. Hence don't store a reference
to it as a member variable of the printer class. It may became dangling. ]

And the `compose` function:

[ipv6_printer__compose]

And we need to override the `formatting()` function:

[ipv6_printer__formatting]

Now we just need to overload `make_printer`

[ipv6__make_printer]

And it's done:

[ipv6_samples]

You can see the full source code of the implementation [@../../example/extend_input_ipv6.cpp here].

[endsect]

[#base64_example]
[section Example 3: Base64]
[import ../example/extend_input_base64.cpp]

[/
It's like we wanted to create a function that takes an array of bytes and encodes it in
[@https://en.wikipedia.org/wiki/Base64 Base64].
But we rather create an extension to Boost.Stringify,
[/taking thus advantage of the support the library provides for a wide range of output types.]
taking thus advantage of the wide range of output types supported by the library.
Because otherwise we would need a create one function for each output type.
]

This is an example of when the intention is not exactly to add support to a certain input type,
but rather to create a function \u2014 let's name `base64` \u2014 that takes an array of
bytes to be encoded in [@https://en.wikipedia.org/wiki/Base64 Base64]:
``
boost::stringify::write(destination) (xxx::base64(bytes_array, num_bytes));
``
But since we need an input type to overload `make_printer`, we create one:

[fmt_base64_input]

[h4 Creating a new facet category]

Wikipedia told me that there are different
[@https://en.wikipedia.org/wiki/Base64#Variants_summary_table variants]
of Base64. So let's define a new facet category to handle them:

[base64_facet]

[h4 Format function]

Let's add indentation as a format function, which could be useful when the
content is printed into XML or YAML files:

[base64_format]

Since Base64 content is commonly printed in multiple lines,
alignment formatting doesn't make much sense here. So let's only use
`base64_format` in [link value_with_format `value_with_format`] this time:

[base64_input_with_format]

[h4 Implementing the printer]

``
namespace xxx {

template <typename CharT>
class base64_printer: public strf::printer<CharT>
{
public:

    base64_printer( strf::output_writer<CharT>& out
                  , base64_facet facet
                  , const fmt_base64& fmt )
    : m_out(out), m_facet(facet), m_fmt(fmt)
    {
    }

    void write() const override;
    std::size_t necessary_size() const override;
    int remaining_width( int w ) const override;

private:

    strf::output_writer<CharT>& m_out;
    const base64_facet m_facet;
    const fmt_base64 m_fmt;
};

}
``
`write()` shall put the content into the [link output_writer `output_writer`]
passed in the constructor. You can see that [link output_writer `output_writer`]
provides different functions (named `put` and `put32`) to do that.
One option is to this call `put(CharT)` for every single character
of the base64 content. That's not very efficient though.
Another option is to use `put(`[link piecemeal_input `piecemeal_input`]`<CharT>&)`.
This implies to create a class template that inherits from `piecemeal_input`
and overrides the `get_some` function that writes directly into a raw string.
This raw string is usually the internal buffer of the `output_writer` instance.

Actually It makes sense to  created two of such class templates. One for single
line mode and another for multiline, so that `base64_printer::write` is:

[base64_printer__write]

Let's see the implementation of `single_line_base64_pm_input`:

[single_line_base64_pm_input]

Each time `get_some(`[~begin], [~end]`)` is invoked it shall
write the continuation of the part written in the previous call.
That's why we need member variables like `m_column` \u2014
which keep track of how many of the indentation characters have been written
\u2014 and `m_index` \u2014 that records how many bytes have been encoded.
In the end, `report_success()` is called to signal that there
is nothing else to write.
You can see that `get_some(begin, end)` is not required to return `end` when
there is not enough space in the range \[`begin, end`). But the distance
from the returned position to `end` shall not be greater than
[link min_buff_size min_buff_size].

The implementation of `multiline_base64_pm_input` is more
complex. After all, some blocks may need to be split by an end of line
followed by indentation. Hence there is a larger number of
situations where the content may need to be interrupted to be
later continued in the next call of `get_some(`[~begin], [~end]`)`.
You can see its full implementation in
[@ ../../example/extend_input_base64.cpp source file].

After we define `base64_printer`, we can finally overload `make_printer`:

[make_printer_base64]

And it's done:

[base64_sample]

Some of the code has been omitted. You can see the full implementation
[@ ../../example/extend_input_base64.cpp here].

[endsect]

[endsect]

