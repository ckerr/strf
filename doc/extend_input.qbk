[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]


[section:extend_input How to add support to a new input type]

[/
Probably you only need to read the first example to know how to add most the input types you desire. There, we a print a IPv4 address, which is very simple since it is always four integer numbers separated by dots. Of course, there is no need to determinate each digit of the each of these numbers, since we use the library to print the numbers.
]

The procedure boils down:

[variablelist
  [ [ Step 1]
    [ Overload `make_printer` function template like this:
      ``
      template <typename CharT, typename FacetsPack>
      printer_type make_printer( boost::stringify::output_writer<CharT>&
                               , const FacetsPack fp&
                               , your_input_type );
      ``
      where
      [itemized_list
        [ `CharT` is the output character type and it's determined by the output type.
           For instance, it is `char16_t` when `to_u16string` is used. ]
        [ `FacetsPack` is always an instance of [link facets_pack facets_pack] class template ]
        [ `printer_type` must be a concrete move-constructible type that inherits from
          [link printer `printer`]`<CharT>`. So actually there is still a previous step which
          is to define `printer_type`. However in the most simple ( and probably common )
          case this is unnecessary, because you can just return a call to another overload
          of `make_printer`. ]
      ] [/itemized_list]
    ]
  ] [/end step 1]
  [ [Step 2]
    [ [_If] you want to provide formatting options for this new type, then create a class
      ( let's name it here as `your_fmt_type` ) that contains the formatting information and
      the value (or reference) of `your_input_type`. Then overload the `make_fmt` function like this:
      ``
      your_fmt_type make_fmt(boost::stringify::tag, your_input_type);
      ``
    ]
    [ [br] And define another overload of `make_printer` that takes formatting object as input:
      ``
      template <typename CharT, typename FacetsPack>
      printer_type make_printer( boost::stringify::output_writer<CharT>&
                               , const FacetsPack fp&
                               , your_fmt_type );
      ``
    ]
  ] [/ end step 2]
] [/ end of variable_list ]


[#printer]
[h3 The `printer` class template]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual void write() const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[itemized_list
  [ [*write()] shall write the content into the [link output_writer `output_writer<CharT>`]
        that is passed in `make_printer` to construct the printer. ]
  [ [*necessary_size()] shall return the amount of characters written
        by `write()`, or a little more if the exact calculation is difficult,
        but never less. It is called when the output type needs to preallocate
        memory ( see [link syntax_reserve `reserve_auto()`] function ).]
  [ [*remaining_width(w)] shall return the same as `std::max(0, w - this_width)`,
        where `this_width` is the width of the content written by `write()`.
        This function is used in [link joins `joins`]. The implementation
        may have to use the [link width_calculation facets for width calculation]
        ( /to do/: this needs to be better documented ) ]
] [/itemized_list]




[#ipv4_example]
[section:ipv4_example Example 1: IPv4 address]
[import ../example/v0/extend_input_ipv4.cpp]

Suppose `ipv4_addr` below is the input type:

[ipv4_addr_type]

[/
Since it's representation is just its numbers separated by dots, there is no need to define a new class that inherits from `printer<CharT>`. /]

Here, we can simply create a [link joins join] and return the result of calling `make_printer` over it:

[make_printer_ipv4_addr]

[warning Watch out for dangling references: the expression `join(/*...*/) (arg1, arg2, arg3)` instantiates an object that holds [_references] to `arg1`, `arg2` and `arg3`, which are commonly temporaries.
A code like this has undefined behavior:
``
  j = strf::join()(123); // a temporary int created here
  return make_printer(out, fp, j); // j holds a dangling reference
``
]

And it's done:

[ipv4_basic_sample]

[h4 Adding alignment formatting options]

Now let's go further and enable alignment, /a.k.a./ justification, like this:
[ipv4_fmt_sample]

The first sub-step is to define the class that contains the formatting information. Inheriting from `align_formatting` already gives us almost all we need:

[fmt_ipv4_addr]

The `align_formatting` class template contains the [link format_functions formatting functions] related to alignment ( the `fill` function and the operators `>`, `<`, `^`, `%` ). Note that we need to pass the type `fmt_ipv4_addr` as the template parameter of `align_formatting`. This is because the return type of these formatting functions needs be `fmt_ipv4_addr &&`.

Now, we need to implement `make_fmt`, which is trivial:

[make_fmt_ipv4]

And to implement the other overload of `make_printer`, the one that takes an `fmt_ipv4_addr`.

[make_printer_fmt_ipv4]

And it's done:

[formatted_ipv4_addr]

[endsect]

[section Example 2: IPv6 address]
[import ../example/v0/extend_input_ipv6.cpp]

Now our input type represents an [@https://en.wikipedia.org/wiki/IPv6_address IPv6 address]:

[ipv6_address]

An IPv6 address can be represented in different ways. For example the three
representations below are equivalent:

* 2001:db8:0000:0000:0000:0000:0000:0001
* 2001:db8:0:0:0:0:0:1
* 2001:db8::1

So let's create the formatting functions named `big` and `small` that makes the longest
and shortest representation, respectively, to be used, and let the intermediate
be the default.

We can not simply use a [link joins join] as we did in the
[link ipv4_example IPv4 example], because that
is only possible when we know at compilation time all the
elements that composes the [link joins join].
So we create a class template that derives from
the [link dynamic_join_printer dynamic_join_printer]
that in turn derives from [link printer `printer`].

[#dynamic_join_printer]
[h4 The `dynamic_join_printer` class template]
``
template <typename CharOut>
class dynamic_join_printer: public stringify::v0::printer<CharOut>
{
public:

    dynamic_join_printer(stringify::v0::output_writer<CharOut>& out);

    void write() const override;
    std::size_t necessary_size() const override;
    int remaining_width(int w) const override;

protected:

    virtual void compose(stringify::v0::printers_receiver<CharOut>& out) const = 0;

    virtual stringify::v0::align_formatting<void> formatting() const
    {
        return {}; // by default the width is zero
    }
};
``

The `printers_receiver` class template is simply:
``
template <typename CharOut>
class printers_receiver
{
public:

    virtual ~printers_receiver();

    virtual bool put(const stringify::v0::printer<CharOut>& ) = 0;
};
``
When the `put` member function returns `false` there is no point
in calling it again with the remaining printers. This does not
necessarily mean that an error happened.
[/
For example, the implementation of `remaining_width`
creates a `printer_receivers` whose `put` function
returns false when the remaining width is already zero.
]

[h4 The formatting class]


[Note Notice that `big` and `small` are declared with the rvalue ref-qualifier
( the token '&&' after the parameter list ) and return `*this` as `derived_type &&`.
This is the convention for format functions. It is what allows constructions
like `hex(200).uppercase().showbase().fill(U'.') > 20`]


In addition to the formatting option that enables the abbreviated
representation, let's add support to alignment formatting, just
as we did in the [link ipv4_example IPv4 example].
If we want to enable this input type be used in [link ranges fmt_range],
we first need to create a class template that handles
exclusively formatting and satisfies certain requirements:

[ipv6_formatting]

Now we define a class that gathers the IPv6 address value
with the formatting information, and overload `make_fmt`:

[fmt_ipv6]

[h4 The printer]

Now we define the class template the derives from
[link dynamic_join_printer dynamic_join_printer]

[ipv6_printer]

First, let's take a look at the member variables.
The `printer_impl` template alias gives us the concrete class that derives
from [link printer `printer`] that handles the given input type.
Hence the type of `m_colon` derives from `printer<CharT>`, and the same
applies to the elements of `m_hextets`.

[ipv6_printer__contructor]

Note that `fp` is a temporary object. May this lead to dangling references
stored in internal printers that are constructed with it? The answer is no
because, by convention, a printer class shall not store a reference
to the facets_pack with which it is constructed.

[caution The `facets_pack` object that is passed in the constructor of a
printer class may be a temporary object. Hence don't store a reference
to it as a member variable of the printer class. It may became dangling. ]

The parameter of the `compose` function shall receive these printers objects:

[ipv6_printer__compose]

And we need to override the `formatting()` function:

[ipv6_printer__formatting]

That works because the `align_formatting<void>` can be implicitly converted from
`align_formatting<`[~AnyType]`>`, as long as `align_formatting<`[~AnyType]`>`
is not a template specialisation.

Now we overload `make_printer`

[ipv6__make_printer]

And it's done:

[ipv6_samples]

You can see the full source code of the implementation [@../../example/v0/extend_input_ipv6.cpp here].

[endsect]

[#base64_example]
[section Example 3: Base64]
[import ../example/v0/extend_input_base64.cpp]

[/
It's like we wanted to create a function that takes an array of bytes and encodes it in
[@https://en.wikipedia.org/wiki/Base64 Base64].
But we rather create an extension to Boost.Stringify,
[/taking thus advantage of the support the library provides for a wide range of output types.]
taking thus advantage of the wide range of output types supported by the library.
Because otherwise we would need a create one function for each output type.
]



In this example we don't want exactly to add support to a certain input type,
but rather to create a function \u2014 let's name `base64` \u2014 that takes an array of
bytes to shall be encoded in [@https://en.wikipedia.org/wiki/Base64 Base64]:
``
boost::stringify::write(destination) (xxx::base64(bytes_array, num_bytes));
``

However we need an input type to overload `make_printer`. So let's create one.
Also, let's add some formatting option to make the example more complete.
This requires a class/struct that holds the formatting stuff in addition
to the data to be printed.
Does this imply two new input types? Maybe we only need the later for now.

[h4 Formatting class - the simplified version]

Since Base64 content is commonly printed in multiple lines,
alignment formatting doesn't make much sense here.
Let's then add indentation, which could be useful when the
content is printed into XML or YAML files:

[fmt_base64_simple_version]

The title says that this is the simplified version. That's
because it doesn't work in [link ranges `fmt_range`].
If that is not necessary we can leave it like that,
otherwise ...

[#base64_complete_formatting_class]
[h4 Formatting class - the complete version ( that works with `fmt_range` ) ]

... otherwise there are some extra steps:

The elements of the range need to have a type. So this time we define
an input type that is decoupled from the formatting stuff:

[fmt_base64_complete_version__input]

Then we need to create a class template that deals only with formatting.
It does not contain the data to be printed:

[fmt_base64_complete_version__formatting]

Finally, we define a class that gathers formatting with the input value:

[fmt_base64_complete_version__fmt]

Then we define `base64` and `make_fmt` function:

[fmt_base64_complete_version__functions]

[h4 Creating a new facet category]

[base64_facet]

[h4 Implementing the printer]

``
namespace xxx {

template <typename CharT>
class base64_printer: public strf::printer<CharT>
{
public:

    base64_printer( strf::output_writer<CharT>& out
                  , base64_facet facet
                  , const fmt_base64& fmt )
    : m_out(out), m_facet(facet), m_fmt(fmt)
    {
    }

    void write() const override;
    std::size_t necessary_size() const override;
    int remaining_width( int w ) const override;

private:

    strf::output_writer<CharT>& m_out;
    const base64_facet m_facet;
    const fmt_base64 m_fmt;
};

}
``
`write()` shall put the content into the [link output_writer `output_writer`]
passed in the constructor. You can see that [link output_writer `output_writer`]
provides different functions (named `put` and `put32`) to do that.
One option is to this call `put(CharT)` for every single character
of the base64 content. That's not very efficient.
Another option is to use `put(`[link piecemeal_writer `piecemeal_writer`]`<CharT>&)`.
This implies to create a class template that inherits from `piecemeal_writer`
and overrides the `write` function which writes directly into a raw string,
which is usually the internal buffer of the `output_writer` instance.

Actually I created two of such class templates. One for single line mode and
another for multiline. So that `base64_printer::write` is:

[base64_printer__write]

Let's see the implementation of `single_line_base64_pm_writer`:

[single_line_base64_pm_writer]

Each time `write(`[~begin], [~end]`)` is invoked it shall
write the continuation of the part written in the previous call.
That's why we need member variables like `m_column` \u2014
which keep track of how many the indentation characters have been written \u2014
and `m_index` \u2014 that records how many bytes have been encoded.
In the end, `report_success()` is called to signal that there
is nothing else to write.
You can see that `write(begin, end)` is not required to return `end` when
there is not enough space in the range \[`begin, end`). But the distance
from the returned position to `end` shall not be greater than
[link BOOST_STRINGIFY_MIN_BUFFER_SIZE BOOST_STRINGIFY_MIN_BUFFER_SIZE].


The implementation of `multiline_base64_pm_writer` is more
complex. After all, some blocks may need to be split by an end of line
followed by indentation. Hence there is a larger number of
situations where the content may need to be interrupted to be
later continued in the next call of `write(`[~begin], [~end]`)`.
I will just show here the `write` function:

[multiline_base64_pm_writer__write]

After we define `base64_printer`, we can finally overload `make_printer`:

[make_printer_base64]

And it's done.

[base64_sample]

Some of the code has been omitted. You can see the full implementation
[@ ../../example/v0/extend_input_base64.cpp here].

[endsect]

[endsect]

