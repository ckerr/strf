[/==============================================================================
    Use, modification and distribution is subject to the Boost Software License,
    Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
    http://www.boost.org/LICENSE_1_0.txt)
===============================================================================/]

[#printer]
[h3 Abstrac class template `printer`]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename CharT>
class printer
{
public:

    virtual ~printer() { }

    virtual bool write(output_buffer<CharT>& ob) const = 0;
    virtual std::size_t necessary_size() const = 0;
    virtual int remaining_width( int w ) const = 0;
};

}}}

``
[h4 Public virtual member functions]

[#printer_write]
[table
[[
  `virtual bool write(`[link output_buffer `output_buffer`]`<CharT>& ob) const = 0;`
]]
[[
  [variablelist
    [[Effect]
     [Writes text into `ob`]]
    [[Return]
     [`true` on success, `false` otherwise. On failure, this function shall also
      call `ob.`[link ouput_buffer_set_error `set_error`]`(`[~some_error_code]`)`.]]
    [[Post condition]
     [If `ob.size() <= necessary_size()` then this function must not call
      `ob.recycle()`]]]
]]
]

[#printer_necessary_size]
[table
[[
  `virtual std::size_t necessary_size() const = 0;`
]]
[[
   [variablelist
    [[Note]
     [This function is only called by [link destination `destination`]
      when [link destination_reserve_calc `reserve_calc`] is used.]]
    [[Effect]
      [Calculates how many characters [link printer_write `write`]
       function writes. The result does not need to be exact, but
       must not be less than the exact value.]]]
]]
]


[#printer_remaining_width]
[table
[[
  `virtual int remaining_width( int w ) const = 0;`
]]
[[
   [variablelist
    [[Effect]
     [ /To-do/ ]]]
     [/Returns the same as `std::max(0, w - this_width)`,
      where `this_width` is the width of the content written by `write()`.
      This function is used in [link joins `joins`]. The implementation
      may have to use the [link width_calculation facets for width calculation]]
]]
]



[#value_with_format]
[h3 Class template `value_with_format`]

``
namespace boost { namespace stringify { inline namespace v0 {

template <typename ValueType, class ... Fmts>
class value_with_format
    : public Fmts::template fn<value_with_format< ValueType, Fmts ...>> ...
{
public:

    constexpr value_with_format(const value_with_format&);
    constexpr value_with_format(value_with_format&&);
    constexpr value_with_format(const ValueType&);


    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , const value_with_format<OtherValueType, Fmts...>& );

    template <typename OtherValueType>
    constexpr value_with_format
        ( const ValueType&
        , value_with_format<OtherValueType, Fmts...>&& );


    template <typename ... OtherFmts>
    constexpr value_with_format
        ( const value_with_format<ValueType, OtherFmts...>& );

    template <typename ... OtherFmts>
    constexpr value_with_format
        ( value_with_format<ValueType, OtherFmts...>&& );


    constexpr const ValueType& value() const;
};

}}}
``
[itemized_list
  [`ValueType` must be copy constructible ]
  [Each type `Fmt` in the `Fmts...` pack has a member `fn` that is a template
    with one template type parameter such that, given the types `T` and `U`:
    [itemized_list
      [`Fmt::fn<T>` is well formed if `T` is `value_with_format<ValueType, Fmts ...>`
        . In this case, note that `T` derives from `Fmt::fn<T>`. ]
      [`Fmt::fn<T>` is default constructible, assuming it is well formed.]
      [`Fmt::fn<T>` can be constructed from `const Fmt::fn<U>&`
       , assuming both are well formed. ] ] ] ]    


