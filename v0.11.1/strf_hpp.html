<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<title>&lt;strf.hpp&gt; Header file reference</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:34em;padding-right:0}
#toc.toc2{width:34em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:34em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{min-width:9em;font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body id="main" class="article toc2 toc-left">
<div id="header">
<h1><code>&lt;strf.hpp&gt;</code> Header file reference</h1>
<div id="toc" class="toc2">
<div id="toctitle">&lt;strf.hpp&gt;</div>
<ul class="sectlevel1">
<li><a href="#_facets_pack">1. facets_pack</a>
<ul class="sectlevel2">
<li><a href="#facets_pack">1.1. Class template <code>facets_pack</code></a></li>
<li><a href="#pack">1.2. Function template <code>pack</code></a></li>
<li><a href="#get_facet">1.3. Function template <code>get_facet</code></a></li>
<li><a href="#has_facet">1.4. Hypothetical function template <code>fas_facet</code></a></li>
<li><a href="#do_get_facet">1.5. Hypothetical function template <code>do_get_facet</code></a></li>
<li><a href="#constrained_fpe">1.6. Class template <code>constrained_fpe</code></a></li>
<li><a href="#_function_template_code_constrain_code">1.7. Function template <code>constrain</code></a></li>
<li><a href="#FacetsPackElement">1.8. Type requirement <em>FacetsPackElement</em></a></li>
<li><a href="#ConstrainableFacetsPackElement">1.9. Type requirement <em>ConstrainableFacetsPackElement</em></a></li>
<li><a href="#Facet">1.10. Type requirement <em>Facet</em></a></li>
<li><a href="#FacetCategory">1.11. Type requirement <em>FacetCagory</em></a></li>
<li><a href="#facet_traits">1.12. Class template <code>facet_traits</code></a></li>
<li><a href="#facet_category">1.13. Type alias <code>facet_category</code></a></li>
</ul>
</li>
<li><a href="#destination">2. Destination types</a>
<ul class="sectlevel2">
<li><a href="#destination_no_reserve">2.1. Class template <code>destination_no_reserve</code></a></li>
<li><a href="#destination_calc_size">2.2. Class template <code>destination_calc_size</code></a></li>
<li><a href="#destination_with_given_size">2.3. Class template <code>destination_with_given_size</code></a></li>
<li><a href="#OutbuffCreator">2.4. Type requirement <em>OutbuffCreator</em></a></li>
<li><a href="#SizedOutbuffCreator">2.5. Type requirement <em>SizedOutbuffCreator</em></a></li>
</ul>
</li>
<li><a href="#tr_string">3. Tr-String</a>
<ul class="sectlevel2">
<li><a href="#_syntax">3.1. Syntax</a></li>
<li><a href="#tr_error_notifier_c">3.2. Facet category <code>tr_error_notifier_c</code></a></li>
</ul>
</li>
<li><a href="#_printable_types">4. printable types</a>
<ul class="sectlevel2">
<li><a href="#_strings">4.1. Strings</a></li>
<li><a href="#_single_characters">4.2. Single characters</a></li>
<li><a href="#__code_bool_code">4.3. <code>bool</code></a></li>
<li><a href="#__code_const_void_code">4.4. <code>const void*</code></a></li>
<li><a href="#_integers">4.5. Integers</a></li>
<li><a href="#_floating_points">4.6. Floating Points</a></li>
<li><a href="#_ranges">4.7. Ranges</a></li>
<li><a href="#joins">4.8. Joins</a></li>
<li><a href="#global_function_with">4.9. Facets</a></li>
</ul>
</li>
<li><a href="#_character_encodings">5. Character encodings</a>
<ul class="sectlevel2">
<li><a href="#char_encoding_id">5.1. Enumeration <code>char_encoding_id</code></a></li>
<li><a href="#invalid_seq_notifier_c">5.2. Facet category <code>invalid_seq_notifier_c</code></a></li>
<li><a href="#surrogate_policy">5.3. Facet category <code>surrogate_policy_c</code></a></li>
<li><a href="#char_encoding_function_pointers">5.4. Aliases for pointers to functions</a></li>
<li><a href="#UnderlyingTranscoder">5.5. Type requirement <em>UnderlyingTranscoder</em></a></li>
<li><a href="#UnderlyingCharEncoding">5.6. Type requirement <em>UnderlyingCharEncoding</em></a></li>
<li><a href="#static_underlying_transcoder">5.7. Class template <code>static_underlying_transcoder</code></a></li>
<li><a href="#static_underlying_char_encoding">5.8. Class template <code>static_underlying_char_encoding</code></a></li>
<li><a href="#dynamic_underlying_transcoder">5.9. Class template <code>dynamic_underlying_transcoder</code></a></li>
<li><a href="#dynamic_underlying_char_encoding_data">5.10. Struct template <code>dynamic_underlying_char_encoding_data</code></a></li>
<li><a href="#dynamic_underlying_char_encoding">5.11. Class template <code>dynamic_underlying_char_encoding</code></a></li>
<li><a href="#find_transcoder">5.12. Function template <code>find_transcoder</code></a></li>
<li><a href="#decode_encode">5.13. Function template <code>decode_encode</code></a></li>
<li><a href="#decode_encode_size">5.14. Function template <code>decode_encode_size</code></a></li>
<li><a href="#char_encoding_c">5.15. Facet category template <code>char_encoding_c</code></a></li>
<li><a href="#CharEncodingFacet">5.16. Type requirement <em>CharEncodingFacet</em></a></li>
<li><a href="#static_char_encoding">5.17. Class template <code>static_char_encoding</code></a></li>
<li><a href="#static_char_encoding_aliases">5.18. Type aliases for encodings</a></li>
<li><a href="#dynamic_char_encoding">5.19. Class template <code>dynamic_char_encoding</code></a></li>
</ul>
</li>
<li><a href="#_width_calculation">6. Width Calculation</a>
<ul class="sectlevel2">
<li><a href="#width_calculator_c">6.1. Facet category <code>width_calculator_c</code></a></li>
<li><a href="#fast_width">6.2. Class <code>fast_width</code></a></li>
<li><a href="#width_as_fast_u32len">6.3. Class <code>width_as_fast_u32len</code></a></li>
<li><a href="#width_as_u32len">6.4. Class <code>width_as_u32len</code></a></li>
<li><a href="#width_by_func">6.5. Class template <code>width_by_func</code></a></li>
<li><a href="#make_width_calculator">6.6. Function template <code>make_width_calculator</code></a></li>
<li><a href="#width_t">6.7. Class <code>width_t</code></a></li>
<li><a href="#width_literal">6.8. <code>width_t</code> literal <code>_w</code></a></li>
</ul>
</li>
<li><a href="#_numeric_punctuation">7. Numeric punctuation</a></li>
<li><a href="#_miscellaneous">8. Miscellaneous</a>
<ul class="sectlevel2">
<li><a href="#_the_code_lettercase_code_facet">8.1. The <code>lettercase</code> facet</a></li>
<li><a href="#_type_traits">8.2. Type traits</a></li>
<li><a href="#tag">8.3. Class template <code>tag</code></a></li>
<li><a href="#__code_outbuff_code_writing_functions">8.4. <code>Outbuff</code> writing functions</a></li>
<li><a href="#_destination_markers">8.5. Destination markers</a></li>
<li><a href="#alignment_format_functions">8.6. Alignment format functions</a></li>
<li><a href="#_format_function_aliases">8.7. Format function aliases</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This document is still a work in progress.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_facets_pack">1. facets_pack</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="facets_pack">1.1. Class template <code>facets_pack</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename ... FPE&gt;
class facets_pack;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p>All types in <code>FPE...</code> satisfy
<a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions">1.1.1. Member functions</h4>
<div class="sect4">
<h5 id="_constructors">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr facets_pack(const facets_pack&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element in this object with the corresponding element in <code>other</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_copy_constructible_v&lt;FPE&gt; &amp;&amp; ...</code>,
otherwise this constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr facets_pack(facets_pack&amp;&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element from the
rvalue reference of the corresponding element in <code>other</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_move_constructible_v&lt;FPE&gt; &amp;&amp; ...</code>, otherwise this
constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr explicit facets_pack(const FPE&amp; ... fpe)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element with the correspondig value in <code>fpe...</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_copy_constructible_v&lt;FPE&gt; &amp;&amp; ...</code>, otherwise this
constructor does not participate in overload resolution.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... U&gt;[br]
constexpr explicit facets_pack(U&amp;&amp;... u)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>Initializes each element with the correspondig value in <code>std::forward&lt;U&gt;(u)...</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p>This constructor does not participate in overload resolution, unless</p>
<div class="ulist">
<ul>
<li>
<p><code>sizeof...(U) == sizeof...(FPE)</code>, and</p>
</li>
<li>
<p><code>sizeof...(U) != 0</code>, and</p>
</li>
<li>
<p><code>std::is_constructible_v&lt;FPE, U&amp;&amp;&gt; &amp;&amp; ...</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_assignment_operators_deleted">Assignment operators (deleted)</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">   facets_pack&amp; operator=(const facets_pack&amp;) = delete
   facets_pack&amp; operator=(facets_pack&amp;&amp;) = delete;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>Assignments are deleted because they seem unecessary and it&#8217;s unclear
what would be the best
implementation in the case there is any reference type in <code>FPE...</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pack">1.2. Function template <code>pack</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename ... T&gt;
constexpr /* see below */ pack(const T&amp; ... args)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code><a href="#facets_pack">facets_pack</a>&lt;std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;...&gt;</code></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p>A <code><a href="#facets_pack">facets_pack</a></code> object initialized with <code>std::forward&lt;T&gt;(args)...</code></p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="get_facet">1.3. Function template <code>get_facet</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename FCat, typename Tag, typename ... T&gt;
constexpr decltype(auto) get_facet(const facets_pack&lt;T...&gt;&amp; fp);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<p>If <a href="#has_facet"><code>has_facet&lt;FCat, Tag&gt;(fp)</code></a> returns <code>true</code> then
returns &lt;&lt;do_get_facet,<code>do_get_facet&lt;FCat, Tag&gt;(fp)</code>, otherwise
return <code>FCat::get_default()</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>FCat</code> is a <em><a href="#FacetCategory">FacetCategory</a></em> type.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="has_facet">1.4. Hypothetical function template <code>fas_facet</code></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This function template does not exists in this library.
       It is only documented to help to explain the
       <a href="#get_facet"><code>get_facet</code></a> function template.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename FCat, typename Tag, typename FPE&gt;
constexpr bool has_facet(const FPE&amp; fpe)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>FPE</code> is an instance of <a href="#facets_pack"><code>facets_pack</code></a>, then returns wheter there
is any elemente <code>elm</code> in <code>fpe</code> such that <code>has_facet&lt;FCat, Tag&gt;(elm)</code>
is <code>true</code>.</p>
</li>
<li>
<p>If <code>FPE</code> is an instance of <a href="#constrained_fpe"><code>constrained_fpe&lt;FPE, Filter&gt;</code></a>,
then returns <code>Filter&lt;Tag&gt;::value &amp;&amp; has_facet&lt;FCat, Tag&gt;(fpe.get())</code>.</p>
</li>
<li>
<p>If <code>FPE</code> is a  <a href="#facet"><em>Facet</em></a> type, returns <code>std::is_same_v&lt;FCat, <a href="#facet_category">facet_category</a>&lt;FPE&gt;&gt;</code></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> is a <em><a href="#FacetCategory">FacetCategory</a></em> type.</p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="do_get_facet">1.5. Hypothetical function template <code>do_get_facet</code></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This function template is not part of the library.
      It only is documented to help to explaine the
      <a href="#get_facet"><code>get_facet</code></a> function template
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename FCat, typename Tag, typename FPE&gt;
constexpr decltype(auto) do_get_facet(const FPE&amp; fpe);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> satisfies <em><a href="#FacetCategory">FacetCategory</a></em>.</p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>has_facet&lt;FCat, Tag&gt;(fpe)</code> is <code>true</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="constrained_fpe">1.6. Class template <code>constrained_fpe</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;template &lt;class&gt; class Filter, typename FPE&gt;
class constrained_fpe;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p>The class template <code>constrained_fpe</code> is designed to be used in
<a href="#facets_pack"><code>facets_pack</code></a>. <code>constrained_fpe&lt;Filter, FPE&gt;</code>
holds a value of <code>FPE</code> that will only be returned by
<a href="#get_facet"><code>get_facet&lt;Category, Tag&gt;</code></a> if
<code>Filter&lt;Tag&gt;::value</code> is <code>true</code>.</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>For any type <code>T</code>, <code>Filter&lt;T&gt;</code> has a member variable <code>value</code> that is a
static constexpr value whose type is implicitly convertible to <code>bool</code></p>
</li>
<li>
<p><code>FPE</code> satisfies <a href="#ConstrainableFacetsPackElement"><em>ConstrainableFacetsPackElement</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis">1.6.1. Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;template &lt;class&gt; class Filter, typename FPE&gt;
class constrained_fpe
{
public:
    // <a href="#constrained_fpe_constructor">constructors</a>
    constexpr constrained_fpe(const constrained_fpe&amp;) = default;
    constexpr constrained_fpe(constrained_fpe&amp;&amp; other) = default;
    constexpr constrained_fpe(const FPE&amp; f);

    // <a href="#constrained_fpe_element_access">element access</a>
    constexpr const FPE&amp; get() const;

private:
    FPE element; // exposition only;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_2">1.6.2. Member functions</h4>
<div class="sect4">
<h5 id="constrained_fpe_constructor">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr explicit constrained_fpe(const FPE&amp; fpe);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes the element of the <code>constrained_fpe</code> with <code>fpe</code>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr constrained_fpe(const constrained_fpe&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes the element of the <code>constrained_fpe</code> from
the const reference of the element of <code>other</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_copy_constructible&lt;FPE&gt;::value</code> is <code>true</code>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr constrained_fpe(constrained_fpe&amp;&amp; other);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Initializes the element of the <code>constrained_fpe</code> from
the rvalue reference of element of <code>other</code>.</p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>std::is_move_constructible&lt;FPE&gt;::value</code> is <code>true</code>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_element_access">Element access</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr const FPE&amp; get() const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<div class="dlist">
<dl>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Return the stored element;</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_function_template_code_constrain_code">1.7. Function template <code>constrain</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>template &lt;template &lt;class&gt; class Filter, typename T&gt;
constexpr constrained_fpe&lt;Filter, U&gt; constrain(const T&amp; arg);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
<dd>
<p><code>constrain</code> is just a syntatic sugar to create a <a href="#constrained_fpe"><code>constrained_fpe</code></a> object.</p>
<div class="dlist">
<dl>
<dt class="hdlist1">Return type</dt>
<dd>
<p><code>constrained_fpe&lt;Filter, U&gt;</code>, where <code>U</code> is
<code>std::remove_cv_t&lt;std::remove_reference_t&lt;T&gt;&gt;</code>.</p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<p><code>constrained_fpe&lt;Filter, U&gt;{ std::forward&lt;T&gt;(arg) }</code></p>
</dd>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>T</code> is such that <code>U</code> satisfies <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="FacetsPackElement">1.8. Type requirement <em>FacetsPackElement</em></h3>
<div class="paragraph">
<p>A given type <code>F</code> satisfies <em>FacetsPackElement</em> if, and only if, one of the following conditions is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is a <a href="#Facet"><em>Facet</em></a> type.</p>
</li>
<li>
<p><code>F</code> is an instance of <a href="#facets_pack"><code>facets_pack</code></a>.</p>
</li>
<li>
<p><code>F</code> is an instance of <a href="#constrained_fpe"><code>constrained_fpe</code></a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ConstrainableFacetsPackElement">1.9. Type requirement <em>ConstrainableFacetsPackElement</em></h3>
<div class="paragraph">
<p>A given a type <code>F</code> is a <em>ConstrainableFacetsPackElement</em> if, and only if,
one of the following conditions is true:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is a  <a href="#Facet"><em>Facet</em></a> type and  <code><a href="#facet_category">facet_category</a>&lt;F&gt;::constrainable</code> is <code>true</code>.</p>
</li>
<li>
<p><code>F</code> is <code>facets_pack&lt;F2...&gt;</code> and all types in <code>F2...</code> are <em>ConstrainableFacetsPackElement</em>.</p>
</li>
<li>
<p><code>F</code> is an instance of <a href="#constrained_fpe"><code>constrained_fpe</code></a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="Facet">1.10. Type requirement <em>Facet</em></h3>
<div class="paragraph">
<p>A given a type <code>F</code> satisfies <code>Facet</code> if all of the following conditions are met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>F</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
<li>
<p><code><a href="#facet_category">facet_category</a>&lt;F&gt;</code> satisfies the <em><a href="#FacetCategory">FacetCategory</a></em> requirements.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="FacetCategory">1.11. Type requirement <em>FacetCagory</em></h3>
<div class="paragraph">
<p>A given a type <code>FCat</code> satisfies <code>FacetCategory</code> if:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>FCat</code> has a static member function named <code>get_default</code> that takes
no argument and whose return type is either <code>F</code> or <code>const F&amp;</code>,
where <code>F</code> is a type that satisfies the requirements associated to
<code>FCat</code>.</p>
</li>
<li>
<p><code>FCat</code> has a member named <code>constrainable</code> that is a static constexpr
value convertible to <code>bool</code>. ( If this value is <code>false</code> then
the facets associated <code>FCat</code> can not be <a href="#constrained_fpe">constrained</a> ).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="facet_traits">1.12. Class template <code>facet_traits</code></h3>
<div class="paragraph">
<p>This class template provides the <a href="#Facet">Facet</a> informations.
If you create a new facet, you can either define such informations as
members of the facet, or specialize <code>facet_traits</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>template &lt;typename F&gt;
class facet_traits
{
public:
    using category = /* Facet::category or void */;
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_public_members">1.12.1. Public members</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>typename /* */ category;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Same as <code>Facet::category</code> if such member exist and is a type,
otherwise it is an alias to <code>void</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_specialization">1.12.2. Specialization</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>template &lt;typename F&gt;
class facet_traits&lt;const F&gt;
{
public:
    using category = typename facet_traits&lt;F&gt;::category;
};</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="facet_category">1.13. Type alias <code>facet_category</code></h3>
<div class="paragraph">
<p><code>facet_category</code> is just a syntatic sugar:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code>template &lt;typename Facet&gt;
using facet_category = facet_traits&lt;Facet&gt;::typename category;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="destination">2. Destination types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>destination_no_reserve</code>, <code>destination_reserve_calc</code> and
<code>destination_with_given_size</code> class templates provide the
basic usage syntax of the library:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="syntax.svg" alt="syntax">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>no_reserve()</code> always returns a <code>destination_no_reserve</code> object</p>
</li>
<li>
<p><code>reserve_calc()</code> always returns a <code>destination_reserve_calc</code> object.</p>
</li>
<li>
<p><code>reserve(<em>size</em>)</code> always returns a <code>destination_with_given_size</code> object.</p>
</li>
<li>
<p>The <em>destination</em> is an object whose type is an instance of one
those three class templates.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="destination_no_reserve">2.1. Class template <code>destination_no_reserve</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename OutbuffCreator, typename FPack = <a href="#facets_pack">facets_pack</a>&lt;&gt;&gt;
class destination_no_reserve</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is an instance of <a href="#facets_pack"><code>facets_pack</code></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> satisfies <a href="#OutbuffCreator"><em>OutbuffCreator</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_2">2.1.1. Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename OutbuffCreator, typename FPack&gt;
class destination_no_reserve
{
public:
    using char_type = typename OutbuffCreator::char_type;

    // <a href="#destination_no_reserve_ctor">constructors</a>
    template &lt;typename... Args&gt;
    constexpr destination_no_reserve(Args&amp;&amp;...);
    constexpr destination_no_reserve(const destination_no_reserve&amp;);
    constexpr destination_no_reserve(destination_no_reserve&amp;&amp;);

    // <a href="#destination_no_reserve_with">facets</a>
    template &lt;typename... FPE&gt;
    destination_no_reserve&lt;OutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) const &amp;;

    template &lt;typename... FPE&gt;
    destination_no_reserve&lt;OutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) &amp;&amp;;

    // <a href="#destination_no_reserve_reserve">size reserve</a>
    constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt;
    reserve_calc() const &amp;;

    constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt;
    reserve_calc() &amp;&amp;;

    constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
    reserve(std::size_t) const &amp;;

    constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
    reserve(std::size_t) &amp;&amp;;

    constexpr destination_no_reserve&amp;  no_reserve() &amp;;
    constexpr destination_no_reserve&amp;&amp; no_reserve() &amp;&amp;;
    constexpr const destination_no_reserve&amp;  no_reserve() const &amp;;
    constexpr const destination_no_reserve&amp;&amp; no_reserve() const &amp;&amp;;

    // <a href="#destination_no_reserve_printing">printing</a>
    template &lt;typename... Args&gt;
    /*...*/ operator()(const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(const char_type*, const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr( const std::basic_string_view&lt;char_type&gt;&amp;
              , const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr( std::basic_string_view&lt;char_type&gt;
              , const Args&amp;...) const;

private:
    OutbuffCreator _outbuff_creator; // exposition only
    FPack _fpack;                  // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_public_member_functions">2.1.2. Public member functions</h4>
<div class="sect4">
<h5 id="destination_no_reserve_ctor">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
constexpr destination_no_reserve(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible"><em>DefaultConstructible</em></a></p>
</li>
<li>
<p><code>std::is_constructible&lt;OutbuffCreator, Args...&gt;</code> is <code>true</code>, otherwise this constructor does not participate on overload resolution.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>_outbuff_creator</code> with <code>std::forward&lt;Args&gt;(args)...</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_no_reserve(const destination_no_reserve&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Copy constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> and <code>OutbuffCreator</code> are
<a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_no_reserve(destination_no_reserve&amp;&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Move constructor.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_no_reserve_with">Facets</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_no_reserve&lt; OutbuffCreator
                      , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                     , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates a <code>destination_no_reserve</code> object whose <code>_outbuff_creator</code>
is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is initialized
with <code>pack(this-&gt;_fpack, std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_no_reserve&lt; OutbuffCreator
                      , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                     , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_no_reserve</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(_outbuff_creator)</code>, and whose <code>_fpack</code> is
initialized with <code>pack(std::move(this-&gt;_fpack), std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_no_reserve_reserve">Size reserve</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; reserve_calc() const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_calc_size</code> object whose <code>_outbuff_creator</code>
is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is
initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; reserve_calc() &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_calc_size</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(_outbuff_creator)</code> from this object, and whose <code>_fpack</code> object is
initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
reserve(std::size_t size) const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> whose <code>_size</code> is initialized with <code>size</code>,
whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is
initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
reserve(std::size_t size) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a>
   and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> object whose <code>_size</code> is initialized with <code>size</code>,
whose <code>_outbuff_creator</code> is initialized with <code>std::move(_outbuff_creator)  from this object,
and whose `_fpack</code> is initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_no_reserve&amp;  no_reserve() &amp;;
constexpr destination_no_reserve&amp;&amp; no_reserve() &amp;&amp;;
constexpr const destination_no_reserve&amp;  no_reserve() const &amp;;
constexpr const destination_no_reserve&amp;&amp; no_reserve() const &amp;&amp;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>None.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>This object.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_no_reserve_printing">Printing</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
/*...*/ operator()(const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#Printable"><em>Printable</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creates/get the <a href="#basic_outbuff">outbuff</a> object doing</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">decltype(auto) ob = _outbuff_creator.create()</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>arg</code> in <code>args...</code>, creates a printer object by doing:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto p = static_cast&lt; const {printer}&lt;sizeof(CharT)&gt;&amp; &gt;
    ( <a href="#printer_impl">printer_impl</a>&lt;CharT, FPack, T&gt;{fpack, preview, x, chtag} )</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code>preview</code> is an instance of
  <code><a href="#print_preview">print_preview</a>&lt;preview_size::no, preview_width::no&gt;</code>
, and <code>chtag</code> is an expression of type <code><a href="#tag">tag</a>&lt;CharT&gt;</code>.</p>
</div>
</li>
<li>
<p>For each <code>p</code> object does <code>p.print_to(ob)</code></p>
</li>
<li>
<p>Returns <code>ob.finish()</code> if such expression is valid, which is optional.
Otherwise the return type is <code>void</code>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const char_type* tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const std::basic_string_view&lt;char_type&gt;&amp; tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( std::basic_string_view&lt;char_type&gt; tr_string
          , const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#Printable"><em>Printable</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p><em>to-do</em></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="destination_calc_size">2.2. Class template <code>destination_calc_size</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename SizedOutbuffCreator, typename FPack = <a href="#facets_pack">facets_pack</a>&lt;&gt;&gt;
class destination_calc_size;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is an instance of <a href="#facets_pack"><code>facets_pack</code></a>.</p>
</li>
<li>
<p><code>SizedOutbuffCreator</code> satisfies <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_3">2.2.1. Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename SizedOutbuffCreator, typename FPack&gt;
class destination_reserve_calc
{
public:
    using char_type = typename SizedOutbuffCreator::char_type;

    // <a href="#destination_reserve_calc_ctor">constructors</a>
    template &lt;typename... Args&gt;
    constexpr destination_reserve_calc(Args&amp;&amp;...);

    constexpr destination_reserve_calc(const destination_reserve_calc&amp;) = default;
    constexpr destination_reserve_calc(destination_reserve_calc&amp;&amp;) = default;

    // <a href="#destination_reserve_calc_with">facets</a>
    template &lt;typename... FPE&gt;
    destination_reserve_calc&lt;SizedOutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) const &amp;;

    template &lt;typename... FPE&gt;
    destination_reserve_calc&lt;SizedOutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) &amp;&amp;;

    // <a href="#destination_reserve_calc_reserve">size reserve</a>
    constexpr destination_no_reserve&lt;SizedOutbuffCreator, FPack&gt;
    no_reserve() const &amp;;

    constexpr destination_no_reserve&lt;SizedOutbuffCreator, FPack&gt;
    no_reserve() &amp;&amp;;

    constexpr destination_with_given_size&lt;SizedOutbuffCreator, FPack&gt;
    reserve(std::size_t) const &amp;;

    constexpr destination_with_given_size&lt;SizedOutbuffCreator, FPack&gt;
    reserve(std::size_t) &amp;&amp;;

    constexpr destination_reserve_calc&amp;  reserve_calc() &amp;;
    constexpr destination_reserve_calc&amp;&amp; reserve_calc() &amp;&amp;;
    constexpr const destination_reserve_calc&amp;  reserve_calc() const &amp;;
    constexpr const destination_reserve_calc&amp;&amp; reserve_calc() const &amp;&amp;;

    // <a href="#destination_reserve_calc_printing">printing</a>
    template &lt;typename... Args&gt;
    /*...*/ operator()(const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(const char_type*, const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(const std::basic_string&lt;char_type&gt;&amp;, const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(std::basic_string_view&lt;char_type&gt;, const Args&amp;...) const;

private:
    OutbuffCreator _outbuff_creator; // exposition only
    FPack _fpack;                  // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="destination_reserve_calc_ctor">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
constexpr destination_reserve_calc(Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible"><em>DefaultConstructible</em></a></p>
</li>
<li>
<p><code>std::is_constructible&lt;OutbuffCreator, Args...&gt;::value</code> is <code>true</code>, otherwise this constructor does not participate on overload resolution.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>_outbuff_creator</code> with <code>std::forward&lt;Args&gt;(args)...</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_reserve_calc(const destination_reserve_calc&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Copy constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> and <code>OutbuffCreator</code> are
<a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_reserve_calc(destination_reserve_calc&amp;&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Move constructor.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_reserve_calc_with">Facets</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_reserve_calc&lt; OutbuffCreator
                        , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                       , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_reserve_calc</code> object whose <code>_outbuff_creator</code>
is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is initialized
with <code>pack(this-&gt;_fpack, std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_reserve_calc&lt; OutbuffCreator
                        , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                       , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_reserve_calc</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(this-&gt;_outbuff_creator)</code>, and whose <code>_fpack</code> is
initialized with <code>pack(std::move(this-&gt;_fpack), std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_reserve_calc_reserve">Size reserve</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_no_reserve&lt;OutbuffCreator, FPack&gt; no_reserve() const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_no_reserve</code> object whose <code>_outbuff_creator</code>
is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is
initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; reserve_calc() &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_no_reserve</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(_outbuff_creator)</code> from this object, and whose <code>_fpack</code> object is
initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
reserve(std::size_t size) const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> whose <code>_size</code> is initialized with <code>size</code>,
whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>, and whose <code>_fpack</code> is
initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size&lt;OutbuffCreator, FPack&gt;
reserve(std::size_t) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a>
   and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> object whose <code>_size</code> is initialized with <code>size</code>,
whose <code>_outbuff_creator</code> is initialized with <code>std::move(_outbuff_creator)  from this object,
and whose `_fpack</code> is initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_reserve_calc&amp;  reserve_calc() &amp;;
constexpr destination_reserve_calc&amp;&amp; reserve_calc() &amp;&amp;;
constexpr const destination_reserve_calc&amp;  reserve_calc() const &amp;;
constexpr const destination_reserve_calc&amp;&amp; reserve_calc() const &amp;&amp;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>None.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>This object.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_reserve_calc_printing">Printing</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
/*...*/ operator()(const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#PrintableWithSizePreview"><em>PrintableWithSizePreview</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creates an object <code>preview</code> of type
<code><a href="#print_preview">print_preview</a>&lt;preview_size::yes, preview_width::no&gt;</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">print_preview&lt;preview_size::yes, preview_width::no&gt; preview;</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>arg</code> in <code>args...</code>, creates a printer object by doing:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto p = static_cast&lt; const {printer}&lt;sizeof(CharT)&gt;&amp; &gt;
    ( <a href="#printer_impl">printer_impl</a>&lt;CharT, FPack, T&gt;{ _fpack, preview, arg, <a href="#tag">tag</a>&lt;CharT&gt;{} } )</code></pre>
</div>
</div>
</li>
<li>
<p>Creates/get the <a href="#basic_outbuff">outbuff</a> object doing</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">decltype(auto) ob = _outbuff_creator.create(preview.get_size())</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>p</code> object does <code>p.print_to(ob)</code></p>
</li>
<li>
<p>Returns <code>ob.finish()</code> if such expression is valid, which is optional. Otherwise the return type is <code>void</code>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const char_type* tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const std::basic_string_view&lt;char_type&gt;&amp; tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( std::basic_string_view&lt;char_type&gt; tr_string
          , const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#PrintableWithSizePreview"><em>PrintableWithSizePreview</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p><em>to-do</em></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="destination_with_given_size">2.3. Class template <code>destination_with_given_size</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename SizedOutbuffCreator, typename FPack = <a href="#facets_pack">facets_pack</a>&lt;&gt;&gt;
class destination_with_given_size</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is an instance of <a href="#facets_pack"><code>facets_pack</code></a>.</p>
</li>
<li>
<p><code>SizedOutbuffCreator</code> satisfies <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synopsis_4">2.3.1. Synopsis</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename SizedOutbuffCreator, typename FPack&gt;
class destination_with_given_size
{
public:
    using char_type = typename SizedOutbuffCreator::char_type;

    // <a href="#destination_with_given_size_ctor">constructors</a>
    template &lt;typename... Args&gt;
    constexpr destination_with_given_size(std::size_t, Args&amp;&amp;...);
    constexpr destination_with_given_size(const destination_with_given_size&amp;) = default;
    constexpr destination_with_given_size(destination_with_given_size&amp;&amp;) = default;

    // <a href="#destination_with_given_size_with">facets</a>
    template &lt;typename... FPE&gt;
    destination_with_given_size&lt;SizedOutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) const &amp;;

    template &lt;typename... FPE&gt;
    destination_with_given_size&lt;SizedOutbuffCreator, /*...*/&gt; with(FPE&amp;&amp;...) &amp;&amp;;

    // <a href="#destination_with_given_size_reserve">size reserve</a>
    constexpr destination_calc_size&lt;SizedOutbuffCreator, FPack&gt;
    reserve_calc() const &amp;;

    constexpr destination_calc_size&lt;SizedOutbuffCreator, FPack&gt;
    reserve_calc() &amp;&amp;;

    constexpr destination_no_reserve&lt;SizedOutbuffCreator, FPack&gt;
    no_reserve() const &amp;;

    constexpr destination_no_reserve&lt;SizedOutbuffCreator, FPack&gt;
    no_reserve() &amp;&amp;;

    constexpr destination_with_given_size&amp;  reserve(std::size_t) &amp;;
    constexpr destination_with_given_size&amp;&amp; reserve(std::size_t) &amp;&amp;;
    constexpr destination_with_given_size   reserve(std::size_t) const &amp;;
    constexpr destination_with_given_size   reserve(std::size_t) const &amp;&amp;;

    // <a href="#destination_with_given_size_printing">printing</a>
    template &lt;typename... Args&gt;
    /*...*/ operator()(const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(const char_type*, const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(const std::basic_string&lt;char_type&gt;&amp;, const Args&amp;...) const;

    template &lt;typename &#8230;&#8203; Args&gt;
    /*...*/ tr(std::basic_string_view&lt;char_type&gt;, const Args&amp;...) const;

private:
    std::size_t _size              // exposition only
    OutbuffCreator _outbuff_creator; // exposition only
    FPack _fpack;                  // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="destination_with_given_size_ctor">Constructors</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
constexpr destination_with_given_size(std::size_t size, Args&amp;&amp;... args);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/DefaultConstructible"><em>DefaultConstructible</em></a></p>
</li>
<li>
<p><code>std::is_constructible&lt;OutbuffCreator, Args...&gt;</code>, otherwise this constructor does not participate on overload resolution.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Initializes <code>_outbuff_creator</code> with <code>std::forward&lt;Args&gt;(args)...</code>.</p>
</li>
<li>
<p>Initializes <code>_size</code> with <code>size</code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size(const destination_with_given_size&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Copy constructor.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>FPack</code> and <code>OutbuffCreator</code> are
<a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size(destination_with_given_size&amp;&amp;) = default;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Move constructor.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_with_given_size_with">Facets</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_with_given_size&lt; OutbuffCreator
                           , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                          , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> object
whose <code>_size</code> is is initialized with this <code>_size</code>
, whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>
, and whose <code>_fpack</code> is initialized with <code>pack(this-&gt;_fpack, std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... FPE&gt;
/* see below */ with(FPE&amp;&amp;...) &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>FPE...</code> satisfy <a href="#FacetsPackElement"><em>FacetsPackElement</em></a>.</p>
</li>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Return Type</dt>
<dd>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">destination_with_given_size&lt; OutbuffCreator
                           , decltype(<a href="#pack">pack</a>( std::declval&lt;const FPack&amp;&gt;()
                                          , std::forward&lt;FPE&gt;(fpe)...) ) &gt;</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_with_given_size</code> object
whose <code>_size</code> is is initialized with this <code>_size</code>
, whose <code>_outbuff_creator</code> is initialized with <code>std::move(_outbuff_creator)</code> from this object
, and whose <code>_fpack</code> is initialized with
<code>pack(std::move(this-&gt;_fpack), std::forward&lt;FPE&gt;(fpe)...)</code></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_with_given_size_reserve">Size reserve</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_no_reserve&lt;OutbuffCreator, FPack&gt; no_reserve() const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a></p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_no_reserve</code> object
whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>,
and whose <code>_fpack</code> is initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; no_reserve() &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a></p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_no_reserve</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(_outbuff_creator)</code> from this object, and whose <code>_fpack</code> object is
initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; reserve_calc() const &amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_calc_size</code> object
whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>,
and whose <code>_fpack</code> is initialized with this <code>_fpack</code>.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_calc_size&lt;OutbuffCreator, FPack&gt; reserve_calc() &amp;&amp;;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>OutbuffCreator</code> is <a href="https://en.cppreference.com/w/cpp/named_req/MoveConstructible"><em>MoveConstructible</em></a>
and <a href="#SizedOutbuffCreator"><em>SizedOutbuffCreator</em></a>.</p>
</li>
<li>
<p><code>FPack</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p>Creates an <code>destination_calc_size</code> object whose <code>_outbuff_creator</code>
is initialized with <code>std::move(_outbuff_creator)</code> from this object, and whose <code>_fpack</code> object is
initialized with <code>std::move(_fpack)</code> from this object.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size&amp;  reserve(std::size_t size) &amp;;
constexpr destination_with_given_size&amp;&amp; reserve(std::size_t size) &amp;&amp;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>assign <code>size</code> to <code>_size</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return
</td>
<td class="hdlist2">
<p>This object.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr destination_with_given_size reserve(std::size_t size) const &amp;;
constexpr destination_with_given_size reserve(std::size_t size) const &amp;&amp;;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Creates an <code>destination_with_give_size</code> object
whose <code>_size</code> is initialized with <code>size</code>,
whose <code>_outbuff_creator</code> is initialized with this <code>_outbuff_creator</code>,
and whose <code>facets_pack</code> object with this <code>_fpack</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="destination_with_given_size_printing">Printing</h5>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename... Args&gt;
/*...*/ operator()(const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#Printable"><em>Printable</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Creates/get the <a href="#basic_outbuff">outbuff</a> object doing</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">decltype(auto) ob = _outbuff_creator.create(_size)</code></pre>
</div>
</div>
</li>
<li>
<p>For each <code>arg</code> in <code>args...</code>, creates a printer object by doing:</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto p = static_cast&lt; const {printer}&lt;sizeof(CharT)&gt;&amp; &gt;
    ( <a href="#printer_impl">printer_impl</a>&lt;CharT, FPack, T&gt;{fpack, preview, x, chtag} )</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code>preview</code> is an instance of <code>preview&lt;false, false&gt;</code>,
and <code>chtag</code> is an expression of type <code><a href="#tag">tag</a>&lt;CharT&gt;</code>.</p>
</div>
</li>
<li>
<p>For each <code>p</code> object does <code>p.print_to(ob)</code></p>
</li>
<li>
<p>Returns <code>ob.finish()</code> if such expression is valid, which is optional. Otherwise the return type is <code>void</code>.</p>
</li>
</ol>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const char_type* tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( const std::basic_string_view&lt;char_type&gt;&amp; tr_string
          , const Args&amp;... args) const;

template &lt;typename &#8230;&#8203; Args&gt;
/*...*/ tr( std::basic_string_view&lt;char_type&gt; tr_string
          , const Args&amp;... args) const;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Compile-time requirements</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>All types in <code>Args...</code> are <a href="#Printable"><em>Printable</em></a>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Effect</dt>
<dd>
<p><em>to-do</em></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="OutbuffCreator">2.4. Type requirement <em>OutbuffCreator</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char_type</code>, a character type</p>
</li>
<li>
<p><code>X</code>, an  <em>OutbuffCreator</em> type for <code>char_type</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></p>
</li>
<li>
<p><code>X</code> has a member type alias <code>T::char_type</code> defined as <code>char_type</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following expression must be satisfied:</p>
</div>
<div id="OutbuffCreator_create" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.create()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A type that derives from <code><a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;char_type&gt;</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="SizedOutbuffCreator">2.5. Type requirement <em>SizedOutbuffCreator</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>char_type</code>, a character type</p>
</li>
<li>
<p><code>size</code>, a value of the <code>std::size_t</code></p>
</li>
<li>
<p><code>X</code>, an  <em>OutbuffCreator</em> type for <code>char_type</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a></p>
</li>
<li>
<p><code>X</code> has a member type alias <code>T::char_type</code> defined as <code>char_type</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And the following expression must be satisfied:</p>
</div>
<div id="SizedOutbuffCreator_create" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.create(size)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A type that derives from <code><a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;char_type&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>ob.size() &gt;= size</code>, where <code>ob</code> is the returned value.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tr_string">3. Tr-String</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_syntax">3.1. Syntax</h3>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">A <code>'{'</code> followed by</th>
<th class="tableblock halign-left valign-top">until</th>
<th class="tableblock halign-left valign-top">means</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'-'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a comment</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">a digit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a positional argument reference</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">another <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the second <code>'{'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">an escaped <code>'{'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">any other character</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">the next <code>'}'</code> or end of string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a non positional argument reference</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="_examples">3.1.1. Examples:</h4>
<div class="listingblock">
<div class="title">Comments</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr
    ( "You can learn more about python{-the programming language, not the reptile} at {}"
    , "www.python.org" );
assert(str == "You can learn more about python at www.python.org");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Positional arguments</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("{1 a person} likes {0 a food type}.", "sandwich", "Paul");
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Non positional arguments</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("{a person} likes {a food type}.", "Paul", "sandwich");
assert(str == "Paul likes sandwich.");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escapes</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.tr("} {{x} {{{} {{{}}", "aaa", "bbb");
assert(str == "} {x} {aaa {bbb}");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_syntax_error_handling">3.1.2. Syntax error handling</h4>
<div class="paragraph">
<p>When the argument associated with a <code>"{"</code> does not exists, the library does two things:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It prints a <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character <code>"\uFFFD"</code> (&#65533;) </a> ( or <code>"?"</code> when the encoding can&#8217;t represent it ) where the missing argument would be printed.</p>
</li>
<li>
<p>It calls the <code>handle</code> function on the facet object correspoding to the <code>tr_error_notifier_c</code> category.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tr_error_notifier_c">3.2. Facet category <code>tr_error_notifier_c</code></h3>
<div class="paragraph">
<p>For a type to be a facet of the <code>tr_error_notifier_c</code>, it must satisfy the
requirements of <em><a href="#TrErrorHandling">TrErrorHandling</a></em></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

struct tr_error_notifier_c {
    static constexpr <a href="#default_tr_error_notifier">default_tr_error_notifier</a> get_default() noexcept
    {
        return <a href="#default_tr_error_notifier">default_tr_error_notifier</a>{};
    }
};

} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="default_tr_error_notifier">3.2.1. Struct <code>default_tr_error_notifier</code></h4>
<div class="paragraph">
<p><code>default_tr_error_notifier</code> is the default facet of the <code>tr_error_notifier_c</code> category.
It&#8217;s a dummy error handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

struct default_tr_error_notifier {
    using category = tr_error_notifier_c;

    template &lt;typename CharEncoding&gt;
    void handle
        ( const typename CharEncoding::char_type* str
        , std::size_t str_len
        , std::size_t err_pos
        , CharEncoding enc ) noexcept
    {
    }
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TrErrorHandling">3.2.2. Type requirement <em>TrErrorHandling</em></h4>
<div class="paragraph">
<p>Given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code>, a <em>TrErrorHandling</em> type</p>
</li>
<li>
<p><code>x</code>, a value of type <code>X</code></p>
</li>
<li>
<p><code>Enc</code>, a <em><a href="#CharEncodingFacet">CharEncodingFacet</a></em> type.</p>
</li>
<li>
<p><code>enc</code>, a value of type <code>Enc</code></p>
</li>
<li>
<p><code>str</code>, a value of type <code>const Enc::char_type*</code> pointing to string encoded according to <code>enc</code></p>
</li>
<li>
<p><code>str_len</code>, a <code>std::size_t</code> value equal to the length of the string <code>str</code></p>
</li>
<li>
<p><code>err_pos</code>, a <code>std::size_t</code> value less than or equal to <code>str_len</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must host:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
<li>
<p><code>X::category</code> is a type alias to <code>tr_error_notifier_c</code></p>
</li>
<li>
<p>The following expression is supported:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.handle(str, str_len, err_pos, enc)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Semantics
</td>
<td class="hdlist2">
<p><code>str</code> is a tr-string that contains an error. <code>err_pos</code> is the
position of the <code>'{'</code> character in <code>str</code> that starts the invalid argument reference.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_printable_types">4. printable types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_strings">4.1. Strings</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const CharT*</code>, <code>std::string_view&lt;CharT, Traits&gt;</code>
and <code>std::basic_string&lt;CharT, Traits, Alloc&gt;</code></p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<p>where:</p>
</dd>
<dt class="hdlist1"></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code> is the character type. If it is not the same as the output character type ( defined by the <a href="#destinations">destination</a> ), then it is necessary to use the <code>conv</code> or <code>sani</code> format function.</p>
</li>
<li>
<p><code>Traits</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/CharTraits">CharTraits</a></p>
</li>
<li>
<p><code>Alloc</code> can be any type that satisfies <a href="https://en.cppreference.com/w/cpp/named_req/Allocator">Allocator</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>p(<a href="#width_t">width_t</a> limit)</code></dt>
<dd>
<p>Does not print the whole string if its width is greater than <code>limit</code>,
but the greatest possible amount of its leading Unicode code points
such that the width is not greater than <code>limit</code>.</p>
</dd>
<dt class="hdlist1"><code>template &lt;typename Encoding&gt; sanitize_from_encoding(Encoding enc)</code></dt>
<dd>
<p>Translates input string from <code>enc</code> to the output encoding.
If the encodings are the same then sanitizes the input string.</p>
</dd>
<dt class="hdlist1"><code>sanitize_encoding()</code></dt>
<dd>
<p>Translates input string from the encoding associated to <code>CharT</code> to
the output encoding. If these encodings are the same
then sanitizes the input string.</p>
</dd>
<dt class="hdlist1"><code>template &lt;typename Encoding&gt; convert_from_encoding(Encoding enc)</code></dt>
<dd>
<p>Translates input string from <code>enc</code> to the
output encoding, if these encodings are not the same.
Otherwise, copies input string as it is.</p>
</dd>
<dt class="hdlist1"><code>convert_encoding()</code> </dt>
<dd>
<p>Translates input string from the encoding associated to <code>CharT</code> to
the output encoding, if these encodings are not the same.
Otherwise, copies the input string as it is.</p>
</dd>
<dt class="hdlist1"><code>template &lt;typename Encoding&gt;  sani(Encoding enc)</code></dt>
<dd>
<p>Equivanlent to <code>sanitize_encoding(enc)</code></p>
</dd>
<dt class="hdlist1"><code>template &lt;typename Encoding&gt;  conv(Encoding enc)</code></dt>
<dd>
<p>Equivanlent to <code>convert_encoding(enc)</code></p>
</dd>
<dt class="hdlist1"><code>sani()</code></dt>
<dd>
<p>Equivalent to <code>sanitize_encoding()</code></p>
</dd>
<dt class="hdlist1"><code>conv()</code></dt>
<dd>
<p>Equivalent to <code>convert_encoding()</code></p>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string(strf::center(u" Hello! ", 16, '*').conv());
assert(str == "**** Hello! ****");</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the section about <a href="#encoding_conversion">encoding conversion</a>.</p>
</div>
</dd>
</dl>
</div>
</dd>
</dl>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculator">width_calculator_c</a></code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#surrogate_policy">surrogate_policy_c</a></code></p>
</li>
<li>
<p><code><a href="#invalid_seq_policy">invalid_seq_policy_c</a></code></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_single_characters">4.2. Single characters</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p><code>CharT</code>, that is the output character type defined by the <a href="#destinations">destination</a>.</p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
</dd>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>multi(std::size_t count)</code>
</td>
<td class="hdlist2">
<p>Prints the character <code>count</code> times. Default value is <code>1</code>.</p>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#width_calculator">width_calculator_c</a></code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="__code_bool_code">4.3. <code>bool</code></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Type</dt>
<dd>
<p><code>bool</code></p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p><a href="#alignment_format_functions">Alignment functions</a> only.</p>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_functions">fill character</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="__code_const_void_code">4.4. <code>const void*</code></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>const void*</code></p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>The <a href="#alignment_format_functions">alignment functions</a> only.</p>
</dd>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;16&gt;</code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_functions">fill character</a> and the <a href="#numpunct">punctuation characters</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_integers">4.5. Integers</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>short</code>,
<code>int</code>,
<code>long int</code>,
<code>long long int</code>,
<code>unsigned short</code>,
<code>unsigned int</code>,
<code>unsigned long int</code> and
<code>unsigned long long int</code></p>
</dd>
</dl>
</div>
<div id="int_fmt" class="dlist">
<dl>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( in addition to <a href="#alignment_format_functions">alignment functions</a> )</p>
</dd>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>dec()</code>
</td>
<td class="hdlist2">
<p>Use decimal base ( This is already the default, though )</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>hex()</code>
</td>
<td class="hdlist2">
<p>Use hexadecimal base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>oct()</code>
</td>
<td class="hdlist2">
<p>Use octal base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>bin()</code>
</td>
<td class="hdlist2">
<p>Use binary base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>p(unsigned precision)</code>
</td>
<td class="hdlist2">
<p>Ensures that at least <code>precision</code> digits
are printed by adding extra zero leading digits if necessary.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator+()</code>
</td>
<td class="hdlist2">
<p>When in decimal base, prints the positive sign
<code>"+"</code> when value is non negative. No effect for other bases.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator*()</code>
</td>
<td class="hdlist2">
<p>Prints the base indication
( <code>"0x"</code> for hexadecimal, <code>"0"</code> for octal and <code>"0b"</code> for binary ).
No effect in decimal base.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator~()</code>
</td>
<td class="hdlist2">
<p>Equivalent to <code>operator*()</code>. Deprecated.</p>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;<em>Base</em>&gt;</code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_functions">fill character</a> and the <a href="#numpunct">punctuation characters</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_floating_points">4.6. Floating Points</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Types</dt>
<dd>
<p><code>float</code>, <code>double</code></p>
</dd>
<dt class="hdlist1">Format functions</dt>
<dd>
<p>( In addition to the <a href="#alignment_format_functions">alignment functions</a> )</p>
</dd>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>operator+()</code>
</td>
<td class="hdlist2">
<p>When in decimal base, prints the positive sign
<code>"+"</code> if the value is non negative. No effect for other bases.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator*()</code>
</td>
<td class="hdlist2">
<p>Prints the decimal point even when there
are no fractional digits.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator~()</code>
</td>
<td class="hdlist2">
<p>Equivalent to <code>operator*()</code>. Deprecated.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>sci()</code>
</td>
<td class="hdlist2">
<p>Prints in scientific notation, like this: <code>"1.2345e+02"</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>fixed()</code>
</td>
<td class="hdlist2">
<p>Prints in decimal notation, like this: <code>"123.45"</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>gen()</code>
</td>
<td class="hdlist2">
<p>This is the default notation.
When precision is unspecified ( or equal to <code>(unsigned)-1</code> )
prints in the scientfic notation if, and only if, it is shorter
than the fixed notation. Otherwise ( when precision is specified ),
does like in <code>std::printf</code>:
uses the scientfic notation if the exponent is less than -4 or greater
than or equal to the precision. Trailing fractional zeros are not printed.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>hex()</code>
</td>
<td class="hdlist2">
<p>Prints in hexadecimal notation, like this <code>"-0x1.abcd123e+5"</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>p(unsigned precision)</code>
</td>
<td class="hdlist2">
<p>If <code>precision == (unsigned)-1</code>, which is
the default, then prints the minimal amount of digits so that value
can be fully recovered by a parser. Otherwise, if notation is <em>general</em>,
<code>precision</code> is the number of significant digits. Otherwise, it is
the number of fractional digits. <code>precision == 0</code> has the same effect as
<code>precision == 1</code>.</p>
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Facet categories</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p><code><a href="#lettercase">lettercase_c</a></code></p>
</li>
<li>
<p><code><a href="#numpunct">numpunct_c</a>&lt;10&gt;</code></p>
</li>
<li>
<p><code><a href="#character_encoding">char_encoding_c</a>&lt;<em>CharType</em>&gt;</code>: Used to encode the <a href="#alignment_format_functions">fill character</a> and the <a href="#numpunct">punctuation characters</a>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_ranges">4.7. Ranges</h3>
<div class="sect3">
<h4 id="_without_formatting">4.7.1. Without formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ range(T (&amp;array)[N]);

template &lt;typename Iterator&gt;
/*...*/ range(const Iterator&amp; begin, const Iterator&amp; end);

// With operation

template &lt;typename Range, typename UnaryOperation&gt;
/*...*/ range(const Range&amp; r, UnaryOperation unary_op);

template &lt;typename T, std::size_t N, typename UnaryOperation&gt;
/*...*/ range(T (&amp;array)[N], UnaryOperation unary_op);

template &lt;typename Iterator, typename UnaryOperation&gt;
/*...*/ range( const Iterator&amp; begin
             , const Iterator&amp; end
             , UnaryOperation unary_op );

// With separator:

template &lt;typename Range, typename CharT&gt;
/*...*/ separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator );

// With separator and operation

template &lt;typename Range, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Range&amp; r
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename T, std::size_t N, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( T (&amp;array)[N]
                       , const CharT* separator
                       , UnaryOperation unary_op );

template &lt;typename Iterator, typename CharT, typename UnaryOperation&gt;
/*...*/ separated_range( const Iterator&amp; begin
                       , const Iterator&amp; end
                       , const CharT* separator
                       , UnaryOperation unary_op );
} // namespace strf</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Examples</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">int arr[3] = { 11, 22, 33 };

auto str = strf::to_string(strf::range(arr));
assert(str == "112233");

str = strf::to_string(strf::separated_range(arr, ", "));
assert(str == "11, 22, 33");

auto op = [](auto x){ return strf::<a href="#joins">join</a>('(', +strf::fmt(x * 10), ')'); };

str = strf::to_string(strf::separated_range(arr, ", ", op));
assert(str == "(+110), (+220), (+330)");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_formatting">4.7.2. With formatting</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename Range&gt;
/*...*/ fmt_range(const Range&amp; r);

template &lt;typename T, std::size_t N&gt;
/*...*/ fmt_range(T (&amp;array)[N], const Range&amp; r);

template &lt;typename Iterator&gt;
/*...*/ fmt_range(const Iterator&amp; begin, const Iterator&amp; end);

// With separator

template &lt;typename Range, typename CharT&gt;
/*...*/ fmt_separated_range(const Range&amp; r, const CharT* separator);

template &lt;typename T, std::size_t N, typename CharT&gt;
/*...*/ fmt_separated_range(T (&amp;array)[N], const CharT* separator);

template &lt;typename Iterator, typename CharT&gt;
/*...*/ fmt_separated_range( const Iterator&amp; begin
                           , const Iterator&amp; end
                           , const CharT* separator );
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any format function applicable to the element type of the
range can also be applied to the
expression <code>strf::fmt_range(/*...*/)</code> or
<code>strf::fmt_separated_range(/*...*/)</code>.
This way the format functions is applied to all elements:</p>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str1 = strf::to_string("[", +strf::fmt_separated_range(vec, " ;") &gt; 4, "]");
assert(str1 == "[ +11 ; +22 ; +33]");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::vector&lt;int&gt; vec = { 11, 22, 33 };
auto str2 = strf::to_string
    ( "["
    , *strf::fmt_separated_range(vec, " / ").fill('.').hex() &gt; 6,
    " ]");

assert(str2 == "[..0xfa / ..0xfb / ..0xfc]");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="joins">4.8. Joins</h3>
<div class="sect3">
<h4 id="_without_alignment">4.8.1. Without alignment</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename ... Args&gt;
/*...*/ join(const Args&amp; ... args);

}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_with_alignment">4.8.2. With alignment</h4>
<div class="paragraph">
<p>You can apply the <a href="#alignment_format_functions">alignment format functions</a>
one the return type of <code>join(args...)</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string
    ("---", strf::join("abc", "def", 123) &gt; 15, "---");

assert(str == "---      abcdef123---");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>split_pos</code> function specifies how many arguments
go before the fill when the <code>operator%</code> is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">str = strf::to_string
    ( strf::join('a', 'b', 'c', 'd', 'e', 'f').split_pos(2) % 10 );
assert(str == "ab    cdef");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions below provide an alternartive syntax to create aligned
join. Their return type has the <code>operator()(const Args&amp; ... args)</code> member function
that receives the elements of the join.</p>
</div>
<div id="text_alignment" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

enum class text_alignment {left, right, split, center};

/* ... */ join_align( std::int16_t width
                    , text_alignment align
                    , char32_t fillchar = U' '
                    , std::ptrdiff_t split_pos = 0 );
/* ... */ join_center(int width, char32_t fillchar = U' ');
/* ... */ join_left(int width, char32_t fillchar = U' ');
/* ... */ join_right(int width, char32_t fillchar = U' ');
/* ... */ join_split(int width, int split_pos);
/* ... */ join_split( std::int16_t width
                    , char32_t fillchar
                    , std::ptrdiff_t split_pos );
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string
    ("---", strf::join_right(15) ("abc", "def", 123), "---");
assert(str == "---      abcdef123---");

str = strf::to_string
    ("---", strf::join_center(15) ("abc", "def", 123), "---");
assert(str == "---   abcdef123   ---");

str = strf::to_string
    ( "---"
    , strf::join_left(15, U'.') ("abc", strf::right("def", 5), 123)
    , "---" );
assert(str == "---abc  def123....---");

str = strf::to_string
    ( "---"
    , strf::join_split(15, '.', 1) (strf::left("abc", 5), "def", 123)
    , "---" );
assert(str == "---abc  ....def123---");</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="global_function_with">4.9. Facets</h3>
<div class="paragraph">
<p>It is possible to <a href="#facet_overriding">override facets</a>
to only a subset of the input arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt; typename FPack &gt;
class inner_pack
{
public:
    template &lt;typename... Args&gt;
    /*...*/  operator()(const Args&amp;... args) const;
    //...
};

template &lt;typename ... Facets&gt;
inner_pack&lt;/*...*/&gt; with(const Facets&amp;... facets);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 1</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto str = strf::to_string.with(strf::numpunct&lt;10&gt;(1))
    ( 10000
    , "  "
    , strf::hex(0x10000)
    , strf::with( strf::numpunct&lt;10&gt;(3)
                , strf::numpunct&lt;16&gt;(4).thousands_sep('\'') )
        ( "  { "
        , 10000
        , "  "
        , strf::hex(0x10000)
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000 }");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 2</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">auto fp = strf::pack
    ( strf::numpunct&lt;10&gt;(3)
    , strf::numpunct&lt;16&gt;(4).thousands_sep('\'') );

auto str = strf::to_string.with(strf::numpunct&lt;10&gt;(1))
    ( 10000
    , "  "
    , strf::hex(0x10000)
    , strf::with(fp)
        ( "  { "
        , 10000
        , "  "
        , strf::hex(0x10000)
        , strf::with
            (strf::numpunct&lt;10&gt;(2).thousands_sep('.'))
            ("  { ", 10000, " }")
        , " }" ) );

assert(str == "1,0,0,0,0  10000  { 10,000  1'0000  { 1.00.00 } }");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_character_encodings">5. Character encodings</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="char_encoding_id">5.1. Enumeration <code>char_encoding_id</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
enum class char_encoding_id : unsigned { };

constexpr char_encoding_id  eid_ascii        = /* ... */;
constexpr char_encoding_id  eid_utf8         = /* ... */;
constexpr char_encoding_id  eid_utf16        = /* ... */;
constexpr char_encoding_id  eid_utf32        = /* ... */;
constexpr char_encoding_id  eid_iso_8859_1   = /* ... */;
constexpr char_encoding_id  eid_iso_8859_3   = /* ... */;
constexpr char_encoding_id  eid_iso_8859_15  = /* ... */;
constexpr char_encoding_id  eid_windows_1252 = /* ... */;

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="invalid_seq_notifier_c">5.2. Facet category <code>invalid_seq_notifier_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
struct invalid_seq_notifier_c {
    static constexpr bool constrainable = false;
    static constexpr <a href="#invalid_seq_notifier">invalid_seq_notifier</a> get_default() noexcept {
        return {}
    }
};
} // namespace strf</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="invalid_seq_notifier">5.2.1. Class invalid_seq_notifier</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

class invalid_seq_notifier {
public:

    using category = invalid_seq_notifier_c;

    typedef void(*notify_fptr)();

    constexpr invalid_seq_notifier() noexcept = default;
    constexpr invalid_seq_notifier(const invalid_seq_notifier&amp;) noexcept = default;

    constexpr explicit invalid_seq_notifier(notify_fptr) noexcept;
    constexpr invalid_seq_notifier&amp; operator=(notify_fptr) noexcept;
    constexpr invalid_seq_notifier&amp; operator=(const invalid_seq_notifier&amp; other) noexcept;
    constexpr bool operator==(const invalid_seq_notifier&amp; other) noexcept;
    constexpr operator bool() const noexcept;
    constexpr void notify() const noexcept;

private:
    notify_fptr notify_func_ = nullptr; // exposition only
};

} // namespace strf</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr invalid_seq_notifier() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial default constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Poscondition
</td>
<td class="hdlist2">
<p><code>notify_func_ == nullptr</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr invalid_seq_notifier(const invalid_seq_notifier&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Poscondition
</td>
<td class="hdlist2">
<p><code>notify_func_ == other.notify_func_</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr explicit invalid_seq_notifier(notify_fptr fptr) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Poscondition
</td>
<td class="hdlist2">
<p><code>notify_func_ == fptr</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr invalid_seq_notifier&amp; operator=(const invalid_seq_notifier&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Poscondition
</td>
<td class="hdlist2">
<p><code>notify_func_ == other.notify_func_</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr bool operator==(const invalid_seq_notifier&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>notify_func_ == other.notify_func_</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr operator bool() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>notify_func_ != nullptr</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr void notify() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>notify_func_</code> if it is not null.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="surrogate_policy">5.3. Facet category <code>surrogate_policy_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">enum class surrogate_policy : bool { strict = false, lax = true };

struct surrogate_policy_c {
    static constexpr bool constrainable = false;
    static constexpr surrogate_policy get_default() noexcept {
        return surrogate_policy::strict;
    }
};

template &lt;&gt;
class facet_traits&lt;surrogate_policy&gt; {
public:
    using category = surrogate_policy_c;
    static constexpr bool store_by_value = true;
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_semantics">5.3.1. Semantics</h4>
<div class="paragraph">
<p>This facet enables you to choose whether a nonconformant presence of a
surrogate character shall be treated as invalid.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="char_encoding_function_pointers">5.4. Aliases for pointers to functions</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr std::size_t invalid_char_len = (std::size_t)-1;

template &lt;std::size_t SrcCharSize, std::size_t DestCharSize&gt;
using transcode_f = void (*)
    ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;DestCharSize&gt;&amp; ob
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#invalid_seq_notifier">invalid_seq_notifier</a> inv_seq_notifier
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli );

template &lt;std::size_t SrcCharSize&gt;
using transcode_size_f = std::size_t (*)
    ( const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli );

template &lt;std::size_t CharSize&gt;
using write_replacement_char_f = void (*) ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; );

using validate_f = std::size_t (*)(char32_t ch);

using encoded_char_size_f = std::size_t (*) (char32_t ch);

template &lt;std::size_t CharSize&gt;
using encode_char_f = <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;*(*)
    ( <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* dest, char32_t ch );

template &lt;std::size_t CharSize&gt;
using encode_fill_f = void (*)
    ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp;, std::size_t count, char32_t ch );

struct codepoints_count_result {
    std::size_t count;
    std::size_t pos;
};

template &lt;std::size_t CharSize&gt;
using codepoints_fast_count_f =
    codepoints_count_result (*)
    ( const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* src
    , std::size_t src_size
    , std::size_t max_count );

template &lt;std::size_t CharSize&gt;
using codepoints_robust_count_f =
    codepoints_count_result (*)
    ( const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* src
    , std::size_t src_size
    , std::size_t max_count
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli );

template &lt;std::size_t CharSize&gt;
using decode_char_f = char32_t (*) ( <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt; );

template &lt;std::size_t SrcCharSize, std::size_t DestCharSize&gt;
using find_transcoder_f =
    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;SrcCharSize, DestCharSize&gt; (*) ( <a href="#char_encoding_id">char_encoding_id</a> );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="UnderlyingTranscoder">5.5. Type requirement <em>UnderlyingTranscoder</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SrcCharSize</code>, a <code>constexpr std::size_t</code> value equal to <code>1</code>, <code>2</code> or <code>4</code></p>
</li>
<li>
<p><code>DestCharSize</code>, a <code>constexpr std::size_t</code> value equal to <code>1</code>, <code>2</code> or <code>4</code></p>
</li>
<li>
<p><code>SrcCharType</code>, the type of <code><a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;</code></p>
</li>
<li>
<p><code>X</code>, a <em>UnderlyingTranscoder</em> type from <code>SrcCharSize</code> to <code>DestCharSize</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
<li>
<p><code>dest</code>, an lvalue reference of type <code><a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;DestCharSize&gt;</code></p>
</li>
<li>
<p><code>src</code>, a value of type <code>const SrcCharType*</code></p>
</li>
<li>
<p><code>src_size</code>, a value of type <code>std::size_t</code> equal to the size of
the array pointed by <code>src</code></p>
</li>
<li>
<p><code>inv_seq_notifier</code>, a value of type <code><a href="#invalid_seq_notifier">invalid_seq_notifier</a></code></p>
</li>
<li>
<p><code>surr_poli</code>, a value of type <code><a href="#surrogate_policy">surrogate_policy</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a>.</p>
</li>
<li>
<p><code>X</code> supports the following syntax and semantics:</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.transcode_size(src, src_size, surr_poli)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::size_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The number of character that
<code>x.transcode(dest, src, src_size, <a href="#invalid_seq_notifier">invalid_seq_notifier</a>{}, surr_poli)</code>
would write into <code>dest</code>, or a value a greater than that if such exact calculation is
difficult ( but ideally not much greater ).</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>x.transcode_func() != nullptr</code> is <code>true</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingTranscoder_transcode" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.transcode(dest, src, src_size, inv_seq_notifier, surr_poli)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Converts the content of <code>src</code> from one encoding to another writing
the result to <code>dest</code>. Each sequence in <code>src</code> that is invalid is
translated instead by the replacement character ( that is returned by
<code><a href="#UnderlyingCharEncoding_replacement_char">x.replacement_char()</a></code>.
And each time that happens, <code>inv_seq_notifier.notify()</code> shall be called
if the value of <code>(bool)inv_seq_notifier</code> is <code>true</code>.
A sequence in <code>src</code> is considered invalid if is non-conformant
to its corresponding encoding or would cause content written in <code>dest</code>
to be non-conformant to the destination encoding, unless such
non-conformity is due to a surrogate character and the value
of <code>surr_poli</code> is <code>surrogate_policy::lax</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Precondition
</td>
<td class="hdlist2">
<p><code>x.transcode_func() != nullptr</code> is <code>true</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<p><code>dest.recycle()</code> is not called() if
<code>dest.size() &gt;= x.transcode_size(src, src_size, surr_poli)</code> is <code>true</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingTranscoder_transcode_size_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.transcode_size_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">transcode_size_f</a>&lt;SrcCharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.transcode_size_func() (src, src_size, surr_poli)</code> has the same
effect as <code>x.transcode_size(src, src_size, surr_poli)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingTranscoder_transcode_func" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.transcode_func()</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">transcode_f</a>&lt;SrcCharSize, DestCharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that
<code>x.transcode_func() (dest, src, src_size, inv_seq_notifier, surr_poli)</code>
has the same effect as
<code>x.transcode(dest, src, src_size, inv_seq_notifier, surr_poli)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<hr>
<div id="UnderlyingTranscoder_null" class="exampleblock">
<div class="content">
<div class="paragraph">
<div class="title">Definition</div>
<p>A <strong>null transcoder</strong> is an object of an <em>UnderlyingTranscoder</em>
type where the <code>transcode_func</code> function returns <code>nullptr</code>.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two class templates that satisfy <em>UnderlyingTranscoder</em>: <code><a href="#static_underlying_transcoder">static_underlying_transcoder</a></code> and <code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a></code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="UnderlyingCharEncoding">5.6. Type requirement <em>UnderlyingCharEncoding</em></h3>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharSize</code>, a <code>constexpr std::size_t</code> value equal to <code>1</code>, <code>2</code>, or ( UTF-32 only ) <code>4</code></p>
</li>
<li>
<p><code>char_type</code>, the type of <code><a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;&amp;</code></p>
</li>
<li>
<p><code>ptr</code>, a value of type <code>char_type*</code></p>
</li>
<li>
<p><code>src</code>, a value of type <code>const char_type*</code></p>
</li>
<li>
<p><code>src_size</code>, a value of type <code>std::size_t</code> equal to the size of
the array pointed by <code>src</code></p>
</li>
<li>
<p><code>count</code>, a value of type <code>std::size_t</code></p>
</li>
<li>
<p><code>max_count</code>, a value of type <code>std::size_t</code></p>
</li>
<li>
<p><code>ch32</code>, a value of type <code>char32_t</code></p>
</li>
<li>
<p><code>ch</code>, a value of type <code>char_type</code></p>
</li>
<li>
<p><code>ob</code>, an lvalue reference of type <code><a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;</code></p>
</li>
<li>
<p><code>enc_id</code>, value of type <code><a href="#char_encoding_id">char_encoding_id</a></code></p>
</li>
<li>
<p><code>X</code>, a <em>UnderlyingCharEncoding</em> type for value <code>CharSize</code></p>
</li>
<li>
<p><code>x</code>, an expression of type <code>X</code> or <code>const X</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>X</code> must be <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible">CopyConstructible</a>
and satisfy the expressions below:</p>
</div>
<div id="UnderlyingCharEncoding_char_size" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">X::char_size</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Type
</td>
<td class="hdlist2">
<p><code>std::size_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Value
</td>
<td class="hdlist2">
<p><code>CharSize</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>It is <code>constexpr</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_id" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.id()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_id">char_encoding_id</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The <code><a href="#char_encoding_id">char_encoding_id</a></code> that corresponds to this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.name()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>const char*</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The name of this encoding. Examples: <code>"UTF-8"</code>, <code>"ASCII"</code>, <code>"ISO-8859-1"</code>, <code>"windows-1252"</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_replacement_char" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.replacement_char()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The character used to signalize an error. Usually it is the <a href="https://en.wikipedia.org/wiki/Specials_(Unicode_block)#Replacement_character">replacement character &#xFFFD;</a> if it is supported by this encoding, or the question mark <code>'?'</code> otherwise.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.write_replacement_char(ob)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>Writes into <code>ob</code> the codepoint returned by <code>x.replacement_char()</code> encoded in this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.replacement_char_size()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::size_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The number of characters that <code>x.write_replacement_char(ob)</code> writes into <code>ob</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.encoded_char_size(ch32)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::size_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The size of the string containing the UTF-32 character <code>ch32</code>,
if <code>ch32</code> is supported in this encoding. Otherwise, same as
<code>x.replacement_char_size()</code> otherwise.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This function does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, this function considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.validate(ch32)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>std::size_t</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The size of the string containing the UTF-32 character <code>ch32</code>,
if <code>ch32</code> is supported in this encoding. Otherwise, <code>(std::size_t)-1</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.encode_char(ptr, ch32)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes into <code>ptr</code> the UTF-32 character <code>ch32</code> encoded into this encoding,
adopting the policy of <code><a href="#surrogate_policy">surrogate_policy</a>::lax</code>,
<em>i.e.</em> if <code>ch32</code> is a surrogate, treat it as if it were a valid codepoint.
If this encoding is not able to encode <code>ch32</code>,
then encode instead the return of <code>x.replacement_char()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char_type*</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The position just after the last writen character.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>This function does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, this function considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.encode_fill(ob, count, ch32)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes <code>count</code> times into <code>ob</code> the UTF-32 character <code>ch32</code> encoded into
this encoding, if it is supported. Otherwise writes <code>x.replacement_char()</code>
instead.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>void</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p><code>encode_fill</code> does not check whether <code>ch32</code> is a legal code point, only if
it is possible to write it in this encoding. For example, if this is encoding
is UTF-32, <code>encode_fill</code> considers as valid any value for <code>ch32</code> ( even if
is is greater than <code>0x10FFFF</code> ). Surrogates characters are also not sanitized.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_codepoints_fast_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.codepoints_fast_count(src, src_size, max_count)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">codepoints_count_result</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>{c, pos}</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>c</code> is the number of Unicode code points in <code>src</code>,
if such value is less than <code>max_count</code>.
Otherwise, <code>c</code> is equal to <code>max_count</code>.</p>
</li>
<li>
<p><code>pos</code> is such that the number of codepoints in
<code>src</code> is equal to <code>c</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>c &lt;= max_count</code> is <code>true</code></p>
</li>
<li>
<p><code>pos &lt;= src_size</code> is <code>true</code></p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Note
</td>
<td class="hdlist2">
<p>If the input is non-conformant to the corresponding character encoding,
this function may return an incorrect value. For instance, for UTF-8
this function may simply count the bytes that are not continuation bytes.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_codepoints_robust_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.codepoints_robust_count(src, src_size, max_count, surr_poli)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Counts the codepoints until is equal to <code>max_count</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">codepoints_count_result</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>{c, pos}</code>, where:</p>
<div class="ulist">
<ul>
<li>
<p><code>c</code> is equal to <code>std::min(max_count, u32len)</code>, where <code>u32len</code> is the
length of the UTF-32 string that would be generated by converting
<code>src</code> from this encoding to UTF-32,
<a href="#surrogate_policy">according to <code>surr_poli</code></a>.</p>
</li>
<li>
<p><code>pos</code> is such that the value of
<code>x.codepoints_robust_count(src, pos, (std::size_t)-1, surr_poli).count</code>
 is equal to <code>c</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
<tr>
<td class="hdlist1">
Posconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>c &lt;= max_count</code> is <code>true</code></p>
</li>
<li>
<p><code>pos &lt;= src_size</code> is <code>true</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="CharEncoding_decode_char" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.decode_char(ch)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Decodes <code>ch</code> from this encoding to UTF-32
assuming the policy of <code><a href="#surrogate_policy">surrogate_policy::lax</a></code>.
If <code>ch</code> is an invalid character, return <code>x.replacement_char()</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code>char32_t</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.encode_char_func()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">encode_char_f</a>&lt;CharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.encode_char_func() (ch32)</code> has
the same effect as <code>x.encode_char(ch32)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.encode_fill_func()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">encode_fill_f</a>&lt;CharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.encode_fill_func() (ob, count, ch32)</code>
has the same effect as <code>x.encode_fill(ob, count, ch32)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.write_replacement_char_func()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#char_encoding_function_pointers">write_replacement_char_f</a>&lt;CharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A function pointer such that <code>x.write_replacement_char_func() (ob)</code>
has the same effect as <code>x.write_replacement_char(ob)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_from_u32" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.from_u32()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#UnderlyingTranscoder">UnderlyingTranscoder</a></em> from <code>4</code> to <code>CharSize</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts UTF-32 to this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_to_u32" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.to_u32()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#UnderlyingTranscoder">UnderlyingTranscoder</a></em> from <code>CharSize</code> to <code>4</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to UTF-32.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_sanitizer" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.sanitizer()</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p>A <em><a href="#UnderlyingTranscoder">UnderlyingTranscoder</a></em> from <code>CharSize</code> to <code>CharSize</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that "converts" this encoding to this encoding,
<em>i.e.</em> a sanitizer of this encoding.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_find_transcoder_to" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.find_transcoder_to(std::integral_constant&lt;std::size_t, 1&gt;, enc_id)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 1&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to the encoding
corresponding to <code>enc_id</code>, or an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.find_transcoder_to(std::integral_constant&lt;std::size_t, 2&gt;, enc_id)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 2&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts this encoding to the encoding
corresponding to <code>enc_id</code>, or an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="UnderlyingCharEncoding_find_transcoder_from" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.find_transcoder_from&lt;ScrCharSize&gt;(std::integral_constant&lt;std::size_t, 1&gt;, enc_id)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;1, CharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts the encoding  corresponding to
<code>enc_id</code> to this encoding, or an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">( Optional )</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.find_transcoder_from&lt;ScrCharSize&gt;(std::integral_constant&lt;std::size_t, 1&gt;, enc_id)</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"></dt>
</dl>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;2, CharSize&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A transcoder that converts the encoding  corresponding to
<code>enc_id</code> to this encoding, or an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You shall not create an <em>UnderlyingCharEncoding</em> type with <code>CharSize</code>
           equal to <code>4</code>, since this is reserved for UTF-32.
           The library internaly assumes in many occasions that the encoding
           is UTF-32 when <code>CharSize</code> is equal to <code>4</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two class templates that satisfy <em>UnderlyingCharEncoding</em>: <code><a href="#static_underlying_transcoder">static_underlying_transcoder</a></code> and <code><a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a></code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="static_underlying_transcoder">5.7. Class template <code>static_underlying_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;<a href="#char_encoding_id">char_encoding_id</a> Src, <a href="#char_encoding_id">char_encoding_id</a> Dest&gt;
class static_underlying_transcoder;

template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_ascii</a>, <a href="#char_encoding_id">eid_ascii</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_ascii</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_ascii</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_1</a>, <a href="#char_encoding_id">eid_iso_8859_1</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_1</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_iso_8859_1</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_3</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_iso_8859_3</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_3</a>, <a href="#char_encoding_id">eid_iso_8859_3</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_15</a>, <a href="#char_encoding_id">eid_iso_8859_15</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_iso_8859_15</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_iso_8859_15</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_windows_1252</a>, <a href="#char_encoding_id">eid_windows_1252</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_windows_1252</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_windows_1252</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf8</a>, <a href="#char_encoding_id">eid_utf8</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf8</a>, <a href="#char_encoding_id">eid_utf16</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf8</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf16</a>, <a href="#char_encoding_id">eid_utf8</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf16</a>, <a href="#char_encoding_id">eid_utf16</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf16</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_utf8</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_utf16</a>&gt;;
template &lt;&gt; static_underlying_transcoder&lt;<a href="#char_encoding_id">eid_utf32</a>, <a href="#char_encoding_id">eid_utf32</a>&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no generic implementation of the <code>static_underlying_transcoder</code> class template.
Instead, there are only template specializations for some pairs of encodings.
All of them are empty classes, and are <em><a href="#UnderlyingTranscoder">UnderlyingTranscoder</a></em>, and their
member functions <code><a href="#UnderlyingTranscoder_transcode_func">transcode_func</a></code>
and <code><a href="#UnderlyingTranscoder_transcode_size_func">transcode_size_func</a></code>
never return <code>nullptr</code></p>
</div>
</div>
<div class="sect2">
<h3 id="static_underlying_char_encoding">5.8. Class template <code>static_underlying_char_encoding</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;<a href="#char_encoding_id">char_encoding_id</a>&gt;
class static_underlying_char_encoding;

template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_utf8</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_utf16</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_utf32</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_ascii</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_iso_8859_1</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_iso_8859_3</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_iso_8859_15</a>&gt;;
template &lt;&gt; class static_underlying_char_encoding&lt;<a href="#char_encoding_id">eid_windows_1252</a>&gt;;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no generic implementation of the <code>static_underlying_char_encoding</code> class template.
Instead, the library provides template specializations for some encodings.
All of them are empty classes, and are <em><a href="#UnderlyingCharEncoding">UnderlyingCharEncoding</a></em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_underlying_transcoder">5.9. Class template <code>dynamic_underlying_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;std::size_t SrcCharSize, std::size_t DestCharSize&gt;
class dynamic_underlying_transcoder {
public:
    constexpr dynamic_underlying_transcoder() noexcept;

    constexpr dynamic_underlying_transcoder
        ( const dynamic_underlying_transcoder&amp; other) noexcept = default;

    template &lt;<a href="#char_encoding_id">char_encoding_id</a> Src, <a href="#char_encoding_id">char_encoding_id</a> Dest&gt;
    constexpr explicit dynamic_underlying_transcoder
        ( <a href="#static_underlying_transcoder">static_underlying_transcoder</a>&lt;Src, Dest&gt; st );

    void transcode
        ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;DestCharSize&gt;&amp; ob
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
        , std::size_t src_size
        , <a href="#invalid_seq_notifier">invalid_seq_notifier</a> inv_seq_notifier
        , <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;

    std::size_t transcode_size
        ( const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
        , std::size_t src_size
        , <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;

    constexpr <a href="#char_encoding_function_pointers">transcode_f</a>&lt;SrcCharSize, DestCharSize&gt; transcode_func() const noexcept;
    constexpr <a href="#char_encoding_function_pointers">transcode_size_f</a>&lt;SrcCharSize&gt; transcode_size_func() const noexcept;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr dynamic_underlying_transcoder() noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == nullptr</code></p>
</li>
<li>
<p><code>transcode_size_func() == nullptr</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr dynamic_underlying_transcoder
    ( const dynamic_underlying_transcoder&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == other.transcode_func()</code></p>
</li>
<li>
<p><code>transcode_size_func() == other.transcode_size_func()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;<a href="#char_encoding_id">char_encoding_id</a> Src, <a href="#char_encoding_id">char_encoding_id</a> Dest&gt;
constexpr explicit dynamic_underlying_transcoder
    ( <a href="#static_underlying_transcoder">static_underlying_transcoder</a>&lt;Src, Dest&gt; other );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postconditions
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>transcode_func() == other.transcode_func()</code></p>
</li>
<li>
<p><code>transcode_size_func() == other.transcode_size_func()</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void transcode
    ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;DestCharSize&gt;&amp; ob
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#invalid_seq_notifier">invalid_seq_notifier</a> inv_seq_notifier
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Effect: Calls <code>transcode_func()(ob, src, src_size, inv_seq_notifier, surr_poli)</code></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::size_t transcode_size
    ( const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Effect: Calls <code>transcode_size_func()(src, src_size, surr_poli)</code></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_underlying_char_encoding_data">5.10. Struct template <code>dynamic_underlying_char_encoding_data</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
struct dynamic_underlying_char_encoding_data {
    const char* name;
    <a href="#char_encoding_id">char_encoding_id</a> id;
    char32_t replacement_char;
    std::size_t replacement_char_size;
    <a href="#char_encoding_function_pointers">validate_f</a> validate_func;
    <a href="#char_encoding_function_pointers">encoded_char_size_f</a> encoded_char_size_func;
    <a href="#char_encoding_function_pointers">encode_char_f</a>&lt;CharSize&gt; encode_char_func;
    <a href="#char_encoding_function_pointers">encode_fill_f</a>&lt;CharSize&gt; encode_fill_func;
    <a href="#char_encoding_function_pointers">codepoints_fast_count_f</a>&lt;CharSize&gt; codepoints_fast_count_func;
    <a href="#char_encoding_function_pointers">codepoints_robust_count_f</a>&lt;CharSize&gt; codepoints_robust_count_func;

    <a href="#char_encoding_function_pointers">write_replacement_char_f</a>&lt;CharSize&gt; write_replacement_char_func;
    <a href="#char_encoding_function_pointers">decode_char_f</a>&lt;CharSize&gt; decode_char_func;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;4, CharSize&gt; from_u32;
    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 4&gt; to_u32;
    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, CharSize&gt; sanitizer;

    <a href="#char_encoding_function_pointers">find_transcoder_f</a>&lt;1, CharSize&gt; transcoder_from_1byte_encoding;
    <a href="#char_encoding_function_pointers">find_transcoder_f</a>&lt;2, CharSize&gt; transcoder_from_2bytes_encoding;

    <a href="#char_encoding_function_pointers">find_transcoder_f</a>&lt;CharSize, 1&gt; transcoder_to_1byte_encoding;
    <a href="#char_encoding_function_pointers">find_transcoder_f</a>&lt;CharSize, 2&gt; transcoder_to_2bytes_encoding;
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_underlying_char_encoding">5.11. Class template <code>dynamic_underlying_char_encoding</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
class dynamic_underlying_char_encoding {
public:

    static constexpr std::size_t char_size = CharSize;

    dynamic_underlying_char_encoding(const dynamic_underlying_char_encoding&amp; other) = default;

    dynamic_underlying_char_encoding
        ( const <a href="#dynamic_underlying_char_encoding_data">dynamic_underlying_char_encoding_data</a>&lt;CharSize&gt;&amp; d );

    dynamic_underlying_char_encoding&amp; operator=(const dynamic_underlying_char_encoding&amp; other) noexcept;

    bool operator==(const dynamic_underlying_char_encoding&amp; other) const noexcept;

    bool operator!=(const dynamic_underlying_char_encoding&amp; other) const noexcept;

    void swap(dynamic_underlying_char_encoding&amp; other) noexcept;

    const char* name() const noexcept;

    constexpr <a href="#char_encoding_id">char_encoding_id</a> id() const noexcept;

    constexpr char32_t replacement_char() const noexcept;

    constexpr std::size_t replacement_char_size() const noexcept;

    constexpr std::size_t validate(char32_t ch) const; // noexcept

    constexpr std::size_t encoded_char_size(char32_t ch) const; // noexcept

    char_type_* encode_char(char_type_* dest, char32_t ch) const; // noexcept

    void encode_fill
        ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob, std::size_t count, char32_t ch ) const;

    std::size_t codepoints_fast_count
        ( const char_type_* src, std::size_t src_size
        , std::size_t max_count ) const;

    std::size_t codepoints_robust_count
        ( const char_type_* src, std::size_t src_size
        , std::size_t max_count, <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;

    void write_replacement_char(<a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob) const;

    char32_t decode_char(char_type_ ch) const;

    <a href="#char_encoding_function_pointers">encode_char_f</a>&lt;char_size&gt; encode_char_func() const noexcept;

    <a href="#char_encoding_function_pointers">encode_fill_f</a>&lt;char_size&gt; encode_fill_func() const noexcept;

    <a href="#char_encoding_function_pointers">write_replacement_char_f</a>&lt;char_size&gt; write_replacement_char_func() const noexcept;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;4, CharSize&gt; from_u32() const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 4&gt; to_u32() const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, CharSize&gt; sanitizer() const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 1&gt; find_transcoder_to
        ( std::integral_constant&lt;std::size_t, 1&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 2&gt; find_transcoder_to
        ( std::integral_constant&lt;std::size_t, 2&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;1, CharSize&gt; find_transcoder_from
        ( std::integral_constant&lt;std::size_t, 1&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;

    <a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;2, CharSize&gt; find_transcoder_from
        ( std::integral_constant&lt;std::size_t, 2&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;

private:

    const <a href="#dynamic_underlying_char_encoding_data">dynamic_underlying_char_encoding_data</a>* data; // exposition only
};</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">dynamic_underlying_char_encoding(const dynamic_underlying_char_encoding&amp; other);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">dynamic_underlying_char_encoding
        ( const <a href="#dynamic_underlying_char_encoding_data">dynamic_underlying_char_encoding_data</a>&lt;CharSize&gt;&amp; d );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = d</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">dynamic_underlying_char_encoding&amp; operator=(const dynamic_underlying_char_encoding&amp; other) noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p><code>this-&gt;data = other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">bool operator==(const dynamic_underlying_char_encoding&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data == other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">bool operator!=(const dynamic_underlying_char_encoding&amp; other) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data != other.data</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void swap(dynamic_underlying_char_encoding&amp; other) noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>std::swap(this-&gt;data, other.data)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">const char* name() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;name</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr <a href="#char_encoding_id">char_encoding_id</a> id() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;id</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr char32_t replacement_char() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;replacement_char</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr std::size_t replacement_char_size() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;replacement_char_size</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr std::size_t validate(char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;validate_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">constexpr std::size_t encoded_char_size(char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;encoded_char_size_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char_type_* encode_char(char_type_* dest, char32_t ch) const; // noexcept</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;encoded_char_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void encode_fill
    ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob, std::size_t count, char32_t ch ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns
<code>this-&gt;data-&gt;encode_fill_func(ob, count, ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::size_t codepoints_fast_count
    ( const char_type_* src, std::size_t src_size
    , std::size_t max_count ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;codepoints_fast_count_func(src, src_size, max_count)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">std::size_t codepoints_robust_count
    ( const char_type_* src, std::size_t src_size
    , std::size_t max_count, <a href="#surrogate_policy">surrogate_policy</a> surr_poli ) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns
<code>this-&gt;data-&gt;codepoints_robust_count_func(src, src_size, max_count, surr_poli)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void write_replacement_char(<a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls <code>this-&gt;data-&gt;write_replacement_char_func(ob)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">char32_t decode_char(char_type_ ch) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calls and returns <code>this-&gt;data-&gt;decode_char_func(ch)</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#char_encoding_function_pointers">encode_char_f</a>&lt;char_size&gt; encode_char_func() const noexcept;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#char_encoding_function_pointers">encode_fill_f</a>&lt;char_size&gt; encode_fill_func() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;encode_fill_func</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#char_encoding_function_pointers">write_replacement_char_f</a>&lt;char_size&gt; write_replacement_char_func() const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;write_replacement_char_func</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;4, CharSize&gt; from_u32() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;from_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 4&gt; to_u32() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;to_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, CharSize&gt; sanitizer() const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;sanitizer</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 1&gt; find_transcoder_to
    ( std::integral_constant&lt;std::size_t, 1&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_to_1byte_char_encoding(id)</code> if such pointer
to function is not null. Otherwise returns an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;CharSize, 2&gt; find_transcoder_to
    ( std::integral_constant&lt;std::size_t, 2&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_to_2bytes_char_encoding(id)</code> if such pointer
to function is not null. Otherwise returns an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;1, CharSize&gt; find_transcoder_from
    ( std::integral_constant&lt;std::size_t, 1&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_from_1byte_char_encoding(id)</code> if such pointer
to function is not null. Otherwise returns an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp"><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;2, CharSize&gt; find_transcoder_from
    ( std::integral_constant&lt;std::size_t, 2&gt;, <a href="#char_encoding_id">char_encoding_id</a> id) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>this-&gt;data-&gt;transcoder_from_2bytes_char_encoding(id)</code> if such pointer
to function is not null. Otherwise returns an
<a href="#UnderlyingTranscoder_null">null transcoder</a>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="find_transcoder">5.12. Function template <code>find_transcoder</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename SrcEncoding, typename DestEncoding&gt;
auto find_transcoder(SrcEncoding src, DestEncoding dest);</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Requirements</dt>
<dd>
<p><code>SrcEncoding</code> and <code>DestEncoding</code> are <em><a href="#UnderlyingCharEncoding">UnderlyingCharEncoding</a></em> types.</p>
</dd>
<dt class="hdlist1">Return type</dt>
<dd>
<p>A type that is <em><a href="#UnderlyingTranscoder">UnderlyingTranscoder</a></em></p>
</dd>
<dt class="hdlist1">Return value</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Returns the default value of <code><a href="#static_underlying_transcoder">static_underlying_transcoder</a>&lt;SrcID, DestID&gt;</code>
if such template instantiation is defined and
<code>SrcEncoding</code> is ( or derives from ) <code><a href="#static_underlying_char_encoding">static_underlying_char_encoding</a>&lt;SrcID&gt;</code> and
<code>DestEncoding</code> is ( or derives from ) <code><a href="#static_underlying_char_encoding">static_underlying_char_encoding</a>&lt;DestID&gt;</code>;</p>
</li>
<li>
<p>otherwise, returns <code>src.<a href="#UnderlyingCharEncoding_sanitizer">sanitizer</a>()</code> if
<code>src.<a href="#UnderlyingCharEncoding_id">id</a>()</code> is equal to <code>dest.<a href="#UnderlyingCharEncoding_id">id</a>()</code>
and <code>SrcEncoding::char_size</code> is equal to <code>DestEncoding::char_size</code>;</p>
</li>
<li>
<p>otherwise, returns <code>src.<a href="#UnderlyingCharEncoding_to_u32">to_u32</a>()</code>
if <code>DestEncoding::char_size</code> is equal to <code>4</code>;</p>
</li>
<li>
<p>otherwise, returns <code>dest.<a href="#UnderlyingCharEncoding_from_u32">from_u32</a>()</code>
if <code>SrcEncoding::char_size</code> is equal to <code>4</code>;</p>
</li>
<li>
<p>otherwise, returns
<code>src.<a href="#UnderlyingCharEncoding_find_transcoder_to">find_transcoder_to</a>(x, dest.id())</code>
if such expression
is well formed and returns a <a href="#UnderlyingTranscoder_null">non null transcoder</a>
, where <code>x</code> is the value of
<code>std::integral_constant&lt;std::size_t, DestEncoding::char_size&gt;()</code>;</p>
</li>
<li>
<p>otherwise, returns
<code>dest.<a href="#UnderlyingCharEncoding_find_transcoder_from">find_transcoder_from</a>(x, src.id())</code>
 if such expression is well formed, where <code>x</code> is the value of
 <code>std::integral_constant&lt;std::size_t, SrcEncoding::char_size&gt;()</code>;</p>
</li>
<li>
<p>otherwise returns a default constructed ( thus null )
<code><a href="#dynamic_underlying_transcoder">dynamic_underlying_transcoder</a>&lt;SrcEncoding::char_size, DestEncoding::char_size&gt;</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>find_transcoder</code> returns an <a href="#UnderlyingTranscoder_null">null transcoder</a>
, you still can use <code><a href="#decode_encode">decode_encode</a></code> and <code>decode_encode_size</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode">5.13. Function template <code>decode_encode</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template&lt;std::size_t SrcCharSize, std::size_t DestCharSize&gt;
void decode_encode
    ( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;DestCharSize&gt;&amp; ob
    , <a href="#char_encoding_function_pointers">transcode_f</a>&lt;SrcCharSize, 4&gt; to_u32
    , <a href="#char_encoding_function_pointers">transcode_f</a>&lt;4, DestCharSize&gt; from_u32
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#invalid_seq_notifier">invalid_seq_notifier</a> inv_seq_notifier
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli );

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>Converts the content in <code>src</code> to UTF-32 using <code>to_u32</code>,
then writes it into <code>ob</code> using <code>from_u32</code>.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Postcondition
</td>
<td class="hdlist2">
<p><code>ob.<a href="#underlying_outbuff_recycle">recycle</a>()</code> is not called if
<code>ob.<a href="#underlying_outbuff_size">size</a>()</code> is not less then the value returned by
<code><a href="#decode_encode_size">decode_encode_size</a>(to_u32, size_calc_func, src, src_size, inv_seq_notifier, surr_poli)</code>,
where <code>size_calc_func</code> is the return value of
<code>dest_enc.<a href="#UnderlyingCharEncoding_from_u32">from_u32</a>().<a href="#UnderlyingTranscoder_transcode_size_func">transcode_size_func</a>()</code>,
where <code>dest_enc</code> is the <em>UnderlyingCharEncoding</em> object such that the return value of
<code>dest_enc.<a href="#UnderlyingCharEncoding_to_u32">to_u32</a>().<a href="#UnderlyingTranscoder_transcode_func">transcode_func</a>()</code>
is equal to <code>to_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="decode_encode_size">5.14. Function template <code>decode_encode_size</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template&lt;std::size_t SrcCharSize&gt;
std::size_t decode_encode_size
    ( <a href="#char_encoding_function_pointers">transcode_f</a>&lt;SrcCharSize, 4&gt; to_u32
    , <a href="#char_encoding_function_pointers">transcode_size_f</a>&lt;4&gt; size_calc_func
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;SrcCharSize&gt;* src
    , std::size_t src_size
    , <a href="#invalid_seq_notifier">invalid_seq_notifier</a> inv_seq_notifier
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli );

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return of <code>size_calc_func</code> called over the UTF-32 content obtained
by passing <code>src</code> to <code>to_u32</code>.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="char_encoding_c">5.15. Facet category template <code>char_encoding_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
struct char_encoding_c {
    static constexpr bool constrainable = false;
    static constexpr <a href="#utf">utf</a>&lt;CharT&gt; get_default() noexcept;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a type to be a facet of <code>char_encoding_c&lt;CharT&gt;</code> it has to
to be <em>CharEncodingFacet</em> of <code>CharT</code></p>
</div>
</div>
<div class="sect2">
<h3 id="CharEncodingFacet">5.16. Type requirement <em>CharEncodingFacet</em></h3>
<div class="paragraph">
<p>Given:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharT</code>, a character type</p>
</li>
<li>
<p><code>X</code>, <em>CharEncodingFacet</em> type of <code>CharT</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following must hold:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>X</code> is <a href="https://en.cppreference.com/w/cpp/named_req/CopyConstructible"><em>CopyConstructible</em></a>.</p>
</li>
<li>
<p><code>X</code> is a <em><a href="#UnderlyingCharEncoding">UnderlyingCharEncoding</a></em> type for <code>sizeof(CharT)</code></p>
</li>
<li>
<p><code>X::char_type</code> is a type alias to <code>CharT</code></p>
</li>
<li>
<p><code>X::category</code> is a type alias to <code>char_encoding_c&lt;CharT&gt;</code>;</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There are two class templates that satisfy <em>CharEncodingFacet</em>: <code><a href="#static_char_encoding">static_char_encoding</a></code> and <code><a href="#dynamic_char_encoding">dynamic_char_encoding</a></code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="static_char_encoding">5.17. Class template <code>static_char_encoding</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename CharT, <a href="#char_encoding_id">char_encoding_id</a> CSID&gt;
class static_char_encoding: public <a href="#static_underlying_char_encoding">static_underlying_char_encoding</a>&lt;CSID&gt; {
public:
    static_assert(sizeof(CharT) == <a href="#static_underlying_char_encoding">static_underlying_char_encoding</a>&lt;CSID&gt;::<a href="#UnderlyingCharEncoding_char_size">char_size</a>);
    using category = <a href="#char_encoding_c">char_encoding_c</a>&lt;CharT&gt;;
    using char_type = CharT;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="static_char_encoding_aliases">5.18. Type aliases for encodings</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
using ascii = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_ascii</a>&gt;;

template &lt;typename CharT&gt;
using iso_8859_1 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_iso_8859_1</a>&gt;;

template &lt;typename CharT&gt;
using iso_8859_3 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_iso_8859_3</a>&gt;;

template &lt;typename CharT&gt;
using iso_8859_15 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_iso_8859_15</a>&gt;;

template &lt;typename CharT&gt;
using windows_1252 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_windows_1252</a>&gt;;

template &lt;typename CharT&gt;
using utf8 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_utf8</a>&gt;;

template &lt;typename CharT&gt;
using utf16 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_utf16</a>&gt;;

template &lt;typename CharT&gt;
using utf32 = <a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, <a href="#char_encoding_id">eid_utf32</a>&gt;;

template &lt;typename CharT&gt;
using utf = /* see below */;

} // namespace strf</code></pre>
</div>
</div>
<div id="utf" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
using utf = /* ... */;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>utf&lt;CharT&gt;</code> is an alias to <code>utf8&lt;CharT&gt;</code>, <code>utf16&lt;CharT&gt;</code> or <code>utf32&lt;CharT&gt;</code>,
depending on the value of <code>sizeof(CharT)</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dynamic_char_encoding">5.19. Class template <code>dynamic_char_encoding</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename CharT&gt;
class dynamic_char_encoding: public <a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a>&lt;sizeof(CharT)&gt; {
public:
    using category = <a href="#char_encoding_c">char_encoding_c</a>&lt;CharT&gt;;
    using char_type = CharT;

    dynamic_char_encoding(const dynamic_char_encoding&amp;) = default;

    explicit dynamic_char_encoding(const <a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a>&lt;sizeof(CharT)&gt;&amp;);

    template &lt;<a href="#char_encoding_id">char_encoding_id</a> EncodingID&gt;
    explicit dynamic_char_encoding(<a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, EncodingID&gt; scs);
};

} // namespace strf</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">dynamic_char_encoding(const dynamic_char_encoding&amp;);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Trivial copy constructor</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">explicit dynamic_char_encoding(const <a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a>&lt;sizeof(CharT)&gt;&amp; x);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Initializes base <code><a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a>&lt;sizeof(CharT)&gt;</code> from <code>x</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;<a href="#char_encoding_id">char_encoding_id</a> EncodingID&gt;
explicit dynamic_char_encoding(<a href="#static_char_encoding">static_char_encoding</a>&lt;CharT, EncodingID&gt; enc);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Initializes base <code><a href="#dynamic_underlying_char_encoding">dynamic_underlying_char_encoding</a>&lt;sizeof(CharT)&gt;</code>
with <code>enc.to_dynamic()</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_width_calculation">6. Width Calculation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="width_calculator_c">6.1. Facet category <code>width_calculator_c</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

struct width_calculator_c
{
    static constexpr bool constrainable = true;

    static constexpr <a href="#fast_width">fast_width</a> get_default() noexcept;
};

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a type to be a facet of the <code>width_calculator_c</code> category, it has to
satisfy the <em><a href="#WidthCalculator">WidthCalculator</a></em> requirements.</p>
</div>
<div class="sect3">
<h4 id="WidthCalculator">6.1.1. Type requirement <em>WidthCalculator</em></h4>
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CharSize</code>, an constexpr integer value equal to <code>1</code>, <code>2</code> or <code>4</code></p>
</li>
<li>
<p><code>Encoding</code>, an <em><a href="#UnderlyingCharEncoding">UnderlyingCharEncoding</a></em> type for value <code>CharSize</code></p>
</li>
<li>
<p><code>encoding</code>, an lvalue reference of type <code>Encoding</code></p>
</li>
<li>
<p><code>ch</code> a value of type <code><a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;</code></p>
</li>
<li>
<p><code>limit</code>, a value of type <code><a href="#width_t">width_t</a></code></p>
</li>
<li>
<p><code>str</code>, a value of type <code>const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;*</code>
pointing to string encoded according to <code>encoding</code>.</p>
</li>
<li>
<p><code>str_len</code>, a value of type <code>std::size_t</code> equal to the length of string <code>str</code>.</p>
</li>
<li>
<p><code>surr_poli</code>, a value of type <code><a href="#surrogate_policy">surrogate_policy</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a type <code>X</code> to be <em>WidthCalculator</em>, given an object <code>x</code> of type <code>X</code>,
the following syntax and requirements have to be satisfied:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">X::category</code></pre>
</div>
</div>
<div class="paragraph">
<p>A type alias to <code><a href="#width_calculator_c">width_calculator_c</a></code>.</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.char_width(encoding, ch)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_t">width_t</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The width of <code>ch</code> when encoded according to <code>encoding</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.str_width(encoding, limit, str, str_len, surr_poli)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_t">width_t</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The width of the string <code>str</code> if it is less than <code>limit</code>.
Otherwise, it can be any value that is greater than or
equal to <code>limit</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">x.str_width_and_pos(encoding, limit, str, str_len, surr_poli)</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Calculates the width of <code>str</code>. If such value is less than
<code>limit</code>, then calculates the size of the substring of <code>str</code>
whose width is equal to <code>limit</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#width_and_pos">width_and_pos</a></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A value <code>ret</code> of type <code><a href="#width_and_pos">width_and_pos</a></code>, such that</p>
<div class="ulist">
<ul>
<li>
<p><code>ret.pos</code> is the greatest value that is less than or equal to <code>str_len</code>
such that <code>x.width(encoding, width_max, str, ret.pos, surr_poli).width</code>
is less than or equal to <code>limit</code>.</p>
</li>
<li>
<p><code>ret.width</code> is the width of the substring of <code>str</code> with size <code>ret.pos</code>
that starts at the same position of <code>str</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The library provides three classes and one class template that
      satisfy _WidthCalculator: <code><a href="#fast_width">fast_width</a></code>, <code><a href="#width_as_fast_u32len">width_as_fast_u32len</a></code>,
      <code><a href="#width_as_u32len">width_as_u32len</a></code> and `<a href="#width_by_func">width_by_func</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="width_and_pos">6.1.2. Struct <code>width_and_pos</code></h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">struct width_and_pos {
    <a href="#width_t">width_t</a> width;
    std::size_t pos;
};</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fast_width">6.2. Class <code>fast_width</code></h3>
<div class="paragraph">
<p>Class <code>fast_width</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>
that evaluates the width of a string as its size.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">class fast_width final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#fast_width_char_width">char_width</a>
        ( CharEncoding
        , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#fast_width_str_width">str_width</a>
        ( CharEncoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;*
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;

    template &lt;typename CharEncoding&gt;
    constexpr <a href="#width_and_pos">width_and_pos</a> <a href="#fast_width_str_width_and_pos">str_width_and_pos</a>
        ( CharEncoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;*
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;
};</code></pre>
</div>
</div>
<div id="fast_width_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
<a href="#width_t">width_t</a> char_width
    ( CharEncoding
    , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="fast_width_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_t">width_t</a> str_width
    ( CharEncoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;*
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>str_len</code>, if <code>str_len</code> is less than or equal to <code>limit.floor()</code></p>
</li>
<li>
<p>otherwise, <code>limit</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="fast_width_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_and_pos">width_and_pos</a> str_width_and_pos
    ( CharEncoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;*
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>if <code>limit &lt;= 0</code> is <code>true</code>, then <code>ret.width</code> and <code>ret.pos</code> are <code>0</code>;</p>
</li>
<li>
<p>otherwise, if <code>limit.floor()</code> is less than <code>str_len</code>, then
<code>ret.width</code> and <code>ret.pos</code> are equal to <code>limit.floor()</code>;</p>
</li>
<li>
<p>otherwise, <code>ret.width</code> and <code>ret.pos</code> are equal to <code>str_len</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_as_fast_u32len">6.3. Class <code>width_as_fast_u32len</code></h3>
<div class="paragraph">
<p>Class <code>width_as_fast_u32len</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>.
It evaluates the width of a string as the number of Unicode code points.
However, to gain performance and differently from <code><a href="#width_as_u32len">width_as_u32len</a></code>,
it assumes that the measured string is totally conformant to its encoding.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">class width_as_fast_u32len final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_fast_u32len_char_width">char_width</a>
        ( CharEncoding encoding
        , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_fast_u32len_str_width">str_width</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;

    template &lt;typename CharEncoding&gt;
    constexpr <a href="#width_and_pos">width_and_pos</a> <a href="#width_as_fast_u32len_str_width_and_pos">str_width_and_pos</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;
};</code></pre>
</div>
</div>
<div id="width_as_fast_u32len_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
<a href="#width_t">width_t</a> char_width
    ( CharEncoding
    , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_fast_u32len_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_t">width_t</a> str_width
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>0</code>, if <code>limit &lt;= 0</code> is <code>true</code></p>
</li>
<li>
<p>otherwise, <code>encoding.<a href="#UnderlyingCharEncoding_codepoints_fast_count">codepoints_fast_count</a>(str, str_len, limit.floor()).count</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_fast_u32len_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_and_pos">width_and_pos</a> str_width_and_pos
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>If <code>limit &lt;= 0</code> is <code>true</code>, then then <code>ret.width</code> and <code>ret.pos</code> are <code>0</code>;</p>
</li>
<li>
<p>otherwise, <code>ret.width</code> is equal to <code>ret2.count</code> and <code>ret.pos</code> is equal
to <code>encoding.<a href="#UnderlyingCharEncoding_codepoints_fast_count">codepoints_fast_count</a>(str, str_len, lim).pos</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_as_u32len">6.4. Class <code>width_as_u32len</code></h3>
<div class="paragraph">
<p>Class <code>width_as_fast_u32len</code> is a facet of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>.
It evaluates the width of a string as the number of Unicode code points,
assuming that any non-conformity to the corresponding encoding is replaced
by one codepoint ( following the semantics of <code>{invalid_seq_policy}::replace</code> ).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">class width_as_u32len final
{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_u32len_char_width">char_width</a>
        ( CharEncoding encoding
        , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_as_u32len_str_width">str_width</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;

    template &lt;typename CharEncoding&gt;
    constexpr <a href="#width_and_pos">width_and_pos</a> <a href="#width_as_u32len_str_width_and_pos">str_width_and_pos</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;
};</code></pre>
</div>
</div>
<div id="width_as_u32len_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
<a href="#width_t">width_t</a> char_width
    ( CharEncoding
    , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>1</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_u32len_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_t">width_t</a> str_width
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<div class="ulist">
<ul>
<li>
<p><code>0</code>, if <code>limit &lt;= 0</code> is <code>true</code></p>
</li>
<li>
<p>otherwise, <code>encoding.<a href="#UnderlyingCharEncoding_codepoints_robust_count">codepoints_robust_count</a>(str, str_len, limit.floor()).count</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_as_u32len_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_and_pos">width_and_pos</a> str_width_and_pos
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> ) const noexcept;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that</p>
<div class="ulist">
<ul>
<li>
<p>If <code>limit &lt;= 0</code> is <code>true</code>, then then <code>ret.width</code> and <code>ret.pos</code> are <code>0</code>;</p>
</li>
<li>
<p>otherwise, <code>ret.width</code> is equal to <code>ret2.count</code> and <code>ret.pos</code> is equal to
<code>encoding.<a href="#UnderlyingCharEncoding_codepoints_robust_count">codepoints_robust_count</a>(str, str_len, lim).pos</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="width_by_func">6.5. Class template <code>width_by_func</code></h3>
<div class="paragraph">
<p>The instances of the <code>width_by_func</code> class template are facets
of the category <code><a href="#width_calculator_c">width_calculator_c</a></code>.
It calculates the width of a string by converting it to UTF-32,
following the policy associated to <code>{invalid_seq_policy}::replace</code>,
and then calling the provided function to evaluate the width
of each UTF-32 character.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharWidthFunc&gt;
class width_by_func{
public:
    using category = <a href="#width_calculator_c">width_calculator_c</a>;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_by_func_char_width">char_width</a>
        ( CharEncoding charste
        , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ) const;

    template &lt;typename CharEncoding&gt;
    <a href="#width_t">width_t</a> <a href="#width_by_func_str_width">str_width</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const;

    template &lt;typename CharEncoding&gt;
    constexpr <a href="#width_and_pos">width_and_pos</a> <a href="#width_by_func_str_width_and_pos">str_width_and_pos</a>
        ( CharEncoding encoding
        , <a href="#width_t">width_t</a> limit
        , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
        , std::size_t str_len
        , <a href="#surrogate_policy">surrogate_policy</a> ) const;

private:

    const CharWidthFunc func_; // exposition only
};</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_compile_time_requirements">6.5.1. Compile-time requirements</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>Given</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ch</code>, a value of type <code>char32_t</code></p>
</li>
<li>
<p><code>func</code>, a object of type <code>CharWidthFunc</code> or <code>const CharWidthFunc</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The expression <code>func(ch)</code> must be well formed and the return type
must be <a href="#width_t">width_t</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_member_functions_3">6.5.2. Member functions</h4>
<div id="width_by_func_char_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
<a href="#width_t">width_t</a> char_width
    ( CharEncoding encoding
    , <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt; ch) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code>func_(encoding.<a href="#CharEncoding_decode_char">decode_char</a>(ch))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_by_func_str_width" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_t">width_t</a> str_width
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a>  surr_poli) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The sum of the values of <code>func_(ch32)</code>, where <code>ch32</code> is
each of the <code>char32_t</code> values that are written into <code>ob</code>&#8201;&#8212;&#8201;an object whose type derives from <code><a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;4&gt;</code>&#8201;&#8212;&#8201;by the call</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">encoding.<a href="#UnderlyingCharEncoding_to_u32">to_u32</a>().<a href="#UnderlyingTranscoder_transcode">transcode</a>
    ( ob, str, str_len, {invalid_seq_policy}::replace, surr_poli )</code></pre>
</div>
</div>
<div class="paragraph">
<p>, if such value is less than or equal to <code>limit</code>. Otherwise, the return value
  can be anyone that is greater than or equal to <code>limit</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="width_by_func_str_width_and_pos" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharEncoding&gt;
constexpr <a href="#width_and_pos">width_and_pos</a> str_width_and_pos
    ( CharEncoding encoding
    , <a href="#width_t">width_t</a> limit
    , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharEncoding::char_size&gt;* str
    , std::size_t str_len
    , <a href="#surrogate_policy">surrogate_policy</a> surr_poli) const;</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>The return value <code>ret</code> is such that:</p>
<div class="ulist">
<ul>
<li>
<p><code>ret.width</code> is the sum of the values of <code>func_(ch32)</code>, where <code>ch32</code> is
each of the <code>char32_t</code> values that are written into <code>ob</code> by the call</p>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">encoding.<a href="#UnderlyingCharEncoding_to_u32">to_u32</a>().<a href="#UnderlyingTranscoder_transcode">transcode</a>
    ( ob, str, ret.pos, {invalid_seq_policy}::replace, surr_poli )</code></pre>
</div>
</div>
<div class="paragraph">
<p>, where <code>ob</code> is any object whose type derives from <code><a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;4&gt;</code>.</p>
</div>
</li>
<li>
<p><code>ret.pos</code> is the greatest value that is less than or equal to <code>str_len</code>
such that <code>str_width_and_pos(encoding, limit, str, ret.pos, surr_poli).width</code>
is less than or equal to <code>limit</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="make_width_calculator">6.6. Function template <code>make_width_calculator</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharWidthFunc&gt;
<a href="#width_by_func">width_by_func</a>&lt;CharWidthFunc&gt; make_width_calculator(CharWidthFunc f);</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p><code><a href="#width_by_func">width_by_func</a>&lt;CharWidthFunc&gt;{f}</code></p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="width_t">6.7. Class <code>width_t</code></h3>
<div class="paragraph">
<p>The <code>width_t</code> class implements signed
<a href="https://en.wikipedia.org/wiki/Q_(number_format)">Q16.16</a> arithmetics and
is used to represent width of textual content when
<a href="#alignment_format">text alignment formatting</a> is used.
The value of <code>width_t(1)</code> corresponds to an <a href="https://en.wikipedia.org/wiki/En_(typography)">en</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

class width_t {
public:
    struct from_underlying_tag{};
    constexpr width_t() noexcept;
    constexpr width_t(std::int16_t) noexcept;
    constexpr width_t(const width_t&amp;) noexcept;
    constexpr width_t(from_underlying_tag, std::int32_t) noexcept;

    constexpr width_t&amp; operator=(const width_t&amp; other) noexcept;
    constexpr width_t&amp; operator=(std::int16_t&amp; x) noexcept;

    constexpr bool operator==(const width_t&amp; other) const noexcept;
    constexpr bool operator!=(const width_t&amp; other) const noexcept;
    constexpr bool operator&lt;(const width_t&amp; other) const noexcept;
    constexpr bool operator&gt;(const width_t&amp; other) const noexcept;
    constexpr bool operator&lt;=(const width_t&amp; other) const noexcept;
    constexpr bool operator&gt;=(const width_t&amp; other) const noexcept;

    constexpr bool is_integral() const noexcept;
    constexpr std::int16_t floor() const noexcept;
    constexpr std::int16_t ceil() const noexcept;
    constexpr std::int16_t round() const noexcept;

    constexpr width_t operator-() const noexcept;
    constexpr width_t operator+() const noexcept;
    constexpr width_t&amp; operator+=(width_t other) noexcept;
    constexpr width_t&amp; operator-=(width_t other) noexcept;
    constexpr width_t&amp; operator*=(std::int16_t m) noexcept;
    constexpr width_t&amp; operator/=(std::int16_t d) noexcept;
    constexpr width_t&amp; operator*=(width_t other) noexcept;
    constexpr width_t&amp; operator/=(width_t other) noexcept;

    constexpr std::int32_t underlying_value() const noexcept;
    constexpr static width_t from_underlying(std::int32_t) noexcept;

private:
    std::int32_t _underlying_value; // exposition only
};

constexpr width_t width_max = width_t::from_underlying(INT32_MAX);
constexpr width_t width_min = width_t::from_underlying(INT32_MIN);

constexpr bool operator==(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator==(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator!=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator!=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&lt; (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&lt; (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&lt;=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&lt;=(std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&gt; (width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&gt; (std::int16_t lhs, width_t rhs) noexcept;
constexpr bool operator&gt;=(width_t lhs, std::int16_t rhs) noexcept;
constexpr bool operator&gt;=(std::int16_t lhs, width_t rhs) noexcept;

constexpr width_t operator+(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator+(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator-(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator*(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator*(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator*(width_t lhs, std::int16_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(std::int16_t lhs, width_t rhs) noexcept;
constexpr width_t operator/(width_t lhs, std::int16_t rhs) noexcept;

constexpr width_t checked_add(width_t lhs, width_t rhs) noexcept;
constexpr width_t checked_subtract(width_t lhs, std::int64_t rhs) noexcept;
constexpr width_t checked_subtract(width_t lhs, width_t rhs) noexcept;
constexpr width_t checked_mul(width_t lhs, std::uint32_t rhs) noexcept;

} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>to-do</em></p>
</div>
</div>
<div class="sect2">
<h3 id="width_literal">6.8. <code>width_t</code> literal <code>_w</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
namespace width_literal {

template &lt;char...C&gt;
constexpr <a href="#width_t">width_t</a> operator "" _w()

} // namespace width_literal
} // namespace strf</code></pre>
</div>
</div>
<div class="paragraph">
<p>The suffix <code>_w</code> can be aplied in floating-points literals in fixed notations as well
as integer literals.</p>
</div>
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">using namespace strf::width_literal;

strf::width_t x = 1.5_w;
x += 0.25_w;
x += 1_w;
assert(x == 2.75_w);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_numeric_punctuation">7. Numeric punctuation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em> To-do </em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_miscellaneous">8. Miscellaneous</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code_lettercase_code_facet">8.1. The <code>lettercase</code> facet</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

enum class lettercase { lower = /*...*/, mixed = /*...*/, upper = /*...*/ };

constexpr lettercase lowercase = lettercase::lower;
constexpr lettercase mixedcase = lettercase::mixed;
constexpr lettercase uppercase = lettercase::upper;

struct lettercase_c {
    static constexpr bool constrainable = true;
    constexpr static lettercase get_default() noexcept
    {
        return lettercase::lower;
    }
};

template &lt;&gt;
struct {facet_traits}&lt;lettercase&gt; {
    using category = lettercase_c;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_type_traits">8.2. Type traits</h3>
<div class="paragraph">
<p>The table below list class templates that satisfy
<a href="https://en.cppreference.com/w/cpp/named_req/UnaryTypeTrait">UnaryTypeTrait</a>.
They are created to be used in the <code>constrain</code> function template to filter
printable types.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_int_number</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code> and the corresponding unsigned types</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_char</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches <code>char</code>, <code>char8_t</code>, <code>wchar_t</code>, <code>char16_t</code>, and <code>char32_t</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_string</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches strings.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><em>to-do</em></p>
</div>
</div>
<div class="sect2">
<h3 id="tag">8.3. Class template <code>tag</code></h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;typename... &gt;
struct tag
{
    explicit tag() = default;
};

template &lt;typename T&gt;
struct tag&lt;T&gt;
{
    explicit constexpr STRF_HD tag() noexcept { }
    using type = T;
};

} // namespace strf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="__code_outbuff_code_writing_functions">8.4. <code>Outbuff</code> writing functions</h3>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template &lt;std::size_t CharSize&gt;
void write( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data
          , std::size_t data_size );

template &lt;std::size_t CharSize&gt;
void write( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data_end );

template &lt;typename CharT&gt;
void write( <a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;CharT&gt;&amp; ob
          , const CharT* data
          , std::size_t count );

template &lt;typename CharT&gt;
void write( <a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;CharT&gt;&amp; ob
          , const CharT* data
          , const CharT* data_end );

void write(<a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;char&gt;&amp; ob, const char* cstr);

void write(<a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;wchar_t&gt;&amp; ob, const wchar_t* cstr);

} // namespace strf</code></pre>
</div>
</div>
<div id="underlying_outbuff_write_range" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
void write( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data_end );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes the the range [ <code>data</code>, <code>data_end</code> ) into <code>ob</code>, calling <code>ob.recycle()</code>
how many times are necessary.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="underlying_outbuff_write_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;std::size_t CharSize&gt;
void write( <a href="outbuff_hpp.html#underlying_outbuff">underlying_outbuff</a>&lt;CharSize&gt;&amp; ob
          , const <a href="outbuff_hpp.html#underlying_char_type">underlying_char_type</a>&lt;CharSize&gt;* data
          , std::size_t data_size );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, data, data + data_size)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="basic_outbuff_write_range" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void write( {basic_outbuff}&lt;CharT&gt;&amp; ob
          , const CharT* data
          , const CharT* data_end );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Writes the the range [ <code>data</code>, <code>data_end</code> ) into <code>ob</code>, calling <code>ob.recycle()</code>
how many times are necessary.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="basic_outbuff_write_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">template &lt;typename CharT&gt;
void write( {basic_outbuff}&lt;CharT&gt;&amp; ob
          , const CharT* data
          , std::size_t data_size );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, data, data + data_size)</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="basic_outbuff_write_cstr" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void write( {basic_outbuff}&lt;char&gt;&amp; ob
          , const char* cstr );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, cstr, std::strlen(cstr))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="basic_outbuff_write_wcstr" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">void write( <a href="outbuff_hpp.html#basic_outbuff">basic_outbuff</a>&lt;wchar_t&gt;&amp; ob
          , const wchar_t* wcstr );</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Effect
</td>
<td class="hdlist2">
<p>Same as <code>write(ob, wcstr, std::wstrlen(wcstr))</code></p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_destination_markers">8.5. Destination markers</h3>
<div id="to_char_ptr_count" class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

<em>/* see below */</em> to(char8_t*  dest, std::size_t count);
<em>/* see below */</em> to(char*     dest, std::size_t count);
<em>/* see below */</em> to(char16_t* dest, std::size_t count);
<em>/* see below */</em> to(char32_t* dest, std::size_t count);
<em>/* see below */</em> to(wchar_t*  dest, std::size_t count);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type
</td>
<td class="hdlist2">
<p><code><a href="#destination">destination_no_reserve</a>&lt;OBC&gt;</code>, where <code>OBC</code> is an implementation-defined
type that satifies <em><a href="#OutbuffCreator">OutbuffCreator</a></em>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
Return value
</td>
<td class="hdlist2">
<p>A destination object whose internal <em><a href="#OutbuffCreator">OutbuffCreator</a></em> object <code>obc</code>
is such that <code>obc.create()</code> returns a <code><a href="outbuff_hpp.html#basic_cstr_writer">basic_cstr_writer</a>&lt;CharT&gt;</code> object initialized
with <code>dest</code> and <code>count</code>, where, <code>CharT</code> is <code>std::remove_reference_t&lt;decltype(*dest)&gt;</code>.</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="to_char_array" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

template&lt;std::size_t N&gt; <em>/* see below */</em> to(char8_t  (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char     (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char16_t (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(char32_t (&amp;dest)[N]);
template&lt;std::size_t N&gt; <em>/* see below */</em> to(wchar_t  (&amp;dest)[N]);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as <code>to(dest, N)</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div id="to_char_range" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {

<em>/* see below */</em> to(char8_t*  dest,  char8_t*  end);
<em>/* see below */</em> to(char*     dest,  char*     end);
<em>/* see below */</em> to(char16_t* dest,  char16_t* end);
<em>/* see below */</em> to(char32_t* dest,  char32_t* end);
<em>/* see below */</em> to(wchar_t*  dest,  wchar_t*  end);

} // namespace strf</code></pre>
</div>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
Return type and value
</td>
<td class="hdlist2">
<p>Same as <code>to(dest, (std::size_t)(end - dest))</code>;</p>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="alignment_format_functions">8.6. Alignment format functions</h3>
<div class="hdlist">
<div class="title">Text aligment format function</div>
<table>
<tr>
<td class="hdlist1">
<code>operator&gt;(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Align to the right ( Or to the left right-to-left (RTL) script )</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator&lt;(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Align to the left ( Or to the right right-to-left (RTL) script )</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator^(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Center alignment</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>operator%(std::int16_t width)</code>
</td>
<td class="hdlist2">
<p>Split the content, as in <code>std::internal</code>.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>fill(char32_t ch)</code>
</td>
<td class="hdlist2">
<p>Set the fill character.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_format_function_aliases">8.7. Format function aliases</h3>
<div id="format_function_aliases" class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-cpp" data-lang="cpp">namespace strf {
inline namespace format_functions {

template &lt;typename T&gt;
constexpr auto hex(const T&amp; value)
{
    return fmt(value).hex();
}

template &lt;typename T&gt;
constexpr auto dec(const T&amp; value)
{
    return fmt(value).dec();
}

template &lt;typename T&gt;
constexpr auto oct(const T&amp; value)
{
    return fmt(value).oct();
}

template &lt;typename T&gt;
constexpr auto bin(const T&amp; value)
{
    return fmt(value).bin();
}

template &lt;typename T&gt;
constexpr auto left(const T&amp; value, int width)
{
    return fmt(value) &lt; width;
}

template &lt;typename T&gt;
constexpr auto right(const T&amp; value, int width)
{
    return fmt(value) &gt; width;
}

template &lt;typename T&gt;
constexpr auto split(const T&amp; value, int width)
{
    return fmt(value) % width;
}

template &lt;typename T&gt;
constexpr auto center(const T&amp; value, int width)
{
    return fmt(value) ^ width;
}

template &lt;typename T&gt;
constexpr auto left(const T&amp; value, int width, char32_t fill)
{
    return fmt(value).fill(fill) &lt; width;
}

template &lt;typename T&gt;
constexpr auto right(const T&amp; value, int width, char32_t fill)
{
    return fmt(value).fill(fill) &gt; width;
}

template &lt;typename T&gt;
constexpr auto conv(const T&amp; value)
{
    return fmt(value).conv();
}

template &lt;typename T, typename CharEncoding&gt;
constexpr auto conv(const T&amp; value, const CharEncoding&amp; cs)
{
    return fmt(value).conv(cs);
}

template &lt;typename T&gt;
constexpr auto sani(const T&amp; value)
{
    return fmt(value).sani();
}

template &lt;typename T, typename CharEncoding&gt;
constexpr auto sani(const T&amp; value, const CharEncoding&amp; cs)
{
    return fmt(value).sani(cs);
}

} // inline namespace format_functions
} // namespace strf</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2020-06-18 19:06:41 -03
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>prettyPrint()</script>
</body>
</html>
